<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft Ultra Otimizado - Sistema Completo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      overflow: hidden;
      font-family: 'Courier New', monospace;
      background: #000;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.9);
      padding: 12px 18px;
      border-radius: 8px;
      z-index: 100;
      font-size: 12px;
      line-height: 1.8;
      max-width: 250px;
    }
    .performance-good { color: #00ff00; }
    .performance-ok { color: #ffff00; }
    .performance-bad { color: #ff0000; }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      z-index: 100;
      pointer-events: none;
    }
    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 0 3px rgba(0,0,0,0.8);
    }
    #crosshair::before {
      width: 2px;
      height: 20px;
      left: 9px;
    }
    #crosshair::after {
      width: 20px;
      height: 2px;
      top: 9px;
    }

    /* Invent√°rio Expandido */
    #inventory-bar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 5px;
      z-index: 100;
    }
    .inv-slot {
      width: 55px;
      height: 55px;
      background: rgba(0, 0, 0, 0.85);
      border: 3px solid #444;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
      border-radius: 6px;
      position: relative;
    }
    .inv-slot.active {
      border-color: #fff;
      background: rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 15px rgba(255,255,255,0.6);
      transform: scale(1.1);
    }
    .block-icon {
      width: 35px;
      height: 35px;
      margin-bottom: 3px;
      border-radius: 3px;
    }
    .slot-count {
      position: absolute;
      bottom: 2px;
      right: 5px;
      font-size: 10px;
      font-weight: bold;
      color: white;
      text-shadow: 1px 1px 2px black;
    }

    /* Sistema de Vida */
    #health-container {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 3px;
      z-index: 100;
    }
    .heart {
      width: 20px;
      height: 20px;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23ff0000" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
      background-size: contain;
    }
    .heart.half {
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23ff0000" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/><path fill="%23777777" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" transform="scale(-1,1) translate(-24,0)"/></svg>');
    }
    .heart.empty {
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23777777" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
    }

    /* Invent√°rio Completo */
    #inventory-full {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 4px solid #555;
      border-radius: 10px;
      padding: 20px;
      z-index: 200;
      display: none;
      grid-template-columns: repeat(9, 50px);
      gap: 5px;
      max-width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
    }
    #inventory-full.open {
      display: grid;
    }
    .inv-full-slot {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid #666;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      position: relative;
    }
    .inv-full-slot.has-item {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Menu Inicial Moderno */
    #main-menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: 'Minecraft', 'Courier New', monospace;
    }

    .menu-container {
      background: rgba(0, 0, 0, 0.85);
      padding: 40px;
      border-radius: 20px;
      border: 4px solid #4CAF50;
      box-shadow: 0 0 40px rgba(76, 175, 80, 0.5),
      inset 0 0 20px rgba(76, 175, 80, 0.2);
      max-width: 800px;
      width: 90%;
      text-align: center;
      animation: glow 2s infinite alternate;
    }

    @keyframes glow {
      from { box-shadow: 0 0 30px rgba(76, 175, 80, 0.5); }
      to { box-shadow: 0 0 50px rgba(76, 175, 80, 0.8); }
    }

    .menu-title {
      font-size: 48px;
      color: #4CAF50;
      text-shadow: 3px 3px 0 #000,
      0 0 20px #4CAF50;
      margin-bottom: 30px;
      letter-spacing: 3px;
    }

    .menu-subtitle {
      font-size: 20px;
      color: #fff;
      margin-bottom: 40px;
      line-height: 1.6;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      margin: 30px 0;
      padding: 20px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      border: 2px solid #4CAF50;
    }

    .control-item {
      background: rgba(76, 175, 80, 0.1);
      padding: 12px;
      border-radius: 8px;
      text-align: left;
      color: white;
      border: 1px solid #4CAF50;
      transition: all 0.3s;
    }

    .control-item:hover {
      transform: translateY(-3px);
      background: rgba(76, 175, 80, 0.2);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .control-item strong {
      color: #4CAF50;
      font-size: 16px;
      display: block;
      margin-bottom: 5px;
    }

    .features-grid {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 30px 0;
      flex-wrap: wrap;
    }

    .feature {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 10px;
      min-width: 150px;
      transition: transform 0.3s;
    }

    .feature:hover {
      transform: scale(1.05);
    }

    .feature-icon {
      font-size: 36px;
      margin-bottom: 10px;
      display: block;
    }

    .feature-text {
      color: white;
      font-size: 14px;
    }

    .start-button {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      color: white;
      border: none;
      padding: 20px 60px;
      font-size: 24px;
      font-weight: bold;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      margin-top: 20px;
      text-transform: uppercase;
      letter-spacing: 2px;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
    }

    .start-button:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
      background: linear-gradient(135deg, #66BB6A, #388E3C);
    }

    .start-button:active {
      transform: translateY(-2px);
    }

    .menu-footer {
      margin-top: 30px;
      color: #888;
      font-size: 14px;
    }

    /* Barra de Progresso de Quebra */
    .break-progress {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100px;
      height: 8px;
      background: rgba(0,0,0,0.7);
      border-radius: 4px;
      overflow: hidden;
      display: none;
      z-index: 100;
    }
    .break-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000, #ffff00);
      width: 0%;
      transition: width 0.1s;
    }

    /* Controles Mobile */
    .mobile-controls {
      display: none;
      position: fixed;
      z-index: 150;
    }

    @media (max-width: 768px), (pointer: coarse) {
      .mobile-controls {
        display: block;
      }
    }

    /* Joystick Virtual */
    #mobile-joystick {
      position: fixed;
      bottom: 80px;
      left: 30px;
      width: 120px;
      height: 120px;
      background: rgba(0, 0, 0, 0.3);
      border: 3px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      touch-action: none;
    }

    #joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.7);
      border: 2px solid rgba(0, 0, 0, 0.5);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.1s;
    }

    /* √Årea de Look Around */
    #mobile-look {
      position: fixed;
      top: 0;
      right: 0;
      width: 50%;
      height: 100%;
      background: rgba(0, 0, 0, 0.05);
      touch-action: none;
      pointer-events: auto;
    }

    /* Bot√µes de A√ß√£o */
    .mobile-buttons {
      position: fixed;
      bottom: 80px;
      right: 30px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .mobile-btn {
      width: 60px;
      height: 60px;
      background: rgba(0, 0, 0, 0.6);
      border: 3px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
      user-select: none;
      font-weight: bold;
    }

    .mobile-btn:active {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(0.95);
    }

    .mobile-btn.active {
      background: rgba(76, 175, 80, 0.8);
      border-color: #4CAF50;
    }

    /* Bot√µes Superiores */
    .mobile-top-buttons {
      position: fixed;
      top: 80px;
      right: 10px;
      display: flex;
      gap: 10px;
    }

    .mobile-top-btn {
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 8px;
      color: white;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
    }

    /* Indicador de toque */
    .touch-indicator {
      position: fixed;
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      animation: touch-pulse 0.3s;
      z-index: 200;
    }

    @keyframes touch-pulse {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
    }

    /* Ajustes para mobile */
    @media (max-width: 768px) {
      #info {
        font-size: 10px;
        padding: 8px 12px;
        max-width: 200px;
      }

      #inventory-bar {
        bottom: 10px;
        transform: translateX(-50%) scale(0.8);
      }

      .inv-slot {
        width: 45px;
        height: 45px;
      }

      #crosshair {
        width: 15px;
        height: 15px;
      }
    }


    /* ============================================
   MENU DE CONFIGURA√á√ïES MODERNO
   ============================================ */

    #settings-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 2000;
      display: none;
      overflow-y: auto;
      backdrop-filter: blur(10px);
    }

    #settings-menu.open {
      display: flex;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .settings-container {
      max-width: 900px;
      width: 90%;
      margin: auto;
      padding: 30px;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(76, 175, 80, 0.3);
      animation: slideUp 0.4s ease;
    }

    @keyframes slideUp {
      from {
        transform: translateY(50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 2px solid rgba(76, 175, 80, 0.3);
    }

    .settings-header h2 {
      color: #4CAF50;
      font-size: 32px;
      margin: 0;
      text-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
      letter-spacing: 2px;
    }

    .close-settings {
      background: transparent;
      border: 2px solid #ff4444;
      color: #ff4444;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .close-settings:hover {
      background: #ff4444;
      color: white;
      transform: rotate(90deg);
    }

    /* Tabs de Categorias */
    .settings-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    .settings-tab {
      padding: 12px 24px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid transparent;
      color: #ffffff;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 16px;
      font-weight: bold;
    }

    .settings-tab:hover {
      background: rgba(76, 175, 80, 0.2);
      border-color: rgba(76, 175, 80, 0.5);
    }

    .settings-tab.active {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      border-color: #4CAF50;
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
    }

    /* Conte√∫do das Tabs */
    .settings-content {
      display: none;
    }

    .settings-content.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    /* Grupos de Configura√ß√µes */
    .settings-group {
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .settings-group h3 {
      color: #4CAF50;
      margin-top: 0;
      margin-bottom: 20px;
      font-size: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .settings-group h3::before {
      content: '‚ñ∂';
      font-size: 14px;
    }

    /* Item de Configura√ß√£o */
    .setting-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .setting-item:last-child {
      border-bottom: none;
    }

    .setting-label {
      color: #ffffff;
      font-size: 16px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .setting-description {
      color: #888;
      font-size: 12px;
    }

    /* Controles */
    .setting-control {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    /* Switch Toggle */
    .switch {
      position: relative;
      width: 60px;
      height: 30px;
      background: #555;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .switch.active {
      background: #4CAF50;
    }

    .switch-handle {
      position: absolute;
      width: 26px;
      height: 26px;
      background: white;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: all 0.3s;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    .switch.active .switch-handle {
      left: 32px;
    }

    /* Slider */
    .slider-container {
      display: flex;
      align-items: center;
      gap: 15px;
      min-width: 250px;
    }

    .slider {
      flex: 1;
      height: 6px;
      background: #555;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #4CAF50;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
      transition: all 0.2s;
    }

    .slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px rgba(76, 175, 80, 0.8);
    }

    .slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #4CAF50;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
    }

    .slider-value {
      color: #4CAF50;
      font-weight: bold;
      min-width: 50px;
      text-align: right;
      font-size: 16px;
    }

    /* Select Dropdown */
    .custom-select {
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(76, 175, 80, 0.3);
      color: white;
      padding: 8px 15px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      min-width: 150px;
      transition: all 0.3s;
    }

    .custom-select:hover {
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.2);
    }

    .custom-select:focus {
      outline: none;
      box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
    }

    .custom-select option {
      background: #1a1a2e;
      color: white;
    }

    /* Bot√£o de A√ß√£o */
    .action-button {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      border: none;
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.3s;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .action-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(76, 175, 80, 0.4);
    }

    .action-button:active {
      transform: translateY(0);
    }

    .action-button.danger {
      background: linear-gradient(135deg, #f44336, #c62828);
    }

    /* Bot√µes de Controle */
    .control-buttons {
      display: flex;
      gap: 10px;
      margin-top: 30px;
      padding-top: 20px;
      border-top: 2px solid rgba(76, 175, 80, 0.3);
    }

    .control-buttons button {
      flex: 1;
      padding: 15px;
      font-size: 16px;
    }

    /* Info Box */
    .info-box {
      background: rgba(33, 150, 243, 0.1);
      border-left: 4px solid #2196F3;
      padding: 15px;
      margin: 15px 0;
      border-radius: 8px;
      color: #90caf9;
      font-size: 14px;
    }

    .warning-box {
      background: rgba(255, 152, 0, 0.1);
      border-left: 4px solid #FF9800;
      padding: 15px;
      margin: 15px 0;
      border-radius: 8px;
      color: #ffb74d;
      font-size: 14px;
    }

    /* Estat√≠sticas */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 10px;
      border: 1px solid rgba(76, 175, 80, 0.3);
      text-align: center;
    }

    .stat-value {
      font-size: 32px;
      font-weight: bold;
      color: #4CAF50;
      margin-bottom: 5px;
    }

    .stat-label {
      color: #888;
      font-size: 14px;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .settings-container {
        padding: 20px;
        margin: 10px;
        width: calc(100% - 20px);
      }

      .settings-header h2 {
        font-size: 24px;
      }

      .settings-tabs {
        flex-direction: column;
      }

      .settings-tab {
        width: 100%;
        text-align: center;
      }

      .setting-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }

      .slider-container {
        width: 100%;
      }

      .control-buttons {
        flex-direction: column;
      }
    }

    /* Anima√ß√£o de Loading */
    .loading-spinner {
      border: 3px solid rgba(76, 175, 80, 0.3);
      border-top: 3px solid #4CAF50;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Bot√£o de Configura√ß√µes no Menu Principal */
    .menu-settings-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #4CAF50;
      color: white;
      padding: 12px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .menu-settings-btn:hover {
      background: rgba(76, 175, 80, 0.3);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }/* Status Multiplayer */
    #multiplayer-status {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.9);
      padding: 10px 15px;
      border-radius: 8px;
      color: white;
      font-size: 12px;
      z-index: 150;
      min-width: 150px;
    }

    #multiplayer-status.hidden {
      display: none;
    }

    .mp-status-line {
      display: flex;
      justify-content: space-between;
      margin: 3px 0;
    }

    .mp-connected {
      color: #4CAF50;
      font-weight: bold;
    }

    .mp-disconnected {
      color: #f44336;
      font-weight: bold;
    }

    /* Chat Multiplayer */
    #multiplayer-chat {
      position: fixed;
      bottom: 100px;
      left: 10px;
      width: 400px;
      max-width: 90vw;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
      padding: 10px;
      display: none;
      flex-direction: column;
      z-index: 200;
    }

    #multiplayer-chat.open {
      display: flex;
    }

    #chat-messages {
      max-height: 300px;
      overflow-y: auto;
      margin-bottom: 10px;
      padding: 5px;
    }

    .chat-msg {
      margin: 5px 0;
      padding: 5px 8px;
      border-radius: 5px;
      font-size: 13px;
      line-height: 1.4;
    }

    .chat-player {
      color: #4CAF50;
      font-weight: bold;
    }

    .chat-system .chat-text-system {
      color: #FFD700;
      font-style: italic;
    }

    .chat-player .chat-text {
      color: white;
    }

    .chat-time {
      color: #888;
      font-size: 11px;
      margin-right: 5px;
    }

    #chat-input-container {
      display: flex;
      gap: 5px;
    }

    #chat-input {
      flex: 1;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(76, 175, 80, 0.5);
      color: white;
      padding: 8px;
      border-radius: 5px;
      font-size: 13px;
    }

    #chat-input:focus {
      outline: none;
      border-color: #4CAF50;
    }

    #chat-send {
      background: #4CAF50;
      border: none;
      color: white;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }

    #chat-send:hover {
      background: #66BB6A;
    }

    /* Menu Multiplayer */
    #multiplayer-menu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 4px solid #4CAF50;
      border-radius: 15px;
      padding: 30px;
      z-index: 2000;
      display: none;
      min-width: 400px;
    }

    #multiplayer-menu.open {
      display: block;
    }

    .mp-menu-title {
      color: #4CAF50;
      font-size: 28px;
      text-align: center;
      margin-bottom: 20px;
      text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
    }

    .mp-menu-section {
      background: rgba(255, 255, 255, 0.05);
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 15px;
    }

    .mp-menu-section h3 {
      color: #4CAF50;
      margin-top: 0;
      margin-bottom: 10px;
    }

    .mp-input-group {
      margin: 10px 0;
    }

    .mp-input-group label {
      color: white;
      display: block;
      margin-bottom: 5px;
      font-size: 14px;
    }

    .mp-input-group input {
      width: 100%;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(76, 175, 80, 0.5);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }

    .mp-input-group input:focus {
      outline: none;
      border-color: #4CAF50;
    }

    .mp-button {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      border: none;
      color: white;
      padding: 12px 25px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      width: 100%;
      margin: 5px 0;
      transition: all 0.3s;
    }

    .mp-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
    }

    .mp-button.danger {
      background: linear-gradient(135deg, #f44336, #c62828);
    }

    .mp-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .mp-status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .mp-status-indicator.online {
      background: #4CAF50;
      box-shadow: 0 0 10px #4CAF50;
    }

    .mp-status-indicator.offline {
      background: #f44336;
    }

    .mp-info-box {
      background: rgba(33, 150, 243, 0.1);
      border-left: 4px solid #2196F3;
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
      color: #90caf9;
      font-size: 13px;
    }

    /* Scroll customizado */
    #chat-messages::-webkit-scrollbar {
      width: 6px;
    }

    #chat-messages::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }

    #chat-messages::-webkit-scrollbar-thumb {
      background: rgba(76, 175, 80, 0.5);
      border-radius: 3px;
    }

    #chat-messages::-webkit-scrollbar-thumb:hover {
      background: rgba(76, 175, 80, 0.8);
    }

    /* Responsivo */
    @media (max-width: 768px) {
      #multiplayer-chat {
        width: calc(100% - 20px);
        bottom: 80px;
      }

      #multiplayer-menu {
        min-width: auto;
        width: 90%;
        padding: 20px;
      }

      #multiplayer-status {
        font-size: 10px;
        padding: 8px 12px;
      }
    }

  </style>
</head>
<body>
<div id="main-menu">
  <div class="menu-container">
    <h1 class="menu-title">‚õèÔ∏è MINECRAFT ULTRA OTIMIZADO ‚õèÔ∏è</h1>

    <p class="menu-subtitle">
      Uma experi√™ncia completa de Minecraft com gr√°ficos otimizados, sistema de vida,
      animais e invent√°rio expandido. Tudo rodando diretamente no seu navegador!
    </p>

    <div class="controls-grid">
      <div class="control-item">
        <strong>W/A/S/D</strong>
        <span>Movimenta√ß√£o</span>
      </div>
      <div class="control-item">
        <strong>ESPA√áO</strong>
        <span>Pular</span>
      </div>
      <div class="control-item">
        <strong>SHIFT</strong>
        <span>Correr / Descer (Voo)</span>
      </div>
      <div class="control-item">
        <strong>MOUSE</strong>
        <span>Olhar ao redor</span>
      </div>
      <div class="control-item">
        <strong>CLIQUE ESQUERDO</strong>
        <span>Quebrar bloco</span>
      </div>
      <div class="control-item">
        <strong>CLIQUE DIREITO</strong>
        <span>Colocar bloco</span>
      </div>
      <div class="control-item">
        <strong>SCROLL / 1-9</strong>
        <span>Trocar bloco</span>
      </div>
      <div class="control-item">
        <strong>F</strong>
        <span>Alternar Modo Voo</span>
      </div>
      <div class="control-item">
        <strong>E</strong>
        <span>Abrir Invent√°rio</span>
      </div>
      <div class="control-item">
        <strong>Q</strong>
        <span>Jogar Item</span>
      </div>
    </div>

    <div class="features-grid">
      <div class="feature">
        <span class="feature-icon">‚ö°</span>
        <span class="feature-text">Alto Desempenho</span>
      </div>
      <div class="feature">
        <span class="feature-icon">‚ù§Ô∏è</span>
        <span class="feature-text">Sistema de Vida</span>
      </div>
      <div class="feature">
        <span class="feature-icon">üêÆ</span>
        <span class="feature-text">Animais Interativos</span>
      </div>
      <div class="feature">
        <span class="feature-icon">üéí</span>
        <span class="feature-text">36 Slots</span>
      </div>
      <div class="feature">
        <span class="feature-icon">üåç</span>
        <span class="feature-text">Mundo Gerado</span>
      </div>
    </div>

    <button class="start-button" onclick="startGame()">
      üéÆ INICIAR JOGO
    </button>

    <p class="menu-footer">
      Desenvolvido com Three.js ‚Ä¢ Otimizado para navegadores modernos
    </p>
  </div>
</div>

<div id="info">
  <div class="info-item"><strong>Posi√ß√£o:</strong> <span id="pos" class="highlight">0, 0, 0</span></div>
  <div class="info-item"><strong>FPS:</strong> <span id="fps" class="performance-good">60</span></div>
  <div class="info-item"><strong>Chunks:</strong> <span id="chunks" class="highlight">0</span></div>
  <div class="info-item"><strong>Faces:</strong> <span id="visible" class="highlight">0</span></div>
  <div class="info-item"><strong>Blocos:</strong> <span id="total" class="highlight">0</span></div>
  <div class="info-item"><strong>Animais:</strong> <span id="animals-count" class="highlight">0</span></div>
  <div class="info-item"><strong>Modo:</strong> <span id="mode" class="highlight">Normal</span></div>
  <div class="info-item"><strong>Bloco:</strong> <span id="selected-block" class="highlight">Grama</span></div>
</div>

<div id="health-container"></div>
<div id="crosshair"></div>
<div class="break-progress" id="break-progress">
  <div class="break-progress-fill"></div>
</div>
<div id="inventory-bar"></div>
<div id="inventory-full"></div>

<!-- Controles Mobile -->
<div class="mobile-controls">
  <!-- Joystick Virtual -->
  <div id="mobile-joystick">
    <div id="joystick-stick"></div>
  </div>

  <!-- √Årea de Look Around -->
  <div id="mobile-look"></div>

  <!-- Bot√µes de A√ß√£o -->
  <div class="mobile-buttons">
    <button class="mobile-btn" id="mobile-jump">‚Üë</button>
    <button class="mobile-btn" id="mobile-break">‚öí</button>
    <button class="mobile-btn" id="mobile-place">+</button>
  </div>

  <!-- Bot√µes Superiores -->
  <div class="mobile-top-buttons">
    <button class="mobile-top-btn" id="mobile-fly">‚úà</button>
    <button class="mobile-top-btn" id="mobile-inventory">üéí</button>
    <button class="mobile-top-btn" id="mobile-sprint">‚ö°</button>
  </div>
</div>

<button class="mobile-top-btn" id="mobile-prev-slot">‚óÄ</button>
<button class="mobile-top-btn" id="mobile-next-slot">‚ñ∂</button>

<div id="settings-menu">
  <div class="settings-container">
    <div class="settings-header">
      <h2>‚öôÔ∏è CONFIGURA√á√ïES</h2>
      <button class="close-settings" onclick="closeSettings()">√ó</button>
    </div>

    <!-- Tabs -->
    <div class="settings-tabs">
      <button class="settings-tab active" onclick="switchTab('graphics')">üé® Gr√°ficos</button>
      <button class="settings-tab" onclick="switchTab('gameplay')">üéÆ Gameplay</button>
      <button class="settings-tab" onclick="switchTab('controls')">‚å®Ô∏è Controles</button>
      <button class="settings-tab" onclick="switchTab('audio')">üîä √Åudio</button>
      <button class="settings-tab" onclick="switchTab('info')">‚ÑπÔ∏è Info</button>
    </div>

    <!-- Conte√∫do: Gr√°ficos -->
    <div id="tab-graphics" class="settings-content active">
      <div class="settings-group">
        <h3>Qualidade Visual</h3>

        <div class="setting-item">
          <div class="setting-label">
            <span>Dist√¢ncia de Renderiza√ß√£o</span>
            <span class="setting-description">Quantos chunks s√£o carregados ao redor do jogador</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="render-distance" min="1" max="12" value="1"
                     oninput="updateSetting('renderDistance', this.value)">
              <span class="slider-value" id="render-distance-value">1</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Antialiasing</span>
            <span class="setting-description">Suaviza bordas dos objetos</span>
          </div>
          <div class="setting-control">
            <div class="switch" id="antialiasing-switch" onclick="toggleSwitch('antialiasing')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Sombras</span>
            <span class="setting-description">Renderizar sombras din√¢micas</span>
          </div>
          <div class="setting-control">
            <div class="switch active" id="shadows-switch" onclick="toggleSwitch('shadows')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>N√©voa</span>
            <span class="setting-description">Efeito de n√©voa atmosf√©rica</span>
          </div>
          <div class="setting-control">
            <div class="switch active" id="fog-switch" onclick="toggleSwitch('fog')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Part√≠culas</span>
            <span class="setting-description">Intensidade de efeitos de part√≠culas</span>
          </div>
          <div class="setting-control">
            <select class="custom-select" id="particles-select" onchange="updateSetting('particles', this.value)">
              <option value="all">Todas</option>
              <option value="minimal">M√≠nimas</option>
              <option value="none">Desativadas</option>
            </select>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>FPS Alvo</span>
            <span class="setting-description">Limite de quadros por segundo</span>
          </div>
          <div class="setting-control">
            <select class="custom-select" id="fps-select" onchange="updateSetting('fpsLimit', this.value)">
              <option value="unlimited">Ilimitado</option>
              <option value="144">144 FPS</option>
              <option value="120">120 FPS</option>
              <option value="60">60 FPS</option>
              <option value="30">30 FPS</option>
            </select>
          </div>
        </div>
      </div>

      <div class="info-box">
        üí° Dica: Reduzir a dist√¢ncia de renderiza√ß√£o e desativar sombras pode melhorar significativamente a performance.
      </div>
    </div>

    <!-- Conte√∫do: Gameplay -->
    <div id="tab-gameplay" class="settings-content">
      <div class="settings-group">
        <h3>Mec√¢nicas de Jogo</h3>

        <div class="setting-item">
          <div class="setting-label">
            <span>Dificuldade</span>
            <span class="setting-description">Altera dano de inimigos e spawn</span>
          </div>
          <div class="setting-control">
            <select class="custom-select" id="difficulty-select" onchange="updateSetting('difficulty', this.value)">
              <option value="peaceful">Pac√≠fico</option>
              <option value="easy">F√°cil</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Dif√≠cil</option>
            </select>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Modo Criativo</span>
            <span class="setting-description">Recursos ilimitados e invencibilidade</span>
          </div>
          <div class="setting-control">
            <div class="switch" id="creative-switch" onclick="toggleSwitch('creative')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Auto-Jump</span>
            <span class="setting-description">Pular automaticamente ao encontrar obst√°culos</span>
          </div>
          <div class="setting-control">
            <div class="switch" id="autojump-switch" onclick="toggleSwitch('autoJump')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Spawn de Inimigos</span>
            <span class="setting-description">Frequ√™ncia de apari√ß√£o de mobs hostis</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="mob-spawn" min="0" max="100" value="50"
                     oninput="updateSetting('mobSpawn', this.value)">
              <span class="slider-value" id="mob-spawn-value">50%</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Regenera√ß√£o de Vida</span>
            <span class="setting-description">Velocidade de recupera√ß√£o de HP</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="health-regen" min="0" max="10" value="5"
                     oninput="updateSetting('healthRegen', this.value)">
              <span class="slider-value" id="health-regen-value">5</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Conte√∫do: Controles -->
    <div id="tab-controls" class="settings-content">
      <div class="settings-group">
        <h3>Sensibilidade</h3>

        <div class="setting-item">
          <div class="setting-label">
            <span>Sensibilidade do Mouse</span>
            <span class="setting-description">Velocidade de rota√ß√£o da c√¢mera</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="mouse-sensitivity" min="1" max="20" value="10"
                     oninput="updateSetting('mouseSensitivity', this.value)">
              <span class="slider-value" id="mouse-sensitivity-value">10</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Inverter Eixo Y</span>
            <span class="setting-description">Inverter dire√ß√£o vertical do mouse</span>
          </div>
          <div class="setting-control">
            <div class="switch" id="invert-y-switch" onclick="toggleSwitch('invertY')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Sensibilidade Touch (Mobile)</span>
            <span class="setting-description">Velocidade de rota√ß√£o no mobile</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="touch-sensitivity" min="1" max="20" value="10"
                     oninput="updateSetting('touchSensitivity', this.value)">
              <span class="slider-value" id="touch-sensitivity-value">10</span>
            </div>
          </div>
        </div>
      </div>

      <div class="settings-group">
        <h3>Atalhos de Teclado</h3>
        <div class="info-box">
          <strong>Controles Atuais:</strong><br>
          ‚Ä¢ WASD - Movimento<br>
          ‚Ä¢ Espa√ßo - Pular<br>
          ‚Ä¢ Shift - Correr/Descer<br>
          ‚Ä¢ F - Modo Voo<br>
          ‚Ä¢ E - Invent√°rio<br>
          ‚Ä¢ Q - Jogar Item<br>
          ‚Ä¢ 1-9 - Selecionar Slot<br>
          ‚Ä¢ Mouse - Olhar / Interagir
        </div>
        <button class="action-button">üîÑ Restaurar Padr√£o</button>
      </div>
    </div>

    <!-- Conte√∫do: √Åudio -->
    <div id="tab-audio" class="settings-content">
      <div class="settings-group">
        <h3>Volume</h3>

        <div class="setting-item">
          <div class="setting-label">
            <span>Volume Mestre</span>
            <span class="setting-description">Volume geral do jogo</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="master-volume" min="0" max="100" value="70"
                     oninput="updateSetting('masterVolume', this.value)">
              <span class="slider-value" id="master-volume-value">70%</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Efeitos Sonoros</span>
            <span class="setting-description">Volume de sons de a√ß√£o</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="sfx-volume" min="0" max="100" value="80"
                     oninput="updateSetting('sfxVolume', this.value)">
              <span class="slider-value" id="sfx-volume-value">80%</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>M√∫sica de Fundo</span>
            <span class="setting-description">Volume da m√∫sica ambiente</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="music-volume" min="0" max="100" value="50"
                     oninput="updateSetting('musicVolume', this.value)">
              <span class="slider-value" id="music-volume-value">50%</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Sons Ambiente</span>
            <span class="setting-description">Sons de natureza e clima</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="ambient-volume" min="0" max="100" value="60"
                     oninput="updateSetting('ambientVolume', this.value)">
              <span class="slider-value" id="ambient-volume-value">60%</span>
            </div>
          </div>
        </div>
      </div>

      <div class="warning-box">
        ‚ö†Ô∏è Nota: Sistema de √°udio ser√° implementado em vers√£o futura.
      </div>
    </div>

    <!-- Conte√∫do: Info -->
    <div id="tab-info" class="settings-content">
      <div class="settings-group">
        <h3>Informa√ß√µes do Sistema</h3>

        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value" id="stat-fps">60</div>
            <div class="stat-label">FPS Atual</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-chunks">0</div>
            <div class="stat-label">Chunks Carregados</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-entities">0</div>
            <div class="stat-label">Entidades</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-memory">--</div>
            <div class="stat-label">Mem√≥ria Usada</div>
          </div>
        </div>
      </div>

      <div class="settings-group">
        <h3>Sobre o Jogo</h3>
        <div class="info-box">
          <strong>Minecraft Ultra Otimizado</strong><br>
          Vers√£o: 1.0.0<br>
          Motor: Three.js r128<br>
          <br>
          Desenvolvido com foco em performance e jogabilidade.<br>
          <br>
          ¬© 2026 - Todos os direitos reservados
        </div>
      </div>

      <div class="settings-group">
        <h3>Dados do Jogo</h3>
        <button class="action-button" onclick="exportGameData()">üì• Exportar Mundo</button>
        <button class="action-button" onclick="importGameData()">üì§ Importar Mundo</button>
        <button class="action-button danger" onclick="resetGameData()">üóëÔ∏è Limpar Todos os Dados</button>
      </div>
    </div>

    <!-- Bot√µes de Controle -->
    <div class="control-buttons">
      <button class="action-button" onclick="saveSettings()">üíæ Salvar</button>
      <button class="action-button" onclick="resetSettings()">üîÑ Restaurar Padr√£o</button>
      <button class="action-button" onclick="closeSettings()">‚úñÔ∏è Fechar</button>
    </div>
  </div>
</div>

<div id="multiplayer-status" class="hidden">
  <div class="mp-status-line">
    <span>Status:</span>
    <span id="mp-status" class="mp-disconnected">Desconectado</span>
  </div>
  <div class="mp-status-line">
    <span>Jogadores:</span>
    <span id="mp-players-count">0</span>
  </div>
</div>

<!-- Chat Multiplayer -->
<div id="multiplayer-chat">
  <div id="chat-messages"></div>
  <div id="chat-input-container">
    <input type="text" id="chat-input" placeholder="Digite sua mensagem... (Enter para enviar)" maxlength="200">
    <button id="chat-send" onclick="sendChatMessage(document.getElementById('chat-input').value)">Enviar</button>
  </div>
</div>

<!-- Menu Multiplayer -->
<div id="multiplayer-menu">
  <h2 class="mp-menu-title">üåê MULTIPLAYER</h2>

  <div class="mp-menu-section">
    <h3>Conex√£o</h3>

    <div class="mp-input-group">
      <label>Servidor:</label>
      <input type="text" id="mp-server-url" value="ws://localhost:8765" placeholder="ws://localhost:8765">
    </div>

    <div class="mp-input-group">
      <label>Seu Nome:</label>
      <input type="text" id="mp-player-name" placeholder="Seu Nome" maxlength="20">
    </div>

    <div class="mp-info-box">
      <span class="mp-status-indicator" id="mp-indicator"></span>
      <span id="mp-connection-status">N√£o conectado</span>
    </div>
  </div>

  <div class="mp-menu-section">
    <h3>Controles</h3>
    <div style="color: white; font-size: 13px; line-height: 1.6;">
      ‚Ä¢ <strong>T</strong> - Abrir chat<br>
      ‚Ä¢ <strong>Enter</strong> - Enviar mensagem<br>
      ‚Ä¢ <strong>ESC</strong> - Fechar chat<br>
    </div>
  </div>

  <button class="mp-button" id="mp-connect-btn" onclick="toggleMultiplayerConnection()">
    Conectar
  </button>

  <button class="mp-button danger" onclick="closeMultiplayerMenu()">
    Fechar
  </button>
</div>




<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  let scene, camera, renderer, raycaster;
  let worldData = {};
  let chunks = {};
  let chunkMeshes = {};
  let inventory = {};
  let materials = {};
  let breakingAnimations = [];
  let animals = [];
  let animalMeshes = [];

  const CHUNK_SIZE = 16;
  const RENDER_DISTANCE = 6;
  const MAX_HEALTH = 20;
  let playerHealth = MAX_HEALTH;

  const player = {
    velocity: new THREE.Vector3(),
    canJump: false,
    selectedSlot: 0,
    flying: false,
    breaking: null,
    breakProgress: 0,
    lastChunk: { x: 0, z: 0 },
    inventorySlots: 36,
    hotbarSlots: 9
  };

  // Sistema de invent√°rio
  player.inventory = Array(player.inventorySlots).fill().map(() => ({
    type: null,
    count: 0
  }));

  let keys = {};
  let mouse = { x: 0, y: 0 };
  let controls = { locked: false };

  const GRAVITY = -0.018;
  const JUMP_SPEED = 0.28;
  const MOVE_SPEED = 0.15;
  const SPRINT_SPEED = 0.28;
  const FLY_SPEED = 0.4;
  const REACH = 7;
  const BREAK_TIME = 500;
  let lastTime = performance.now();
  let frames = 0;
  let lastFaceUpdate = 0;
  const blockTypes = {
    grass: { color: 0x7CFC00, name: 'Grama', hardness: 1 },
    dirt: { color: 0x8B4513, name: 'Terra', hardness: 1 },
    stone: { color: 0x808080, name: 'Pedra', hardness: 3 },
    wood: { color: 0x654321, name: 'Madeira', hardness: 2 },
    leaves: { color: 0x228B22, name: 'Folhas', hardness: 0.5 },
    sand: { color: 0xF4A460, name: 'Areia', hardness: 1 },
    cobblestone: { color: 0x6B6B6B, name: 'Pedregulho', hardness: 3 },
    coal_ore: { color: 0x343434, name: 'Carv√£o', hardness: 4 },
    iron_ore: { color: 0xD8AF93, name: 'Ferro', hardness: 5 },
    gold_ore: { color: 0xFFD700, name: 'Ouro', hardness: 5 },
    diamond_ore: { color: 0x00CED1, name: 'Diamante', hardness: 6 },
    bedrock: { color: 0x2F2F2F, name: 'Bedrock', hardness: 999 },
    planks: { color: 0xC19A6B, name: 'T√°buas', hardness: 2 },
    brick: { color: 0xB22222, name: 'Tijolo', hardness: 3 },
    glass: { color: 0xADD8E6, name: 'Vidro', hardness: 0.3 },
    obsidian: { color: 0x1C1C2E, name: 'Obsidiana', hardness: 8 },
    ice: { color: 0xB0E0E6, name: 'Gelo', hardness: 0.5 },
    snow: { color: 0xFFFAFA, name: 'Neve', hardness: 0.2 },
    gravel: { color: 0x8B8680, name: 'Cascalho', hardness: 1 },
    clay: { color: 0xA0A0A0, name: 'Argila', hardness: 1 },
    emerald_ore: { color: 0x50C878, name: 'Esmeralda', hardness: 6 },
    redstone_ore: { color: 0xFF0000, name: 'Redstone', hardness: 5 },


    // NOVOS BLOCOS ESPECIAIS - LUMINOSOS
    glowstone: { color: 0xFFFF99, name: 'Pedra Luminosa', hardness: 0.5, emissive: true },
    lantern: { color: 0xFFD700, name: 'Lanterna', hardness: 0.5, emissive: true },
    torch: { color: 0xFF8C00, name: 'Tocha', hardness: 0.1, emissive: true },

    // BLOCOS DECORATIVOS
    quartz: { color: 0xF5F5F5, name: 'Quartzo', hardness: 2 },
    prismarine: { color: 0x4ECDC4, name: 'Prismarinho', hardness: 3 },
    purpur: { color: 0xA569BD, name: 'Purpur', hardness: 3 },
    endstone: { color: 0xE4E096, name: 'Pedra do End', hardness: 4 },

    // BLOCOS DE CONSTRU√á√ÉO
    concrete_white: { color: 0xFFFFFF, name: 'Concreto Branco', hardness: 2 },
    concrete_red: { color: 0xDC143C, name: 'Concreto Vermelho', hardness: 2 },
    concrete_blue: { color: 0x1E90FF, name: 'Concreto Azul', hardness: 2 },
    concrete_green: { color: 0x32CD32, name: 'Concreto Verde', hardness: 2 },
    concrete_yellow: { color: 0xFFD700, name: 'Concreto Amarelo', hardness: 2 },
    concrete_black: { color: 0x2F4F4F, name: 'Concreto Preto', hardness: 2 },

    // BLOCOS FUNCIONAIS
    crafting_table: { color: 0x8B4513, name: 'Mesa de Trabalho', hardness: 2.5 },
    furnace: { color: 0x696969, name: 'Fornalha', hardness: 4 },
    chest: { color: 0xA0522D, name: 'Ba√∫', hardness: 2.5 },
    bookshelf: { color: 0x654321, name: 'Estante', hardness: 1.5 },

    // BLOCOS NATURAIS ESPECIAIS
    mushroom_red: { color: 0xFF0000, name: 'Cogumelo Vermelho', hardness: 0.2 },
    mushroom_brown: { color: 0x8B4513, name: 'Cogumelo Marrom', hardness: 0.2 },
    pumpkin: { color: 0xFF8C00, name: 'Ab√≥bora', hardness: 1 },
    melon: { color: 0x90EE90, name: 'Melancia', hardness: 1 },

    // BLOCOS DE MIN√âRIO RAROS
    lapis_ore: { color: 0x0000FF, name: 'L√°pis-laz√∫li', hardness: 4 },
    netherite: { color: 0x8B008B, name: 'Netherite', hardness: 10 }
  };

  const animalTypes = {
    cow: {
      name: 'Vaca',
      health: 10,
      size: { width: 1, height: 1.6, depth: 1.5 },
      color: 0x8B4513,
      drops: ['leather', 'beef'],
      dropCount: { min: 1, max: 3 }
    },
    pig: {
      name: 'Porco',
      health: 8,
      size: { width: 0.9, height: 0.9, depth: 1 },
      color: 0xFFB6C1,
      drops: ['pork'],
      dropCount: { min: 1, max: 3 }
    },
    sheep: {
      name: 'Ovelha',
      health: 8,
      size: { width: 1.2, height: 1.3, depth: 1.6 },
      color: 0xFFFFFF,
      drops: ['wool'],
      dropCount: { min: 1, max: 2 }
    }
  };

  const itemTypes = {
    ...blockTypes,
    leather: { color: 0x8B4513, name: 'Couro' },
    beef: { color: 0x8B0000, name: 'Carne Bovina' },
    pork: { color: 0xFFC0CB, name: 'Carne de Porco' },
    wool: { color: 0xFFFFFF, name: 'L√£' }
  };


  function createHealthUI() {
    const container = document.getElementById('health-container');
    for (let i = 0; i < MAX_HEALTH / 2; i++) {
      const heart = document.createElement('div');
      heart.className = 'heart';
      container.appendChild(heart);
    }
    updateHealthUI();
  }

  function updateHealthUI() {
    const hearts = document.querySelectorAll('.heart');
    hearts.forEach((heart, index) => {
      const heartIndex = index * 2;
      if (playerHealth >= heartIndex + 2) {
        heart.className = 'heart';
      } else if (playerHealth >= heartIndex + 1) {
        heart.className = 'heart half';
      } else {
        heart.className = 'heart empty';
      }
    });
  }

  function damagePlayer(amount) {
    playerHealth = Math.max(0, playerHealth - amount);
    updateHealthUI();

    // Verificar morte
    if (playerHealth <= 0) {
      playerHealth = MAX_HEALTH;
      camera.position.set(0, 25, 0);
      player.velocity.set(0, 0, 0);
      updateHealthUI();
    }
  }

  function healPlayer(amount) {
    playerHealth = Math.min(MAX_HEALTH, playerHealth + amount);
    updateHealthUI();
  }

  function initializeInventory() {
    // Blocos b√°sicos
    addToInventory('grass', 64);
    addToInventory('dirt', 64);
    addToInventory('stone', 32);
    addToInventory('wood', 32);
    addToInventory('planks', 32);

    // Blocos decorativos
    addToInventory('concrete_white', 16);
    addToInventory('concrete_blue', 16);
    addToInventory('brick', 16);
    addToInventory('quartz', 16);

    // Blocos luminosos
    addToInventory('glowstone', 16);
    addToInventory('lantern', 16);
    addToInventory('torch', 32);

    // Blocos funcionais
    addToInventory('crafting_table', 4);
    addToInventory('chest', 4);
    addToInventory('furnace', 2);

    player.selectedSlot = 0;
  }

  function createCoalOreTexture(ctx, size) {
    createStoneTexture(ctx, size);

    // Veios de carv√£o
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(52, 52, 52, 0.8)';
      ctx.fillRect(x, y, 6, 6);
    }
  }

  function createIronOreTexture(ctx, size) {
    createStoneTexture(ctx, size);

    // Manchas de ferro
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(216, 175, 147, 0.7)';
      ctx.fillRect(x, y, 8, 8);
    }
  }

  function createDiamondOreTexture(ctx, size) {
    createStoneTexture(ctx, size);

    // Cristais de diamante
    for (let i = 0; i < 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(0, 206, 209, 0.9)';
      ctx.fillRect(x, y, 6, 6);

      // Brilho
      ctx.fillStyle = 'rgba(100, 255, 255, 0.5)';
      ctx.fillRect(x + 2, y + 2, 2, 2);
    }
  }
  function addToInventory(type, count) {
    // Encontrar slot existente com o mesmo tipo
    for (let i = 0; i < player.inventory.length; i++) {
      if (player.inventory[i].type === type && player.inventory[i].count < 64) {
        const availableSpace = 64 - player.inventory[i].count;
        const toAdd = Math.min(count, availableSpace);
        player.inventory[i].count += toAdd;
        count -= toAdd;
        if (count <= 0) break;
      }
    }

    // Se ainda h√° itens, encontrar slot vazio
    if (count > 0) {
      for (let i = 0; i < player.inventory.length; i++) {
        if (player.inventory[i].count === 0) {
          player.inventory[i].type = type;
          player.inventory[i].count = Math.min(count, 64);
          count -= player.inventory[i].count;
          if (count <= 0) break;
        }
      }
    }

    updateInventoryUI();
    updateFullInventoryUI();
  }

  function removeFromInventory(slotIndex, count = 1) {
    if (slotIndex < 0 || slotIndex >= player.inventory.length) return false;
    if (player.inventory[slotIndex].count >= count) {
      player.inventory[slotIndex].count -= count;
      if (player.inventory[slotIndex].count <= 0) {
        player.inventory[slotIndex].type = null;
        player.inventory[slotIndex].count = 0;
      }
      updateInventoryUI();
      updateFullInventoryUI();
      return true;
    }
    return false;
  }

  function getSelectedItem() {
    const slot = player.inventory[player.selectedSlot];
    return slot.count > 0 ? slot.type : null;
  }

  function createInventoryUI() {
    const invBar = document.getElementById('inventory-bar');
    invBar.innerHTML = '';

    for (let i = 0; i < player.hotbarSlots; i++) {
      const slot = document.createElement('div');
      slot.className = `inv-slot ${i === player.selectedSlot ? 'active' : ''}`;
      slot.dataset.index = i;

      const slotData = player.inventory[i];
      if (slotData.count > 0) {
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div class="block-icon" style="background: #${colorHex}"></div>
                    <div class="slot-count">${slotData.count}</div>
                `;
      }

      slot.onclick = () => selectSlot(i);
      invBar.appendChild(slot);
    }
  }

  function createFullInventoryUI() {
    const invFull = document.getElementById('inventory-full');
    invFull.innerHTML = '';

    for (let i = 0; i < player.inventorySlots; i++) {
      const slot = document.createElement('div');
      slot.className = 'inv-full-slot';
      slot.dataset.index = i;

      const slotData = player.inventory[i];
      if (slotData.count > 0) {
        slot.classList.add('has-item');
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div style="width: 35px; height: 35px; background: #${colorHex}; border-radius: 3px;"></div>
                    <div style="position: absolute; bottom: 2px; right: 5px; font-size: 10px; color: white;">${slotData.count}</div>
                `;
      }

      invFull.appendChild(slot);
    }
  }

  function updateInventoryUI() {
    const slots = document.querySelectorAll('#inventory-bar .inv-slot');
    slots.forEach((slot, i) => {
      const slotData = player.inventory[i];
      slot.classList.toggle('active', i === player.selectedSlot);

      if (slotData.count > 0) {
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div class="block-icon" style="background: #${colorHex}"></div>
                    <div class="slot-count">${slotData.count}</div>
                `;
      } else {
        slot.innerHTML = '';
      }
    });

    const selectedItem = getSelectedItem();
    document.getElementById('selected-block').textContent = selectedItem ? itemTypes[selectedItem].name : 'Vazio';
  }

  function updateFullInventoryUI() {
    const slots = document.querySelectorAll('#inventory-full .inv-full-slot');
    slots.forEach((slot, i) => {
      const slotData = player.inventory[i];
      slot.innerHTML = '';

      if (slotData.count > 0) {
        slot.classList.add('has-item');
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div style="width: 35px; height: 35px; background: #${colorHex}; border-radius: 3px;"></div>
                    <div style="position: absolute; bottom: 2px; right: 5px; font-size: 10px; color: white;">${slotData.count}</div>
                `;
      } else {
        slot.classList.remove('has-item');
      }
    });
  }

  function selectSlot(index) {
    if (index >= 0 && index < player.hotbarSlots) {
      player.selectedSlot = index;
      updateInventoryUI();
    }
  }

  function toggleFullInventory() {
    const invFull = document.getElementById('inventory-full');
    invFull.classList.toggle('open');
    controls.locked = !invFull.classList.contains('open');

    if (invFull.classList.contains('open')) {
      document.exitPointerLock();
      updateFullInventoryUI();
    } else {
      renderer.domElement.requestPointerLock();
    }
  }

  function getHeight(x, z) {
    const n1 = noise(x * 0.04, z * 0.04) * 10;
    const n2 = noise(x * 0.08, z * 0.08) * 5;
    const n3 = noise(x * 0.15, z * 0.15) * 2;
    return Math.floor(12 + n1 + n2 + n3);
  }

  function getBlockKey(x, y, z) {
    return `${x},${y},${z}`;
  }

  function getChunkKey(cx, cz) {
    return `${cx},${cz}`;
  }

  function worldToChunk(x, z) {
    return {
      x: Math.floor(x / CHUNK_SIZE),
      z: Math.floor(z / CHUNK_SIZE)
    };
  }

  function setBlock(x, y, z, type) {
    worldData[getBlockKey(x, y, z)] = { x, y, z, type };
  }

  function getBlock(x, y, z) {
    return worldData[getBlockKey(x, y, z)];
  }

  function removeBlockData(x, y, z) {
    delete worldData[getBlockKey(x, y, z)];
  }

  function removeAnimalsInChunk(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;
    const ex = sx + CHUNK_SIZE;
    const ez = sz + CHUNK_SIZE;

    for (let i = animals.length - 1; i >= 0; i--) {
      const animal = animals[i];
      if (animal.x >= sx && animal.x < ex && animal.z >= sz && animal.z < ez) {
        animal.remove();
        animals.splice(i, 1);
      }
    }
  }

  function buildChunkMesh(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);

    if (chunkMeshes[chunkKey]) {
      scene.remove(chunkMeshes[chunkKey]);
      chunkMeshes[chunkKey].children.forEach(child => {
        child.geometry.dispose();
      });
      delete chunkMeshes[chunkKey];
    }

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    const geometriesByType = {};

    for (let type in blockTypes) {
      geometriesByType[type] = {
        positions: [],
        normals: [],
        indices: [],
        vertexCount: 0
      };
    }

    let totalFaces = 0;

    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
      for (let lz = 0; lz < CHUNK_SIZE; lz++) {
        for (let y = 0; y < 40; y++) {
          const x = sx + lx;
          const z = sz + lz;
          const block = getBlock(x, y, z);

          if (!block) continue;

          const geo = geometriesByType[block.type];

          const faces = [
            { dir: [1, 0, 0], corners: [[1, 0, 0], [1, 1, 0], [1, 1, 1], [1, 0, 1]] },
            { dir: [-1, 0, 0], corners: [[0, 0, 1], [0, 1, 1], [0, 1, 0], [0, 0, 0]] },
            { dir: [0, 1, 0], corners: [[0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 1, 0]] },
            { dir: [0, -1, 0], corners: [[0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 0, 1]] },
            { dir: [0, 0, 1], corners: [[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]] },
            { dir: [0, 0, -1], corners: [[1, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0]] }
          ];

          for (let face of faces) {
            const [dx, dy, dz] = face.dir;
            const neighbor = getBlock(x + dx, y + dy, z + dz);

            if (!neighbor) {
              const baseIdx = geo.vertexCount;

              for (let corner of face.corners) {
                geo.positions.push(
                        x + corner[0] - 0.5,
                        y + corner[1] - 0.5,
                        z + corner[2] - 0.5
                );
                geo.normals.push(dx, dy, dz);
              }

              geo.indices.push(
                      baseIdx, baseIdx + 1, baseIdx + 2,
                      baseIdx, baseIdx + 2, baseIdx + 3
              );

              geo.vertexCount += 4;
              totalFaces++;
            }
          }
        }
      }
    }

    const group = new THREE.Group();

    for (let type in geometriesByType) {
      const geo = geometriesByType[type];

      if (geo.positions.length === 0) continue;

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(geo.positions, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(geo.normals, 3));
      geometry.setIndex(geo.indices);

      const mesh = new THREE.Mesh(geometry, materials[type]);
      mesh.userData.chunkKey = chunkKey;
      mesh.userData.type = type;
      group.add(mesh);
    }

    if (group.children.length > 0) {
      scene.add(group);
      chunkMeshes[chunkKey] = group;
      chunkMeshes[chunkKey].userData.faceCount = totalFaces;
    }

    return totalFaces;
  }

  function removeEnemiesInChunk(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;
    const ex = sx + CHUNK_SIZE;
    const ez = sz + CHUNK_SIZE;

    for (let i = enemies.length - 1; i >= 0; i--) {
      const enemy = enemies[i];
      if (enemy.x >= sx && enemy.x < ex && enemy.z >= sz && enemy.z < ez) {
        enemy.remove();
        enemies.splice(i, 1);
      }
    }
  }
  function updateFaceCount() {
    let totalFaces = 0;
    for (let key in chunkMeshes) {
      if (chunkMeshes[key].userData.faceCount) {
        totalFaces += chunkMeshes[key].userData.faceCount;
      }
    }
    document.getElementById('visible').textContent = totalFaces;
  }

  function createBreakAnimation(block) {
    const particles = [];
    const color = blockTypes[block.type] ? blockTypes[block.type].color : 0xFFFFFF;

    for (let i = 0; i < 6; i++) {
      const p = new THREE.Mesh(
              new THREE.BoxGeometry(0.12, 0.12, 0.12),
              new THREE.MeshBasicMaterial({ color, transparent: true })
      );

      p.position.set(
              block.x + (Math.random() - 0.5) * 0.4,
              block.y + (Math.random() - 0.5) * 0.4,
              block.z + (Math.random() - 0.5) * 0.4
      );

      p.velocity = new THREE.Vector3(
              (Math.random() - 0.5) * 0.08,
              Math.random() * 0.12,
              (Math.random() - 0.5) * 0.08
      );

      scene.add(p);
      particles.push(p);
    }

    breakingAnimations.push({ particles, created: Date.now() });
  }

  function updateBreakAnimations() {
    const now = Date.now();
    breakingAnimations = breakingAnimations.filter(anim => {
      const age = now - anim.created;
      if (age > 400) {
        anim.particles.forEach(p => {
          scene.remove(p);
          p.geometry.dispose();
          p.material.dispose();
        });
        return false;
      }

      anim.particles.forEach(p => {
        p.velocity.y -= 0.01;
        p.position.add(p.velocity);
        p.material.opacity = 1 - (age / 400);
      });

      return true;
    });
  }

  function setupEventListeners() {
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;

      // Selecionar slots 1-9
      if (e.code >= 'Digit1' && e.code <= 'Digit9') {
        const idx = parseInt(e.code.slice(-1)) - 1;
        if (idx < player.hotbarSlots) selectSlot(idx);
      }

      // Modo voo
      if (e.code === 'KeyF') {
        player.flying = !player.flying;
        document.getElementById('mode').textContent = player.flying ? 'Voo' : 'Normal';
      }

      // Invent√°rio completo
      if (e.code === 'KeyE') {
        toggleFullInventory();
      }

      // Jogar item
      if (e.code === 'KeyQ' && !document.getElementById('inventory-full').classList.contains('open')) {
        const selectedItem = getSelectedItem();
        if (selectedItem && removeFromInventory(player.selectedSlot, 1)) {
          // Criar entidade do item jogado
          const itemMesh = new THREE.Mesh(
                  new THREE.BoxGeometry(0.3, 0.3, 0.3),
                  new THREE.MeshLambertMaterial({ color: itemTypes[selectedItem].color })
          );
          itemMesh.position.copy(camera.position);
          itemMesh.velocity = new THREE.Vector3(
                  camera.getWorldDirection(new THREE.Vector3()).x * 0.5,
                  0.3,
                  camera.getWorldDirection(new THREE.Vector3()).z * 0.5
          );
          scene.add(itemMesh);

          // Remover ap√≥s 5 segundos
          setTimeout(() => {
            if (itemMesh.parent) {
              scene.remove(itemMesh);
            }
          }, 5000);
        }
      }

      // Reproduzir animais (debug)
      if (e.code === 'KeyR') {
        const chunk = worldToChunk(camera.position.x, camera.position.z);
        spawnAnimals(chunk.x, chunk.z);
      }
    });

    document.addEventListener('keyup', (e) => keys[e.code] = false);

    document.addEventListener('mousemove', (e) => {
      if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;

      // Corre√ß√£o: Controles desinvertidos - movimento do mouse mais suave
      mouse.x -= e.movementX * 0.002; // Invertido o sinal para desinverter
      mouse.y -= e.movementY * 0.002; // Mantido para controle vertical normal

      mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
    });

    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('wheel', handleScroll);
    document.addEventListener('contextmenu', (e) => e.preventDefault());
    window.addEventListener('resize', onWindowResize);

    document.addEventListener('pointerlockchange', () => {
      controls.locked = document.pointerLockElement === renderer.domElement;
    });
  }

  function handleInventoryScroll(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;
    if (mobileControls.enabled) return; // Desabilitar scroll em mobile

    e.preventDefault();
    const dir = e.deltaY > 0 ? 1 : -1;
    const newSlot = (player.selectedSlot + dir + player.hotbarSlots) % player.hotbarSlots;
    selectSlot(newSlot);
  }

  document.addEventListener('wheel', handleInventoryScroll);

  function handleMouseDown(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;

    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

    // Verificar colis√£o com animais primeiro
    const animalIntersects = raycaster.intersectObjects(animalMeshes);
    if (animalIntersects.length > 0 && e.button === 0) {
      const animalMesh = animalIntersects[0].object;
      const animal = animals.find(a => a.mesh === animalMesh);
      if (animal) {
        if (animal.damage(1)) {
          // Animal morto
          damagePlayer(1); // Dano ao jogador por matar animal
        }
      }
      return;
    }

    // Verificar colis√£o com blocos
    const allMeshes = [];
    for (let key in chunkMeshes) {
      allMeshes.push(...chunkMeshes[key].children);
    }

    const intersects = raycaster.intersectObjects(allMeshes);
    if (intersects.length === 0) return;

    const hit = intersects[0];
    const hitPos = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(-0.1));
    const bx = Math.round(hitPos.x);
    const by = Math.round(hitPos.y);
    const bz = Math.round(hitPos.z);

    if (e.button === 0) {
      const block = getBlock(bx, by, bz);
      if (block && block.type !== 'bedrock') {
        player.breaking = { x: bx, y: by, z: bz };
        player.breakStartTime = Date.now();
        player.breakBlockType = block.type;

        // Mostrar barra de progresso
        const progressBar = document.getElementById('break-progress');
        progressBar.style.display = 'block';
      }
    } else if (e.button === 2) {
      const placePos = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(0.5));
      const px = Math.round(placePos.x);
      const py = Math.round(placePos.y);
      const pz = Math.round(placePos.z);

      const selectedItem = getSelectedItem();
      if (selectedItem && blockTypes[selectedItem]) {
        placeBlock(px, py, pz, selectedItem);
      }
    }
  }

  function handleMouseUp(e) {
    if (e.button === 0) {
      player.breaking = null;
      player.breakProgress = 0;
      document.getElementById('break-progress').style.display = 'none';
    }
  }

  function updateBreaking() {
    if (player.breaking) {
      const block = getBlock(player.breaking.x, player.breaking.y, player.breaking.z);
      if (!block || block.type !== player.breakBlockType) {
        player.breaking = null;
        document.getElementById('break-progress').style.display = 'none';
        return;
      }

      const hardness = blockTypes[block.type].hardness;
      const elapsed = Date.now() - player.breakStartTime;
      player.breakProgress = elapsed / (BREAK_TIME * hardness);

      // Atualizar barra de progresso
      const progressFill = document.querySelector('.break-progress-fill');
      progressFill.style.width = `${Math.min(player.breakProgress * 100, 100)}%`;

      if (player.breakProgress >= 1) {
        removeBlock(player.breaking.x, player.breaking.y, player.breaking.z);
        player.breaking = null;
        player.breakProgress = 0;
        document.getElementById('break-progress').style.display = 'none';
      }
    }
  }

  function handleScroll(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;
    e.preventDefault();
    const dir = e.deltaY > 0 ? 1 : -1;
    const newSlot = (player.selectedSlot + dir + player.hotbarSlots) % player.hotbarSlots;
    selectSlot(newSlot);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }


  function playAnimalSound(type) {
    // Esta fun√ß√£o pode ser expandida para adicionar sons
    console.log(`${type} fez barulho!`);
  }

  function checkAnimalCollision(position) {
    for (const animal of animals) {
      if (animal.boundingBox) {
        const playerBox = new THREE.Box3(
                new THREE.Vector3(position.x - 0.3, position.y - 1.8, position.z - 0.3),
                new THREE.Vector3(position.x + 0.3, position.y + 0.2, position.z + 0.3)
        );

        if (animal.boundingBox.intersectsBox(playerBox)) {
          return animal;
        }
      }
    }
    return null;
  }


  class Animal {
    constructor(type, x, y, z) {
      this.type = type;
      this.x = x;
      this.y = y;
      this.z = z;
      this.health = animalTypes[type].health;
      this.targetX = x;
      this.targetZ = z;
      this.speed = 0.02;
      this.moveTimer = 0;
      this.idleTimer = 0;
      this.mesh = null; // Inicializar como null
      this.direction = new THREE.Vector3(0, 0, 1);
      this.velocity = new THREE.Vector3();
      this.isMoving = false;
      this.headRotation = 0;
      this.legRotation = 0;
      this.animationTime = 0;
      this.boundingBox = null;

      // Criar o mesh imediatamente
      this.createMesh();
    }

    // Fun√ß√µes de cria√ß√£o de geometria espec√≠fica para cada animal
    createCowMesh() {
      const group = new THREE.Group();

      // Corpo principal
      const bodyGeometry = new THREE.BoxGeometry(1, 0.8, 1.5);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.7;
      group.add(body);

      // Cabe√ßa
      const headGeometry = new THREE.BoxGeometry(0.7, 0.6, 0.7);
      const headMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.set(0, 0.9, 0.9);
      group.add(head);

      // Focinho
      const snoutGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.4);
      const snoutMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
      const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
      snout.position.set(0, 0.8, 1.25);
      group.add(snout);

      // Chifres
      const hornGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 6);
      const hornMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
      const horn1 = new THREE.Mesh(hornGeometry, hornMaterial);
      horn1.position.set(0.3, 1.2, 1);
      horn1.rotation.x = Math.PI / 2;
      group.add(horn1);

      const horn2 = new THREE.Mesh(hornGeometry, hornMaterial);
      horn2.position.set(-0.3, 1.2, 1);
      horn2.rotation.x = Math.PI / 2;
      group.add(horn2);

      // Orelhas
      const earGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.15);
      const earMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const ear1 = new THREE.Mesh(earGeometry, earMaterial);
      ear1.position.set(0.35, 1.1, 0.7);
      ear1.rotation.z = Math.PI / 6;
      group.add(ear1);

      const ear2 = new THREE.Mesh(earGeometry, earMaterial);
      ear2.position.set(-0.35, 1.1, 0.7);
      ear2.rotation.z = -Math.PI / 6;
      group.add(ear2);

      // Pernas
      const legGeometry = new THREE.BoxGeometry(0.25, 0.8, 0.25);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });

      const legPositions = [
        { x: 0.35, y: 0.4, z: 0.5 },
        { x: -0.35, y: 0.4, z: 0.5 },
        { x: 0.35, y: 0.4, z: -0.5 },
        { x: -0.35, y: 0.4, z: -0.5 }
      ];

      legPositions.forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        leg.position.set(pos.x, pos.y, pos.z);
        leg.userData.originalY = pos.y;
        leg.userData.isLeg = true;
        group.add(leg);
      });

      // Cauda
      const tailGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.4, 6);
      const tailMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const tail = new THREE.Mesh(tailGeometry, tailMaterial);
      tail.position.set(0, 1, -0.8);
      tail.rotation.x = Math.PI / 4;
      group.add(tail);

      return group;
    }

    createPigMesh() {
      const group = new THREE.Group();

      // Corpo principal (esf√©rico)
      const bodyGeometry = new THREE.SphereGeometry(0.6, 8, 8);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.scale.set(1.3, 1, 1);
      body.position.y = 0.7;
      group.add(body);

      // Cabe√ßa
      const headGeometry = new THREE.BoxGeometry(0.6, 0.5, 0.6);
      const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.set(0, 0.8, 0.8);
      group.add(head);

      // Focinho
      const snoutGeometry = new THREE.BoxGeometry(0.4, 0.25, 0.3);
      const snoutMaterial = new THREE.MeshLambertMaterial({ color: 0xFF9999 });
      const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
      snout.position.set(0, 0.75, 1.1);
      group.add(snout);

      // Orelhas
      const earGeometry = new THREE.BoxGeometry(0.2, 0.15, 0.1);
      const earMaterial = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const ear1 = new THREE.Mesh(earGeometry, earMaterial);
      ear1.position.set(0.3, 1.1, 0.7);
      ear1.rotation.z = Math.PI / 4;
      group.add(ear1);

      const ear2 = new THREE.Mesh(earGeometry, earMaterial);
      ear2.position.set(-0.3, 1.1, 0.7);
      ear2.rotation.z = -Math.PI / 4;
      group.add(ear2);

      // Pernas curtas
      const legGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.2);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });

      const legPositions = [
        { x: 0.4, y: 0.25, z: 0.4 },
        { x: -0.4, y: 0.25, z: 0.4 },
        { x: 0.4, y: 0.25, z: -0.4 },
        { x: -0.4, y: 0.25, z: -0.4 }
      ];

      legPositions.forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        leg.position.set(pos.x, pos.y, pos.z);
        leg.userData.originalY = pos.y;
        leg.userData.isLeg = true;
        group.add(leg);
      });

      // Rabinho encaracolado
      const tailGeometry = new THREE.TorusGeometry(0.1, 0.03, 8, 16, Math.PI);
      const tailMaterial = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const tail = new THREE.Mesh(tailGeometry, tailMaterial);
      tail.position.set(0, 0.8, -0.8);
      tail.rotation.y = Math.PI / 2;
      group.add(tail);

      return group;
    }

    createSheepMesh() {
      const group = new THREE.Group();

      // Corpo principal (fofinho com blocos extras para simular l√£)
      const bodyGeometry = new THREE.BoxGeometry(1.2, 0.9, 1.6);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.8;
      group.add(body);

      // Blocos extras para dar volume √† l√£
      const woolGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.4);
      const woolMaterial = new THREE.MeshLambertMaterial({ color: 0xF8F8F8 });

      const woolPositions = [
        { x: 0.3, y: 1.2, z: 0.3 },
        { x: -0.3, y: 1.2, z: 0.3 },
        { x: 0.3, y: 1.2, z: -0.3 },
        { x: -0.3, y: 1.2, z: -0.3 },
        { x: 0, y: 1.2, z: 0 }
      ];

      woolPositions.forEach(pos => {
        const wool = new THREE.Mesh(woolGeometry, woolMaterial);
        wool.position.set(pos.x, pos.y, pos.z);
        group.add(wool);
      });

      // Cabe√ßa
      const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
      const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.set(0, 0.9, 1.1);
      group.add(head);

      // Orelhas
      const earGeometry = new THREE.BoxGeometry(0.15, 0.25, 0.08);
      const earMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDAB9 });
      const ear1 = new THREE.Mesh(earGeometry, earMaterial);
      ear1.position.set(0.25, 1.1, 1);
      ear1.rotation.z = Math.PI / 6;
      group.add(ear1);

      const ear2 = new THREE.Mesh(earGeometry, earMaterial);
      ear2.position.set(-0.25, 1.1, 1);
      ear2.rotation.z = -Math.PI / 6;
      group.add(ear2);

      // Pernas
      const legGeometry = new THREE.BoxGeometry(0.25, 0.8, 0.25);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });

      const legPositions = [
        { x: 0.4, y: 0.4, z: 0.6 },
        { x: -0.4, y: 0.4, z: 0.6 },
        { x: 0.4, y: 0.4, z: -0.6 },
        { x: -0.4, y: 0.4, z: -0.6 }
      ];

      legPositions.forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        leg.position.set(pos.x, pos.y, pos.z);
        leg.userData.originalY = pos.y;
        leg.userData.isLeg = true;
        group.add(leg);
      });

      // Olhos
      const eyeGeometry = new THREE.SphereGeometry(0.05, 6, 6);
      const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
      const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
      eye1.position.set(0.2, 0.95, 1.35);
      group.add(eye1);

      const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
      eye2.position.set(-0.2, 0.95, 1.35);
      group.add(eye2);

      return group;
    }

    createMesh() {

      const group = new THREE.Group();

      // Cores por profiss√£o
      const professionColors = {
        farmer: 0x8B4513,
        librarian: 0xFFFFFF,
        blacksmith: 0x696969,
        priest: 0x800080,
        butcher: 0xFFEBCD,
        fisherman: 0x4682B4,  // NOVO
        shepherd: 0x90EE90,   // NOVO
        fletcher: 0xD2691E,   // NOVO
        cartographer: 0xFFD700 // NOVO
      };

      const color = professionColors[this.profession] || 0x8B4513;

      switch(this.type) {
        case 'cow':
          this.mesh = this.createCowMesh();
          break;
        case 'pig':
          this.mesh = this.createPigMesh();
          break;
        case 'sheep':
          this.mesh = this.createSheepMesh();
          break;
        default:
          const animalType = animalTypes[this.type];
          const geometry = new THREE.BoxGeometry(
                  animalType.size.width,
                  animalType.size.height,
                  animalType.size.depth
          );
          const material = new THREE.MeshLambertMaterial({ color: animalType.color });
          this.mesh = new THREE.Mesh(geometry, material);
      }

      this.mesh.position.set(this.x, this.y, this.z);
      scene.add(this.mesh);
      animalMeshes.push(this.mesh);

      // Adicionar bounding box para colis√£o
      this.boundingBox = new THREE.Box3().setFromObject(this.mesh);
    }

    update() {
      this.moveTimer++;
      this.idleTimer++;
      this.animationTime += 0.1;

      // Movimento aleat√≥rio
      if (this.moveTimer > 120 && Math.random() < 0.01) {
        this.isMoving = true;
        this.targetX = this.x + (Math.random() - 0.5) * 8;
        this.targetZ = this.z + (Math.random() - 0.5) * 8;
        this.moveTimer = 0;
        this.idleTimer = 0;
      }

      // Parar ap√≥s certo tempo
      if (this.idleTimer > 60) {
        this.isMoving = false;
      }

      // Movimento em dire√ß√£o ao alvo
      if (this.isMoving) {
        const dx = this.targetX - this.x;
        const dz = this.targetZ - this.z;
        const distance = Math.sqrt(dx * dx + dz * dz);

        if (distance > 0.5) {
          this.x += (dx / distance) * this.speed;
          this.z += (dz / distance) * this.speed;

          // Verificar colis√£o com blocos
          const blockBelow = getBlock(Math.floor(this.x), Math.floor(this.y - 1), Math.floor(this.z));
          if (!blockBelow) {
            this.isMoving = false;
            this.y -= 1;
          }

          // Atualizar dire√ß√£o
          this.direction.set(dx, 0, dz).normalize();

          // Animar pernas
          this.animateLegs();
        } else {
          this.isMoving = false;
        }
      }

      // Anima√ß√£o de respira√ß√£o suave
      this.animateBreathing();

      // Anima√ß√£o de cabe√ßa (olhar ao redor)
      this.animateHead();

      // Atualizar posi√ß√£o e rota√ß√£o do mesh
      if (this.mesh) {
        this.mesh.position.set(this.x, this.y, this.z);

        // Rota√ß√£o suave na dire√ß√£o do movimento
        if (this.isMoving) {
          const targetRotation = Math.atan2(-this.direction.x, -this.direction.z);
          this.mesh.rotation.y += (targetRotation - this.mesh.rotation.y) * 0.1;
        }

        // Atualizar bounding box
        if (this.boundingBox) {
          this.boundingBox.setFromObject(this.mesh);
        }
      }
    }

    animateLegs() {
      if (!this.mesh) return;

      this.mesh.traverse(child => {
        if (child.userData && child.userData.isLeg) {
          const legMove = Math.sin(this.animationTime * 8) * 0.1;
          child.position.y = child.userData.originalY + legMove;
        }
      });
    }

    animateBreathing() {
      if (!this.mesh) return;

      const breathScale = 1 + Math.sin(this.animationTime * 2) * 0.01;
      this.mesh.scale.set(breathScale, breathScale, breathScale);
    }

    animateHead() {
      if (!this.mesh) return;

      // Animar cabe√ßa para parecer que est√° olhando ao redor
      this.headRotation = Math.sin(this.animationTime * 0.5) * 0.3;

      // Encontrar a cabe√ßa no grupo (assumindo que √© o segundo filho)
      if (this.mesh.children.length > 1) {
        const head = this.mesh.children[1];
        head.rotation.y = this.headRotation;
      }
    }

    remove() {
      if (this.mesh) {
        // Limpar todos os filhos do mesh
        this.mesh.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => mat.dispose());
            } else {
              child.material.dispose();
            }
          }
        });

        scene.remove(this.mesh);
        const index = animalMeshes.indexOf(this.mesh);
        if (index > -1) animalMeshes.splice(index, 1);
      }
    }

    damage(amount) {
      this.health -= amount;

      // Efeito visual de dano (piscar vermelho)
      if (this.mesh) {
        this.mesh.traverse(child => {
          if (child.material) {
            const originalColor = child.material.color.clone();
            child.material.color.set(0xFF0000);

            setTimeout(() => {
              if (child.material) {
                child.material.color.copy(originalColor);
              }
            }, 100);
          }
        });
      }

      if (this.health <= 0) {
        this.dropItems();
        this.remove();
        const animalIndex = animals.indexOf(this);
        if (animalIndex > -1) animals.splice(animalIndex, 1);
        return true;
      }
      return false;
    }

    dropItems() {
      const animalType = animalTypes[this.type];
      animalType.drops.forEach(drop => {
        const count = Math.floor(Math.random() *
                (animalType.dropCount.max - animalType.dropCount.min + 1)) + animalType.dropCount.min;
        addToInventory(drop, count);
      });
    }
  }

  function updateAnimals() {
    animals.forEach(animal => {
      if (animal.update) {
        animal.update();
      }
    });
    document.getElementById('animals-count').textContent = animals.length;
  }

  function spawnAnimals(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;

    // Gerar animais com base na biome
    const biome = hash(chunkX * 0.1, chunkZ * 0.1);
    let animalCount = 0;

    if (biome > 0.5) {
      animalCount = Math.floor(Math.random() * 2) + 1; // Menos animais em biomas extremos
    } else {
      animalCount = Math.floor(Math.random() * 2) + 2; // Mais animais em biomas normais
    }

    for (let i = 0; i < animalCount; i++) {
      const x = sx + Math.random() * CHUNK_SIZE;
      const z = sz + Math.random() * CHUNK_SIZE;
      const y = getHeight(x, z) + 1;

      // Verificar se o bloco abaixo √© grama ou terra
      const blockBelow = getBlock(Math.floor(x), Math.floor(y - 1), Math.floor(z));
      if (blockBelow && (blockBelow.type === 'grass' || blockBelow.type === 'dirt')) {
        let type;

        // Escolher tipo de animal baseado no biome
        if (biome > 0.85) {
          type = Math.random() > 0.5 ? 'sheep' : 'cow'; // Mais ovelhas em biomas frios
        } else if (biome > 0.7) {
          type = 'pig'; // Apenas porcos em biomas quentes
        } else {
          const rand = Math.random();
          type = rand < 0.4 ? 'cow' : rand < 0.7 ? 'pig' : 'sheep';
        }

        const animal = new Animal(type, x, y, z);
        animals.push(animal);
      }
    }
  }


  // Adicionar estas constantes no in√≠cio
  const PLAYER_WIDTH = 0.6;
  const PLAYER_HEIGHT = 1.8;
  const PLAYER_EYE_HEIGHT = 1.6;
  const COLLISION_TOLERANCE = 0.01;

  // Atualizar a fun√ß√£o updatePlayer para incluir colis√£o completa
  function updatePlayer() {
    const dir = new THREE.Vector3();
    const right = new THREE.Vector3();

    camera.getWorldDirection(dir);
    dir.y = 0;
    dir.normalize();
    // CORRE√á√ÉO: Vetor right calculado corretamente para controles padr√£o
    right.crossVectors(dir, camera.up).normalize();

    const speed = keys['ShiftLeft'] ? SPRINT_SPEED : (player.flying ? FLY_SPEED : MOVE_SPEED);

    // Calcular movimento desejado - CORRE√á√ÉO DOS CONTROLES
    const move = new THREE.Vector3();
    if (keys['KeyW']) move.add(dir);
    if (keys['KeyS']) move.add(dir.clone().negate());
    if (keys['KeyA']) move.add(right.clone().negate()); // CORRE√á√ÉO: Movimento para esquerda
    if (keys['KeyD']) move.add(right); // CORRE√á√ÉO: Movimento para direita

    if (move.length() > 0) {
      move.normalize().multiplyScalar(speed);
    }

    // Aplicar gravidade se n√£o estiver voando
    if (!player.flying) {
      player.velocity.y += GRAVITY;
      move.y = player.velocity.y;
    } else {
      if (keys['Space']) move.y = FLY_SPEED;
      if (keys['ShiftLeft']) move.y = -FLY_SPEED;
      player.velocity.y = 0;
    }

    // Detectar colis√µes e ajustar movimento
    const newPos = camera.position.clone().add(move);
    const collision = checkCollision(newPos);

    // Colis√£o lateral
    if (collision.sides) {
      // Projetar movimento no plano XZ para evitar paredes
      const lateralMove = new THREE.Vector3(move.x, 0, move.z);

      // Testar movimento apenas em X
      const testX = new THREE.Vector3(camera.position.x + move.x, camera.position.y, camera.position.z);
      if (!checkCollision(testX).sides) {
        camera.position.x = testX.x;
        move.x = 0;
      }

      // Testar movimento apenas em Z
      const testZ = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z + move.z);
      if (!checkCollision(testZ).sides) {
        camera.position.z = testZ.z;
        move.z = 0;
      }

      // Se ainda houver colis√£o, tentar deslizar
      if (move.x !== 0 || move.z !== 0) {
        const slideMove = new THREE.Vector3(move.x, 0, move.z);
        slideMove.normalize().multiplyScalar(speed * 0.5);

        const testSlide = new THREE.Vector3(
                camera.position.x + slideMove.x,
                camera.position.y,
                camera.position.z + slideMove.z
        );

        if (!checkCollision(testSlide).sides) {
          camera.position.x = testSlide.x;
          camera.position.z = testSlide.z;
        }
      }
    } else {
      // Sem colis√£o lateral, mover normalmente
      camera.position.x += move.x;
      camera.position.z += move.z;
    }

    // Colis√£o vertical
    if (collision.ground) {
      // No ch√£o
      player.velocity.y = 0;
      player.canJump = true;

      // Ajustar posi√ß√£o para ficar exatamente em cima do bloco
      const groundY = Math.floor(newPos.y - PLAYER_HEIGHT/2) + 1 + PLAYER_HEIGHT/2;
      camera.position.y = groundY;

      // Pular
      if (keys['Space'] && player.canJump) {
        player.velocity.y = JUMP_SPEED;
        player.canJump = false;
      }
    } else if (collision.ceiling) {
      // Batendo no teto
      player.velocity.y = Math.min(player.velocity.y, 0);
      const ceilingY = Math.floor(newPos.y + PLAYER_HEIGHT/2) - COLLISION_TOLERANCE - PLAYER_HEIGHT/2;
      camera.position.y = ceilingY;
    } else {
      // No ar
      camera.position.y += move.y;
      player.canJump = false;
    }

    // Dano por queda
    if (player.velocity.y < -2.5 && !player.flying && collision.ground) {
      const fallDamage = Math.floor(Math.abs(player.velocity.y) - 2);
      if (fallDamage > 0) {
        damagePlayer(fallDamage);
      }
    }

    // Atualizar rota√ß√£o da c√¢mera
    camera.rotation.order = 'YXZ';
    camera.rotation.y = mouse.x;
    camera.rotation.x = mouse.y;

    // Atualizar chunks
    const chunk = worldToChunk(camera.position.x, camera.position.z);
    if (chunk.x !== player.lastChunk.x || chunk.z !== player.lastChunk.z) {
      player.lastChunk = chunk;
      updateVisibleChunks();
    }
  }

  // Fun√ß√£o de verifica√ß√£o de colis√£o melhorada
  function checkCollision(position) {
    const result = {
      sides: false,
      ground: false,
      ceiling: false
    };

    // Definir pontos de teste para o jogador
    const playerMinY = position.y - PLAYER_HEIGHT/2;
    const playerMaxY = position.y + PLAYER_HEIGHT/2;
    const playerRadius = PLAYER_WIDTH/2;

    // Testar colis√£o com o ch√£o
    const groundTestPoints = [
      new THREE.Vector3(position.x, playerMinY - COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x + playerRadius, playerMinY - COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x - playerRadius, playerMinY - COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x, playerMinY - COLLISION_TOLERANCE, position.z + playerRadius),
      new THREE.Vector3(position.x, playerMinY - COLLISION_TOLERANCE, position.z - playerRadius)
    ];

    for (const point of groundTestPoints) {
      const block = getBlock(
              Math.floor(point.x),
              Math.floor(point.y),
              Math.floor(point.z)
      );
      if (block && block.type !== 'leaves' && block.type !== 'glass') {
        result.ground = true;
        break;
      }
    }

    // Testar colis√£o com o teto
    const ceilingTestPoints = [
      new THREE.Vector3(position.x, playerMaxY + COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x + playerRadius, playerMaxY + COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x - playerRadius, playerMaxY + COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x, playerMaxY + COLLISION_TOLERANCE, position.z + playerRadius),
      new THREE.Vector3(position.x, playerMaxY + COLLISION_TOLERANCE, position.z - playerRadius)
    ];

    for (const point of ceilingTestPoints) {
      const block = getBlock(
              Math.floor(point.x),
              Math.floor(point.y),
              Math.floor(point.z)
      );
      if (block && block.type !== 'leaves' && block.type !== 'glass') {
        result.ceiling = true;
        break;
      }
    }

    // Testar colis√£o lateral
    const sideTestPoints = [];
    const angles = [0, 45, 90, 135, 180, 225, 270, 315];

    for (const angle of angles) {
      const rad = angle * Math.PI / 180;
      const testPoint = new THREE.Vector3(
              position.x + Math.cos(rad) * playerRadius,
              position.y,
              position.z + Math.sin(rad) * playerRadius
      );
      sideTestPoints.push(testPoint);

      // Testar tamb√©m em diferentes alturas
      sideTestPoints.push(testPoint.clone().setY(position.y + PLAYER_HEIGHT/3));
      sideTestPoints.push(testPoint.clone().setY(position.y - PLAYER_HEIGHT/3));
    }

    for (const point of sideTestPoints) {
      const block = getBlock(
              Math.floor(point.x),
              Math.floor(point.y),
              Math.floor(point.z)
      );
      if (block && block.type !== 'leaves' && block.type !== 'glass') {
        result.sides = true;
        break;
      }
    }

    return result;
  }


  function removeBlock(x, y, z) {
    const block = getBlock(x, y, z);
    if (!block || block.type === 'bedrock') return;

    // ‚ú® ILUMINA√á√ÉO: Remover luz se o bloco for emissivo
    if (blockTypes[block.type] && blockTypes[block.type].emissive) {
      removeBlockLight(x, y, z);
    }

    // Criar part√≠culas do bloco quebrado
    if (particleSystem) {
      const color = blockTypes[block.type] ? blockTypes[block.type].color : 0xFFFFFF;
      particleSystem.emit(
              new THREE.Vector3(x, y, z),
              color,
              15,
              0.2
      );
    }

    // ‚úÖ SINCRONIZAR MULTIPLAYER
    if (multiplayer.connected) {
      console.log('üì§ Sincronizando quebra de bloco em:', x, y, z);
      sendMultiplayerMessage({
        type: 'block_break',
        x: Math.floor(x),
        y: Math.floor(y),
        z: Math.floor(z)
      });
    }

    // Remover √°gua se for bloco de √°gua
    if (block.type === 'water') {
      waterSystem.removeWater(x, y, z);
    }

    addToInventory(block.type, 1);
    removeBlockData(x, y, z);

    // Reconstruir chunks
    const chunk = worldToChunk(x, z);
    const chunksToUpdate = new Set();
    chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

    const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

    if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
    if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
    if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
    if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

    chunksToUpdate.forEach(key => {
      const [cx, cz] = key.split(',').map(Number);
      if (chunkMeshes[key]) {
        buildChunkMesh(cx, cz);
      }
    });

    updateFaceCount();
  }







  // Fun√ß√£o auxiliar para gerar vegeta√ß√£o
  function generateVegetation(x, height, z, biome, specialFeature) {
    switch(specialFeature) {
      case 'spruce_trees':
        // √Årvores de taiga (pinheiros)
        const spruceHeight = Math.floor(Math.random() * 4) + 6;
        for (let i = 1; i <= spruceHeight; i++) {
          setBlock(x, height + i, z, 'wood');
        }

        // Copa c√¥nica
        for (let dy = 0; dy < 4; dy++) {
          const radius = 3 - dy;
          for (let dx = -radius; dx <= radius; dx++) {
            for (let dz = -radius; dz <= radius; dz++) {
              if (Math.abs(dx) + Math.abs(dz) <= radius * 1.5) {
                setBlock(x + dx, height + spruceHeight - dy, z + dz, 'leaves');
              }
            }
          }
        }
        break;

      case 'acacia_trees':
        // √Årvores de savana (ac√°cias)
        const acaciaHeight = Math.floor(Math.random() * 3) + 4;
        for (let i = 1; i <= acaciaHeight; i++) {
          setBlock(x, height + i, z, 'wood');
        }

        // Copa plana e larga
        const canopySize = 2;
        for (let dx = -canopySize; dx <= canopySize; dx++) {
          for (let dz = -canopySize; dz <= canopySize; dz++) {
            if (Math.abs(dx) + Math.abs(dz) <= canopySize * 1.5 || Math.random() > 0.3) {
              setBlock(x + dx, height + acaciaHeight + 1, z + dz, 'leaves');
            }
          }
        }
        break;

      case 'jungle_trees':
        // √Årvores da selva (altas com videiras)
        const jungleHeight = Math.floor(Math.random() * 6) + 8;
        for (let i = 1; i <= jungleHeight; i++) {
          setBlock(x, height + i, z, 'wood');
        }

        // Copa grande e densa
        for (let dx = -3; dx <= 3; dx++) {
          for (let dz = -3; dz <= 3; dz++) {
            for (let dy = -2; dy <= 1; dy++) {
              const dist = Math.sqrt(dx*dx + dz*dz + dy*dy);
              if (dist <= 3 && Math.random() > 0.3) {
                setBlock(x + dx, height + jungleHeight + dy, z + dz, 'leaves');
              }
            }
          }
        }
        break;

      case 'cacti':
        // Cactos no deserto
        if (Math.random() > 0.7) {
          const cactusHeight = Math.floor(Math.random() * 3) + 1;
          for (let i = 1; i <= cactusHeight; i++) {
            setBlock(x, height + i, z, 'wood'); // Usando wood como cacto
          }
        }
        break;

      default:
        // √Årvores padr√£o (floresta/plan√≠cie)
        if (biome === 'forest' || biome === 'plains') {
          const treeHeight = Math.floor(Math.random() * 4) + 4;
          for (let i = 1; i <= treeHeight; i++) {
            setBlock(x, height + i, z, 'wood');
          }

          // Copa padr√£o
          for (let dx = -2; dx <= 2; dx++) {
            for (let dz = -2; dz <= 2; dz++) {
              for (let dy = -1; dy <= 1; dy++) {
                if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 3) {
                  setBlock(x + dx, height + treeHeight + dy, z + dz, 'leaves');
                }
              }
            }
          }
        }
        break;
    }
  }

  // Fun√ß√£o auxiliar para gerar caracter√≠sticas do bioma
  function generateBiomeFeatures(x, height, z, biome, specialFeature) {
    switch(biome) {
      case 'swamp':
        // Cogumelos no p√¢ntano
        if (Math.random() > 0.98) {
          setBlock(x, height + 1, z, 'brick'); // Representando cogumelo
        }
        break;

      case 'desert':
        // Templos ou po√ßos no deserto (simplificado)
        if (Math.random() > 0.995) {
          // Po√ßo de √°gua
          for (let dx = -1; dx <= 1; dx++) {
            for (let dz = -1; dz <= 1; dz++) {
              setBlock(x + dx, height - 1, z + dz, 'sandstone' || 'sand');
            }
          }
          setBlock(x, height, z, 'glass'); // √Ågua
        }
        break;

      case 'mountains':
        // Neve no topo das montanhas
        if (height > 40 && Math.random() > 0.5) {
          setBlock(x, height + 1, z, 'snow');
        }
        break;

      case 'tundra':
        // Neve na tundra
        if (Math.random() > 0.7) {
          setBlock(x, height + 1, z, 'snow');
        }
        break;
    }
  }

  // Fun√ß√£o auxiliar para gerar subsolo
  function generateUnderground(x, z, height, stoneHeight) {
    // Cavernas
    const caveNoise = noise(x * 0.1, z * 0.1);
    if (caveNoise > 0.7 && stoneHeight > 5) {
      const caveHeight = Math.floor(caveNoise * stoneHeight);
      if (caveHeight > 5 && caveHeight < stoneHeight - 5) {
        const caveSize = Math.floor(noise(x * 0.5, z * 0.5) * 3) + 1;
        for (let dy = 0; dy < caveSize; dy++) {
          removeBlockData(x, caveHeight + dy, z);
        }
      }
    }

    // Min√©rios
    for (let y = 1; y < stoneHeight; y++) {
      if (getBlock(x, y, z) && getBlock(x, y, z).type === 'stone') {
        const oreRand = Math.random();
        let ore = null;

        // Diamante e esmeralda no fundo
        if (y < 5 && oreRand > 0.98) {
          ore = 'diamond_ore';
        } else if (y < 10 && oreRand > 0.98) {
          ore = 'emerald_ore';
        }
        // Ouro no m√©dio-fundo
        else if (y < 15 && oreRand > 0.96) {
          ore = 'gold_ore';
        }
        // Ferro no m√©dio
        else if (y < 25 && oreRand > 0.94) {
          ore = 'iron_ore';
        }
        // Redstone
        else if (y < 30 && oreRand > 0.92) {
          ore = 'redstone_ore';
        }
        // Carv√£o em todas as camadas
        else if (oreRand > 0.90) {
          ore = 'coal_ore';
        }
        // Pedregulho em veios
        else if (oreRand > 0.88 && y < 20) {
          ore = 'cobblestone';
        }

        if (ore) {
          setBlock(x, y, z, ore);
        }
      }
    }
  }

  // Fun√ß√µes de ru√≠do e hash originais (mantidas para compatibilidade)
  function noise(x, z) {
    const X = Math.floor(x);
    const Z = Math.floor(z);
    const xf = x - X;
    const zf = z - Z;

    const a = hash(X, Z);
    const b = hash(X + 1, Z);
    const c = hash(X, Z + 1);
    const d = hash(X + 1, Z + 1);

    const u = xf * xf * (3.0 - 2.0 * xf);
    const v = zf * zf * (3.0 - 2.0 * zf);

    return a * (1 - u) * (1 - v) + b * u * (1 - v) + c * (1 - u) * v + d * u * v;
  }

  function hash(x, y) {
    let h = x * 374761393 + y * 668265263;
    h = (h ^ (h >> 13)) * 1274126177;
    return Math.abs((h ^ (h >> 16)) / 2147483648.0);
  }




  function generateChunk(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);
    if (chunks[chunkKey]) return;

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    for (let x = sx; x < sx + CHUNK_SIZE; x++) {
      for (let z = sz; z < sz + CHUNK_SIZE; z++) {
        // Determinando biomas com m√∫ltiplos fatores de ru√≠do
        const temp = noise(x * 0.001, z * 0.001);
        const humidity = noise(x * 0.001 + 1000, z * 0.001 + 1000);
        const terrain = noise(x * 0.002, z * 0.002);

        // Altura base com ru√≠do fractal
        let height = 0;
        let amplitude = 15;
        let frequency = 0.01;

        // 4 camadas de ru√≠do para terreno mais natural
        for (let i = 0; i < 4; i++) {
          height += noise(x * frequency, z * frequency) * amplitude;
          amplitude *= 0.5;
          frequency *= 2.0;
        }

        height = Math.floor(15 + height);

        // Bedrock na base
        setBlock(x, 0, z, 'bedrock');

        // Camadas subterr√¢neas
        const stoneHeight = height - 4;
        for (let y = 1; y < stoneHeight; y++) {
          setBlock(x, y, z, 'stone');
        }

        for (let y = stoneHeight; y < height - 1; y++) {
          setBlock(x, y, z, 'dirt');
        }

        // Determinar bioma com base em temperatura e umidade
        let surfaceBlock = 'grass';
        let biome = 'plains';

        if (temp > 0.7) {
          // Biomas quentes
          if (humidity < 0.3) {
            biome = 'desert';
            surfaceBlock = 'sand';
          } else if (humidity < 0.6) {
            biome = 'savanna';
            surfaceBlock = 'dirt';
          } else {
            biome = 'jungle';
            surfaceBlock = 'grass';
          }
        } else if (temp < 0.3) {
          // Biomas frios
          if (humidity < 0.4) {
            biome = 'tundra';
            surfaceBlock = 'gravel';
          } else {
            biome = 'taiga';
            surfaceBlock = 'grass';
          }
        } else {
          // Biomas temperados
          if (humidity < 0.4) {
            biome = 'plains';
            surfaceBlock = 'grass';
          } else if (humidity < 0.7) {
            biome = 'forest';
            surfaceBlock = 'grass';
          } else {
            biome = 'swamp';
            surfaceBlock = 'dirt';
          }
        }

        // Ajustar altura baseado no bioma
        if (terrain > 0.7) {
          biome = 'mountains';
          height += Math.floor(terrain * 20);
        } else if (terrain > 0.6) {
          biome = 'hills';
          height += Math.floor(terrain * 10);
        }

        // Colocar superf√≠cie
        setBlock(x, height, z, surfaceBlock);

        // Adicionar vegeta√ß√£o baseada no bioma
        generateBiomeVegetation(x, height, z, biome);

        // Min√©rios com base na profundidade
        generateOres(x, height, z, stoneHeight);

        // √Ågua em biomas √∫midos
        if ((biome === 'swamp' || biome === 'jungle') && humidity > 0.8) {
          for (let y = height + 1; y < 20; y++) {
            setBlock(x, y, z, 'glass'); // Usando glass como √°gua temporariamente
          }
        }

        // Neve em biomas frios
        if ((biome === 'tundra' || biome === 'taiga') && temp < 0.3) {
          if (Math.random() > 0.5) {
            setBlock(x, height + 1, z, 'snow');
          }
        }
      }
    }

    chunks[chunkKey] = true;
  }

  function generateBiomeVegetation(x, height, z, biome) {
    switch(biome) {
      case 'forest':
        if (Math.random() > 0.95 && height < 40) {
          generateTree(x, height + 1, z, 'normal');
        }
        break;

      case 'jungle':
        if (Math.random() > 0.9 && height < 40) {
          generateTree(x, height + 1, z, 'jungle');
        }
        if (Math.random() > 0.8) {
          setBlock(x, height + 1, z, 'leaves');
        }
        break;

      case 'taiga':
        if (Math.random() > 0.97 && height < 40) {
          generateTree(x, height + 1, z, 'spruce');
        }
        break;

      case 'desert':
        if (Math.random() > 0.99 && height < 40) {
          // Cacto
          const cactusHeight = Math.floor(Math.random() * 3) + 1;
          for (let i = 1; i <= cactusHeight; i++) {
            setBlock(x, height + i, z, 'wood');
          }
        }
        break;

      case 'plains':
        if (Math.random() > 0.98 && height < 40) {
          generateTree(x, height + 1, z, 'normal');
        }
        if (Math.random() > 0.9) {
          setBlock(x, height + 1, z, 'leaves'); // Flores/grama alta
        }
        break;

      case 'savanna':
        if (Math.random() > 0.98 && height < 40) {
          generateTree(x, height + 1, z, 'acacia');
        }
        break;
    }
  }

  function generateTree(x, y, z, type) {
    const treeHeight = type === 'jungle' ?
            Math.floor(Math.random() * 6) + 8 :
            type === 'spruce' ?
                    Math.floor(Math.random() * 4) + 6 :
                    Math.floor(Math.random() * 4) + 4;

    // Tronco
    for (let i = 0; i < treeHeight; i++) {
      setBlock(x, y + i, z, 'wood');
    }

    // Copa
    const topY = y + treeHeight - 1;

    if (type === 'spruce') {
      // Copa de pinheiro (c√¥nica)
      for (let dy = 0; dy < 4; dy++) {
        const radius = 3 - dy;
        for (let dx = -radius; dx <= radius; dx++) {
          for (let dz = -radius; dz <= radius; dz++) {
            if (Math.abs(dx) + Math.abs(dz) <= radius * 1.5) {
              setBlock(x + dx, topY - dy, z + dz, 'leaves');
            }
          }
        }
      }
    } else if (type === 'jungle') {
      // Copa densa de selva
      for (let dx = -3; dx <= 3; dx++) {
        for (let dz = -3; dz <= 3; dz++) {
          for (let dy = -2; dy <= 1; dy++) {
            const dist = Math.sqrt(dx*dx + dz*dz + dy*dy);
            if (dist <= 3 && Math.random() > 0.3) {
              setBlock(x + dx, topY + dy, z + dz, 'leaves');
            }
          }
        }
      }
    } else if (type === 'acacia') {
      // Copa plana de ac√°cia
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          if (Math.abs(dx) + Math.abs(dz) <= 3 && Math.random() > 0.2) {
            setBlock(x + dx, topY + 1, z + dz, 'leaves');
          }
        }
      }
    } else {
      // Copa normal (carvalho)
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          for (let dy = -1; dy <= 1; dy++) {
            if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 3) {
              setBlock(x + dx, topY + dy, z + dz, 'leaves');
            }
          }
        }
      }
    }
  }

  function generateOres(x, height, z, stoneHeight) {
    for (let y = 1; y < stoneHeight; y++) {
      if (getBlock(x, y, z) && getBlock(x, y, z).type === 'stone') {
        const oreRand = Math.random();
        let ore = null;

        // Diamante e esmeralda no fundo
        if (y < 5 && oreRand > 0.98) {
          ore = 'diamond_ore';
        } else if (y < 10 && oreRand > 0.98) {
          ore = 'emerald_ore';
        }
        // Ouro no m√©dio-fundo
        else if (y < 15 && oreRand > 0.96) {
          ore = 'gold_ore';
        }
        // Ferro no m√©dio
        else if (y < 25 && oreRand > 0.94) {
          ore = 'iron_ore';
        }
        // Redstone
        else if (y < 30 && oreRand > 0.92) {
          ore = 'redstone_ore';
        }
        // Carv√£o em todas as camadas
        else if (oreRand > 0.90) {
          ore = 'coal_ore';
        }

        if (ore) {
          setBlock(x, y, z, ore);
        }

        // Cavernas ocasionais
        if (oreRand < 0.05 && y > 10 && y < stoneHeight - 10) {
          removeBlockData(x, y, z);
          if (Math.random() > 0.7) {
            removeBlockData(x, y + 1, z);
          }
        }
      }
    }
  }




  // ============================================
  // SISTEMA DE INIMIGOS (MOBS HOSTIS)
  // ============================================

  const enemyTypes = {
    zombie: {
      name: 'Zumbi',
      health: 20,
      damage: 3,
      speed: 0.03,
      size: { width: 0.6, height: 1.8, depth: 0.6 },
      color: 0x228B22,
      attackRange: 2,
      detectionRange: 16,
      drops: ['dirt', 'stone'],
      dropCount: { min: 0, max: 2 }
    },
    skeleton: {
      name: 'Esqueleto',
      health: 15,
      damage: 2,
      speed: 0.035,
      size: { width: 0.6, height: 1.8, depth: 0.6 },
      color: 0xE8E8E8,
      attackRange: 10,
      detectionRange: 20,
      drops: ['wood'],
      dropCount: { min: 0, max: 2 }
    },
    creeper: {
      name: 'Creeper',
      health: 20,
      damage: 25,
      speed: 0.04,
      size: { width: 0.6, height: 1.6, depth: 0.6 },
      color: 0x00FF00,
      attackRange: 3,
      detectionRange: 16,
      explodeTime: 1500,
      drops: ['coal_ore'],
      dropCount: { min: 0, max: 1 }
    },
    spider: {
      name: 'Aranha',
      health: 16,
      damage: 2,
      speed: 0.05,
      size: { width: 1.4, height: 0.9, depth: 1.4 },
      color: 0x8B0000,
      attackRange: 2,
      detectionRange: 16,
      drops: ['leaves'],
      dropCount: { min: 0, max: 2 }
    }
  };

  let enemies = [];
  let enemyMeshes = [];

  class Enemy {
    constructor(type, x, y, z) {
      this.type = type;
      this.x = x;
      this.y = y;
      this.z = z;
      this.health = enemyTypes[type].health;
      this.speed = enemyTypes[type].speed;
      this.damage = enemyTypes[type].damage;
      this.attackRange = enemyTypes[type].attackRange;
      this.detectionRange = enemyTypes[type].detectionRange;
      this.velocity = new THREE.Vector3();
      this.targetPlayer = false;
      this.attackCooldown = 0;
      this.animationTime = 0;
      this.mesh = null;
      this.boundingBox = null;

      // Creeper espec√≠fico
      this.exploding = false;
      this.explodeTimer = 0;

      this.createMesh();
    }

    createZombieMesh() {
      const group = new THREE.Group();
      const color = enemyTypes[this.type].color;

      // Corpo
      const bodyGeo = new THREE.BoxGeometry(0.6, 0.9, 0.3);
      const bodyMat = new THREE.MeshLambertMaterial({ color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 1;
      group.add(body);

      // Cabe√ßa
      const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      const headMat = new THREE.MeshLambertMaterial({ color });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.7;
      head.userData.isHead = true;
      group.add(head);

      // Bra√ßos
      const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
      const armMat = new THREE.MeshLambertMaterial({ color });

      const leftArm = new THREE.Mesh(armGeo, armMat);
      leftArm.position.set(-0.4, 0.9, 0);
      leftArm.userData.isArm = true;
      leftArm.userData.side = 'left';
      group.add(leftArm);

      const rightArm = new THREE.Mesh(armGeo, armMat);
      rightArm.position.set(0.4, 0.9, 0);
      rightArm.userData.isArm = true;
      rightArm.userData.side = 'right';
      group.add(rightArm);

      // Pernas
      const legGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
      const legMat = new THREE.MeshLambertMaterial({ color });

      const leftLeg = new THREE.Mesh(legGeo, legMat);
      leftLeg.position.set(-0.15, 0.45, 0);
      leftLeg.userData.isLeg = true;
      leftLeg.userData.side = 'left';
      group.add(leftLeg);

      const rightLeg = new THREE.Mesh(legGeo, legMat);
      rightLeg.position.set(0.15, 0.45, 0);
      rightLeg.userData.isLeg = true;
      rightLeg.userData.side = 'right';
      group.add(rightLeg);

      return group;
    }

    createCreeperMesh() {
      const group = new THREE.Group();
      const color = enemyTypes[this.type].color;

      // Corpo
      const bodyGeo = new THREE.BoxGeometry(0.6, 1.2, 0.6);
      const bodyMat = new THREE.MeshLambertMaterial({ color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 1;
      group.add(body);

      // Cabe√ßa
      const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
      const headMat = new THREE.MeshLambertMaterial({ color });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.9;
      group.add(head);

      // Pernas (4 pernas curtas)
      const legGeo = new THREE.BoxGeometry(0.2, 0.5, 0.2);
      const legMat = new THREE.MeshLambertMaterial({ color });

      const legPositions = [
        { x: -0.2, z: -0.2 },
        { x: 0.2, z: -0.2 },
        { x: -0.2, z: 0.2 },
        { x: 0.2, z: 0.2 }
      ];

      legPositions.forEach((pos, i) => {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(pos.x, 0.25, pos.z);
        leg.userData.isLeg = true;
        leg.userData.index = i;
        group.add(leg);
      });

      return group;
    }

    createSpiderMesh() {
      const group = new THREE.Group();
      const color = enemyTypes[this.type].color;

      // Corpo (2 partes)
      const bodyGeo = new THREE.BoxGeometry(0.8, 0.5, 0.5);
      const bodyMat = new THREE.MeshLambertMaterial({ color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.6;
      group.add(body);

      const headGeo = new THREE.BoxGeometry(0.6, 0.4, 0.4);
      const headMat = new THREE.MeshLambertMaterial({ color });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.set(0, 0.6, 0.5);
      group.add(head);

      // Olhos vermelhos
      const eyeGeo = new THREE.SphereGeometry(0.08, 6, 6);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });

      [-0.15, 0.15].forEach(x => {
        const eye = new THREE.Mesh(eyeGeo, eyeMat);
        eye.position.set(x, 0.7, 0.7);
        group.add(eye);
      });

      // 8 pernas
      const legGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 6);
      const legMat = new THREE.MeshLambertMaterial({ color });

      for (let i = 0; i < 8; i++) {
        const side = i < 4 ? -1 : 1;
        const angle = (i % 4) * Math.PI / 2;

        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(
                Math.cos(angle) * 0.7 * side,
                0.3,
                Math.sin(angle) * 0.4
        );
        leg.rotation.z = angle + (side > 0 ? Math.PI / 4 : -Math.PI / 4);
        leg.userData.isLeg = true;
        leg.userData.index = i;
        group.add(leg);
      } // ‚úÖ CORRIGIDO: Era });  agora √© apenas }

      return group;
    }
    createMesh() {
      switch(this.type) {
        case 'zombie':
        case 'skeleton':
          this.mesh = this.createZombieMesh();
          break;
        case 'creeper':
          this.mesh = this.createCreeperMesh();
          break;
        case 'spider':
          this.mesh = this.createSpiderMesh();
          break;
        default:
          const enemyType = enemyTypes[this.type];
          const geometry = new THREE.BoxGeometry(
                  enemyType.size.width,
                  enemyType.size.height,
                  enemyType.size.depth
          );
          const material = new THREE.MeshLambertMaterial({ color: enemyType.color });
          this.mesh = new THREE.Mesh(geometry, material);
      }

      this.mesh.position.set(this.x, this.y, this.z);
      this.mesh.userData.isEnemy = true;
      this.mesh.userData.enemyRef = this;
      scene.add(this.mesh);
      enemyMeshes.push(this.mesh);
      this.boundingBox = new THREE.Box3().setFromObject(this.mesh);
    }

    update() {
      this.animationTime += 0.1;
      this.attackCooldown = Math.max(0, this.attackCooldown - 1);

      // Dist√¢ncia at√© o jogador
      const dx = camera.position.x - this.x;
      const dz = camera.position.z - this.z;
      const distToPlayer = Math.sqrt(dx * dx + dz * dz);

      // Detectar jogador
      if (distToPlayer < this.detectionRange) {
        this.targetPlayer = true;
      }

      // Comportamento de persegui√ß√£o
      if (this.targetPlayer && distToPlayer > 1) {
        const dirX = dx / distToPlayer;
        const dirZ = dz / distToPlayer;

        this.x += dirX * this.speed;
        this.z += dirZ * this.speed;

        // Verificar colis√£o com blocos
        const blockBelow = getBlock(Math.floor(this.x), Math.floor(this.y - 1), Math.floor(this.z));
        if (!blockBelow) {
          this.y -= 0.5;
        }

        // Rota√ß√£o na dire√ß√£o do jogador
        if (this.mesh) {
          this.mesh.rotation.y = Math.atan2(-dx, -dz);
        }

        this.animateWalking();
      }

      // Ataque espec√≠fico do tipo
      if (distToPlayer < this.attackRange && this.attackCooldown === 0) {
        this.attack();
      }

      // Atualizar posi√ß√£o do mesh
      if (this.mesh) {
        this.mesh.position.set(this.x, this.y, this.z);
        this.boundingBox.setFromObject(this.mesh);
      }
    }

    animateWalking() {
      if (!this.mesh) return;

      this.mesh.traverse(child => {
        if (child.userData.isLeg) {
          if (this.type === 'spider') {
            const legMove = Math.sin(this.animationTime * 8 + child.userData.index) * 0.2;
            child.rotation.z += legMove * 0.1;
          } else {
            const legMove = Math.sin(this.animationTime * 8) * 0.5;
            if (child.userData.side === 'left') {
              child.rotation.x = legMove;
            } else {
              child.rotation.x = -legMove;
            }
          }
        }

        if (child.userData.isArm && (this.type === 'zombie' || this.type === 'skeleton')) {
          const armMove = Math.sin(this.animationTime * 8) * 0.5;
          if (child.userData.side === 'left') {
            child.rotation.x = -armMove;
          } else {
            child.rotation.x = armMove;
          }
        }
      });
    }

    attack() {
      if (this.type === 'creeper') {
        // Creeper explode
        if (!this.exploding) {
          this.exploding = true;
          this.explodeTimer = Date.now();
        }

        const elapsed = Date.now() - this.explodeTimer;

        // Piscar vermelho
        if (this.mesh && Math.floor(elapsed / 100) % 2 === 0) {
          this.mesh.traverse(child => {
            if (child.material) {
              child.material.color.set(0xFFFFFF);
            }
          });
        } else if (this.mesh) {
          this.mesh.traverse(child => {
            if (child.material) {
              child.material.color.set(enemyTypes.creeper.color);
            }
          });
        }

        if (elapsed > enemyTypes.creeper.explodeTime) {
          this.explode();
        }
      } else {
        // Ataque direto
        damagePlayer(this.damage);
        this.attackCooldown = 60;
      }
    }

    explode() {
      // Dano ao jogador
      const dx = camera.position.x - this.x;
      const dz = camera.position.z - this.z;
      const dist = Math.sqrt(dx * dx + dz * dz);

      if (dist < 5) {
        const damage = Math.floor(this.damage * (1 - dist / 5));
        damagePlayer(damage);
      }

      // Destruir blocos ao redor
      for (let x = -2; x <= 2; x++) {
        for (let y = -1; y <= 1; y++) {
          for (let z = -2; z <= 2; z++) {
            const bx = Math.floor(this.x) + x;
            const by = Math.floor(this.y) + y;
            const bz = Math.floor(this.z) + z;

            const block = getBlock(bx, by, bz);
            if (block && block.type !== 'bedrock' && Math.random() > 0.3) {
              removeBlockData(bx, by, bz);
            }
          }
        }
      }

      // Reconstruir chunks afetados
      const chunk = worldToChunk(this.x, this.z);
      for (let cx = -1; cx <= 1; cx++) {
        for (let cz = -1; cz <= 1; cz++) {
          const key = getChunkKey(chunk.x + cx, chunk.z + cz);
          if (chunkMeshes[key]) {
            buildChunkMesh(chunk.x + cx, chunk.z + cz);
          }
        }
      }

      this.remove();
      const index = enemies.indexOf(this);
      if (index > -1) enemies.splice(index, 1);
    }

    damage(amount) {
      this.health -= amount;

      if (this.mesh) {
        this.mesh.traverse(child => {
          if (child.material) {
            const originalColor = child.material.color.clone();
            child.material.color.set(0xFF0000);
            setTimeout(() => {
              if (child.material) {
                child.material.color.copy(originalColor);
              }
            }, 100);
          }
        });
      }

      if (this.health <= 0) {
        this.dropItems();
        this.remove();
        const index = enemies.indexOf(this);
        if (index > -1) enemies.splice(index, 1);
        return true;
      }
      return false;
    }

    dropItems() {
      const enemyType = enemyTypes[this.type];
      if (enemyType.drops) {
        enemyType.drops.forEach(drop => {
          const count = Math.floor(Math.random() *
                  (enemyType.dropCount.max - enemyType.dropCount.min + 1)) + enemyType.dropCount.min;
          if (count > 0) addToInventory(drop, count);
        });
      }
    }

    remove() {
      if (this.mesh) {
        this.mesh.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => mat.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
        scene.remove(this.mesh);
        const index = enemyMeshes.indexOf(this.mesh);
        if (index > -1) enemyMeshes.splice(index, 1);
      }
    }
  }

  function spawnEnemies(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;

    // ‚úÖ REDUZIDO: 0 a 2 inimigos por chunk (antes era 2-5)
    const spawnCount = Math.floor(Math.random() * 3); // 0, 1 ou 2 inimigos

    for (let i = 0; i < spawnCount; i++) {
      const x = sx + Math.random() * CHUNK_SIZE;
      const z = sz + Math.random() * CHUNK_SIZE;
      const y = getHeight(x, z) + 1;

      const blockBelow = getBlock(Math.floor(x), Math.floor(y - 1), Math.floor(z));

      // ‚úÖ REDUZIDO: 20% de chance (antes era 50%)
      if (blockBelow && Math.random() > 0.8) {
        const types = Object.keys(enemyTypes);
        const type = types[Math.floor(Math.random() * types.length)];

        const enemy = new Enemy(type, x, y, z);
        enemies.push(enemy);
      }
    }
  }

  function updateEnemies() {
    enemies.forEach(enemy => {
      if (enemy.update) {
        enemy.update();
      }
    });
  }


  let villagers = [];
  let villagerMeshes = [];
  let villages = [];

  class Villager {
    constructor(x, y, z, profession) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.profession = profession || 'farmer';
      this.health = 20;
      this.homeX = x;
      this.homeZ = z;
      this.wanderRadius = 10;
      this.targetX = x;
      this.targetZ = z;
      this.speed = 0.015;
      this.moveTimer = 0;
      this.animationTime = 0;
      this.mesh = null;
      this.boundingBox = null;

      this.createMesh();
    }

    createMesh() {
      const group = new THREE.Group();

      // Cor baseada na profiss√£o
      const professionColors = {
        farmer: 0x8B4513,
        librarian: 0xFFFFFF,
        blacksmith: 0x696969,
        priest: 0x800080,
        butcher: 0xFFEBCD
      };

      const color = professionColors[this.profession] || 0x8B4513;

      // Corpo
      const bodyGeo = new THREE.BoxGeometry(0.6, 1, 0.3);
      const bodyMat = new THREE.MeshLambertMaterial({ color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 1.1;
      group.add(body);

      // Cabe√ßa (maior que zumbis)
      const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
      const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.8;
      group.add(head);

      // Nariz grande (caracter√≠stico)
      const noseGeo = new THREE.BoxGeometry(0.2, 0.3, 0.2);
      const noseMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const nose = new THREE.Mesh(noseGeo, noseMat);
      nose.position.set(0, 1.8, 0.4);
      group.add(nose);

      // Bra√ßos
      const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
      const armMat = new THREE.MeshLambertMaterial({ color });

      const leftArm = new THREE.Mesh(armGeo, armMat);
      leftArm.position.set(-0.4, 1, 0);
      leftArm.userData.isArm = true;
      leftArm.userData.side = 'left';
      group.add(leftArm);

      const rightArm = new THREE.Mesh(armGeo, armMat);
      rightArm.position.set(0.4, 1, 0);
      rightArm.userData.isArm = true;
      rightArm.userData.side = 'right';
      group.add(rightArm);

      // Pernas
      const legGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
      const legMat = new THREE.MeshLambertMaterial({ color: 0x654321 });

      const leftLeg = new THREE.Mesh(legGeo, legMat);
      leftLeg.position.set(-0.15, 0.5, 0);
      leftLeg.userData.isLeg = true;
      leftLeg.userData.side = 'left';
      group.add(leftLeg);

      const rightLeg = new THREE.Mesh(legGeo, legMat);
      rightLeg.position.set(0.15, 0.5, 0);
      rightLeg.userData.isLeg = true;
      rightLeg.userData.side = 'right';
      group.add(rightLeg);

      this.mesh = group;
      this.mesh.position.set(this.x, this.y, this.z);
      this.mesh.userData.isVillager = true;
      scene.add(this.mesh);
      villagerMeshes.push(this.mesh);
      this.boundingBox = new THREE.Box3().setFromObject(this.mesh);
    }

    update() {
      this.moveTimer++;
      this.animationTime += 0.1;

      // Movimento aleat√≥rio dentro do raio
      if (this.moveTimer > 180 && Math.random() < 0.02) {
        this.targetX = this.homeX + (Math.random() - 0.5) * this.wanderRadius;
        this.targetZ = this.homeZ + (Math.random() - 0.5) * this.wanderRadius;
        this.moveTimer = 0;
      }

      const dx = this.targetX - this.x;
      const dz = this.targetZ - this.z;
      const dist = Math.sqrt(dx * dx + dz * dz);

      if (dist > 0.5) {
        this.x += (dx / dist) * this.speed;
        this.z += (dz / dist) * this.speed;

        const blockBelow = getBlock(Math.floor(this.x), Math.floor(this.y - 1), Math.floor(this.z));
        if (!blockBelow) {
          this.y -= 0.5;
        }

        this.animateWalking();

        if (this.mesh) {
          this.mesh.rotation.y = Math.atan2(-dx, -dz);
        }
      }

      if (this.mesh) {
        this.mesh.position.set(this.x, this.y, this.z);
        this.boundingBox.setFromObject(this.mesh);
      }
    }

    animateWalking() {
      if (!this.mesh) return;

      this.mesh.traverse(child => {
        if (child.userData.isLeg) {
          const legMove = Math.sin(this.animationTime * 6) * 0.4;
          if (child.userData.side === 'left') {
            child.rotation.x = legMove;
          } else {
            child.rotation.x = -legMove;
          }
        }

        if (child.userData.isArm) {
          const armMove = Math.sin(this.animationTime * 6) * 0.3;
          if (child.userData.side === 'left') {
            child.rotation.x = -armMove;
          } else {
            child.rotation.x = armMove;
          }
        }
      });
    }

    remove() {
      if (this.mesh) {
        this.mesh.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        scene.remove(this.mesh);
        const index = villagerMeshes.indexOf(this.mesh);
        if (index > -1) villagerMeshes.splice(index, 1);
      }
    }
  }

  // SUBSTITUIR a classe PlayerCharacter completa
  class PlayerCharacter {
    constructor() {
      this.group = new THREE.Group();
      this.animations = {
        idle: { time: 0, speed: 0.5 },
        walk: { time: 0, speed: 2 },
        jump: { time: 0, speed: 1.5 },
        run: { time: 0, speed: 3 }
      };
      this.currentAnimation = 'idle';
      this.createRealisticModel();
    }

    createRealisticModel() {
      // Cabe√ßa com mais detalhes
      const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      const headMaterial = new THREE.MeshLambertMaterial({
        color: 0xFFDBAC,
        flatShading: false
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 1.75;
      head.castShadow = true;
      head.receiveShadow = true;
      this.head = head;
      this.group.add(head);

      // Cabelo/Chap√©u
      const hairGeometry = new THREE.BoxGeometry(0.52, 0.15, 0.52);
      const hairMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
      const hair = new THREE.Mesh(hairGeometry, hairMaterial);
      hair.position.y = 2.05;
      hair.castShadow = true;
      this.group.add(hair);

      // Pesco√ßo
      const neckGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.2, 8);
      const neckMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
      const neck = new THREE.Mesh(neckGeometry, neckMaterial);
      neck.position.y = 1.4;
      neck.castShadow = true;
      this.group.add(neck);

      // Corpo com mais forma
      const torsoGeometry = new THREE.BoxGeometry(0.7, 0.9, 0.35);
      const torsoMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
      const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
      torso.position.y = 0.95;
      torso.castShadow = true;
      torso.receiveShadow = true;
      this.group.add(torso);

      // Cintura
      const waistGeometry = new THREE.BoxGeometry(0.65, 0.15, 0.33);
      const waistMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
      const waist = new THREE.Mesh(waistGeometry, waistMaterial);
      waist.position.y = 0.48;
      waist.castShadow = true;
      this.group.add(waist);

      // Bra√ßo esquerdo (ombro + antebra√ßo)
      const shoulderGeometry = new THREE.CylinderGeometry(0.12, 0.11, 0.4, 8);
      const armMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });

      this.leftShoulder = new THREE.Mesh(shoulderGeometry, armMaterial);
      this.leftShoulder.position.set(-0.45, 1.15, 0);
      this.leftShoulder.castShadow = true;
      this.group.add(this.leftShoulder);

      const forearmGeometry = new THREE.CylinderGeometry(0.1, 0.09, 0.45, 8);
      const skinMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });

      this.leftForearm = new THREE.Mesh(forearmGeometry, skinMaterial);
      this.leftForearm.position.set(-0.45, 0.65, 0);
      this.leftForearm.castShadow = true;
      this.group.add(this.leftForearm);

      // M√£o esquerda
      const handGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
      this.leftHand = new THREE.Mesh(handGeometry, skinMaterial);
      this.leftHand.position.set(-0.45, 0.35, 0);
      this.leftHand.castShadow = true;
      this.group.add(this.leftHand);

      // Bra√ßo direito (ombro + antebra√ßo)
      this.rightShoulder = new THREE.Mesh(shoulderGeometry, armMaterial);
      this.rightShoulder.position.set(0.45, 1.15, 0);
      this.rightShoulder.castShadow = true;
      this.group.add(this.rightShoulder);

      this.rightForearm = new THREE.Mesh(forearmGeometry, skinMaterial);
      this.rightForearm.position.set(0.45, 0.65, 0);
      this.rightForearm.castShadow = true;
      this.group.add(this.rightForearm);

      // M√£o direita
      this.rightHand = new THREE.Mesh(handGeometry, skinMaterial);
      this.rightHand.position.set(0.45, 0.35, 0);
      this.rightHand.castShadow = true;
      this.group.add(this.rightHand);

      // Pernas (coxa + canela)
      const thighGeometry = new THREE.CylinderGeometry(0.14, 0.13, 0.5, 8);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });

      this.leftThigh = new THREE.Mesh(thighGeometry, legMaterial);
      this.leftThigh.position.set(-0.18, 0.15, 0);
      this.leftThigh.castShadow = true;
      this.group.add(this.leftThigh);

      const calfGeometry = new THREE.CylinderGeometry(0.12, 0.11, 0.5, 8);

      this.leftCalf = new THREE.Mesh(calfGeometry, legMaterial);
      this.leftCalf.position.set(-0.18, -0.35, 0);
      this.leftCalf.castShadow = true;
      this.group.add(this.leftCalf);

      // P√© esquerdo
      const footGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.3);
      const shoeMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
      this.leftFoot = new THREE.Mesh(footGeometry, shoeMaterial);
      this.leftFoot.position.set(-0.18, -0.65, 0.05);
      this.leftFoot.castShadow = true;
      this.group.add(this.leftFoot);

      // Perna direita
      this.rightThigh = new THREE.Mesh(thighGeometry, legMaterial);
      this.rightThigh.position.set(0.18, 0.15, 0);
      this.rightThigh.castShadow = true;
      this.group.add(this.rightThigh);

      this.rightCalf = new THREE.Mesh(calfGeometry, legMaterial);
      this.rightCalf.position.set(0.18, -0.35, 0);
      this.rightCalf.castShadow = true;
      this.group.add(this.rightCalf);

      // P√© direito
      this.rightFoot = new THREE.Mesh(footGeometry, shoeMaterial);
      this.rightFoot.position.set(0.18, -0.65, 0.05);
      this.rightFoot.castShadow = true;
      this.group.add(this.rightFoot);

      // Olhos com brilho
      const eyeGeometry = new THREE.SphereGeometry(0.04, 8, 8);
      const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x1E90FF });

      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.12, 1.8, 0.25);
      this.group.add(leftEye);

      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.12, 1.8, 0.25);
      this.group.add(rightEye);

      // Pupilas
      const pupilGeometry = new THREE.SphereGeometry(0.02, 6, 6);
      const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

      const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
      leftPupil.position.set(-0.12, 1.8, 0.27);
      this.group.add(leftPupil);

      const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
      rightPupil.position.set(0.12, 1.8, 0.27);
      this.group.add(rightPupil);

      // Sombra circular embaixo
      const shadowGeometry = new THREE.CircleGeometry(0.4, 16);
      const shadowMaterial = new THREE.MeshBasicMaterial({
        color: 0x000000,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      const shadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
      shadow.rotation.x = -Math.PI / 2;
      shadow.position.y = -0.69;
      this.group.add(shadow);
    }

    updateAnimation(deltaTime, isMoving, isJumping, isRunning) {
      const animType = isJumping ? 'jump' : isRunning ? 'run' : isMoving ? 'walk' : 'idle';
      const anim = this.animations[animType];
      anim.time += deltaTime * anim.speed;

      if (isJumping) {
        this.updateJumpAnimation(anim.time);
      } else if (isRunning) {
        this.updateRunAnimation(anim.time);
      } else if (isMoving) {
        this.updateWalkAnimation(anim.time);
      } else {
        this.updateIdleAnimation(anim.time);
      }
    }

    updateIdleAnimation(time) {
      const breath = Math.sin(time) * 0.015;
      this.group.position.y = breath;

      // Respira√ß√£o sutil
      this.group.scale.y = 1 + Math.sin(time * 1.5) * 0.01;

      // Movimento sutil dos bra√ßos
      this.leftShoulder.rotation.x = Math.sin(time * 0.5) * 0.05;
      this.rightShoulder.rotation.x = Math.sin(time * 0.5 + Math.PI) * 0.05;

      // Cabe√ßa olhando levemente
      this.head.rotation.y = Math.sin(time * 0.3) * 0.1;
    }

    updateWalkAnimation(time) {
      const legSwing = Math.sin(time) * 0.6;
      const armSwing = Math.sin(time + Math.PI) * 0.4;
      const bob = Math.sin(time * 2) * 0.04;

      this.group.position.y = bob;

      // Balan√ßo natural das pernas
      this.leftThigh.rotation.x = legSwing;
      this.rightThigh.rotation.x = -legSwing;

      // Canelas seguem as coxas com delay
      this.leftCalf.rotation.x = Math.max(0, legSwing * 0.5);
      this.rightCalf.rotation.x = Math.max(0, -legSwing * 0.5);

      // P√©s com movimento natural
      this.leftFoot.rotation.x = legSwing * 0.3;
      this.rightFoot.rotation.x = -legSwing * 0.3;

      // Bra√ßos balan√ßando oposto √†s pernas
      this.leftShoulder.rotation.x = armSwing;
      this.rightShoulder.rotation.x = -armSwing;

      this.leftForearm.rotation.x = armSwing * 0.5;
      this.rightForearm.rotation.x = -armSwing * 0.5;

      // Rota√ß√£o sutil do tronco
      this.group.rotation.z = Math.sin(time) * 0.03;

      // Cabe√ßa balan√ßa levemente
      this.head.rotation.x = bob * 0.5;
    }

    updateRunAnimation(time) {
      const legSwing = Math.sin(time) * 0.9;
      const armSwing = Math.sin(time + Math.PI) * 0.7;
      const bob = Math.sin(time * 2) * 0.08;

      this.group.position.y = bob;

      // Inclina√ß√£o do corpo para frente ao correr
      this.group.rotation.x = -0.1;

      // Movimento exagerado das pernas
      this.leftThigh.rotation.x = legSwing;
      this.rightThigh.rotation.x = -legSwing;

      this.leftCalf.rotation.x = Math.max(0, legSwing * 0.8);
      this.rightCalf.rotation.x = Math.max(0, -legSwing * 0.8);

      // Bra√ßos mais din√¢micos
      this.leftShoulder.rotation.x = armSwing;
      this.rightShoulder.rotation.x = -armSwing;

      this.leftForearm.rotation.x = armSwing * 0.6;
      this.rightForearm.rotation.x = -armSwing * 0.6;

      // Rota√ß√£o do tronco mais pronunciada
      this.group.rotation.z = Math.sin(time) * 0.05;
    }

    updateJumpAnimation(time) {
      const jumpPhase = Math.min(time, Math.PI);
      const jumpHeight = Math.sin(jumpPhase) * 0.3;

      this.group.position.y = jumpHeight;

      // Bra√ßos para cima
      this.leftShoulder.rotation.x = -0.8 - jumpHeight;
      this.rightShoulder.rotation.x = -0.8 - jumpHeight;

      this.leftForearm.rotation.x = -0.3;
      this.rightForearm.rotation.x = -0.3;

      // Pernas dobradas
      this.leftThigh.rotation.x = 0.6 + jumpHeight * 0.5;
      this.rightThigh.rotation.x = 0.6 + jumpHeight * 0.5;

      this.leftCalf.rotation.x = -0.8 - jumpHeight;
      this.rightCalf.rotation.x = -0.8 - jumpHeight;

      // Cabe√ßa para tr√°s
      this.head.rotation.x = -0.2;
    }

    setPosition(x, y, z) {
      this.group.position.set(x, y, z);
    }

    setRotation(y) {
      this.group.rotation.y = y;
    }
  }

  function buildHouse(x, y, z) {
    // Base (5x5)
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'planks');
      }
    }

    // Paredes
    for (let dy = 0; dy < 4; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          if (Math.abs(dx) === 2 || Math.abs(dz) === 2) {
            if (dy === 1 && dx === 0 && dz === 2) {
              // Porta
              removeBlockData(x + dx, y + dy, z + dz);
            } else {
              setBlock(x + dx, y + dy, z + dz, 'planks');
            }
          }
        }
      }
    }

    // Telhado
    for (let dy = 0; dy < 3; dy++) {
      const size = 2 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -size; dz <= size; dz++) {
          setBlock(x + dx, y + 4 + dy, z + dz, 'brick');
        }
      }
    }

    // Janelas
    setBlock(x - 2, y + 2, z, 'glass');
    setBlock(x + 2, y + 2, z, 'glass');
  }

  function buildWell(x, y, z) {
    // Base do po√ßo
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
          setBlock(x + dx, y, z + dz, 'cobblestone');
          setBlock(x + dx, y + 1, z + dz, 'cobblestone');
          setBlock(x + dx, y + 2, z + dz, 'cobblestone');
        } else {
          // √Ågua no centro
          setBlock(x, y - 3, z, 'glass');
          setBlock(x, y - 2, z, 'glass');
          setBlock(x, y - 1, z, 'glass');
        }
      }
    }

    // Teto
    setBlock(x, y + 4, z, 'wood');
  }


  function createVillagePaths(centerX, villageY, centerZ) {
    // Caminhos em cruz
    for (let i = -20; i <= 20; i++) {
      // Horizontal
      setBlock(centerX + i, villageY, centerZ, 'cobblestone');
      setBlock(centerX + i, villageY, centerZ + 1, 'cobblestone');
      setBlock(centerX + i, villageY, centerZ - 1, 'cobblestone');

      // Vertical
      setBlock(centerX, villageY, centerZ + i, 'cobblestone');
      setBlock(centerX + 1, villageY, centerZ + i, 'cobblestone');
      setBlock(centerX - 1, villageY, centerZ + i, 'cobblestone');
    }

    // Lanternas ao longo dos caminhos
    for (let i = -20; i <= 20; i += 5) {
      setBlock(centerX + i, villageY + 1, centerZ + 3, 'lantern');
      setBlock(centerX + i, villageY + 1, centerZ - 3, 'lantern');
      setBlock(centerX + 3, villageY + 1, centerZ + i, 'lantern');
      setBlock(centerX - 3, villageY + 1, centerZ + i, 'lantern');
    }
  }

  function buildChurch(x, y, z) {
    // Base maior (7x10)
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -5; dz <= 5; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'cobblestone');
      }
    }

    // Paredes
    for (let dy = 0; dy < 6; dy++) {
      for (let dx = -3; dx <= 3; dx++) {
        for (let dz = -5; dz <= 5; dz++) {
          if (Math.abs(dx) === 3 || Math.abs(dz) === 5) {
            if (dy === 1 && dx === 0 && dz === 5) {
              continue; // Porta
            }
            setBlock(x + dx, y + dy, z + dz, 'quartz');
          }
        }
      }
    }

    // Torre do sino
    for (let dy = 0; dy < 10; dy++) {
      setBlock(x, y + 6 + dy, z, 'quartz');
    }

    // Topo da torre com glowstone
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + dx, y + 16, z + dz, 'glowstone');
      }
    }

    // Telhado principal
    for (let dy = 0; dy < 4; dy++) {
      const size = 3 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -5 + dy; dz <= 5 - dy; dz++) {
          setBlock(x + dx, y + 6 + dy, z + dz, 'brick');
        }
      }
    }

    // Janelas com vidro
    setBlock(x - 3, y + 3, z - 2, 'glass');
    setBlock(x - 3, y + 3, z + 2, 'glass');
    setBlock(x + 3, y + 3, z - 2, 'glass');
    setBlock(x + 3, y + 3, z + 2, 'glass');

    // Lanternas internas
    setBlock(x - 2, y + 4, z - 3, 'lantern');
    setBlock(x + 2, y + 4, z - 3, 'lantern');
    setBlock(x - 2, y + 4, z + 3, 'lantern');
    setBlock(x + 2, y + 4, z + 3, 'lantern');
  }

  function buildFarm(x, y, z) {
    // Cercado (8x8)
    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -4; dz <= 4; dz++) {
        if (Math.abs(dx) === 4 || Math.abs(dz) === 4) {
          setBlock(x + dx, y, z + dz, 'planks');
          setBlock(x + dx, y + 1, z + dz, 'planks');
        }
      }
    }

    // √Årea cultivada
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        if ((dx + dz) % 2 === 0) {
          setBlock(x + dx, y, z + dz, 'dirt');
          // Plantas decorativas
          if (Math.random() > 0.5) {
            setBlock(x + dx, y + 1, z + dz, 'leaves');
          }
        } else {
          setBlock(x + dx, y, z + dz, 'water');
        }
      }
    }

    // Port√£o
    removeBlockData(x, y, z + 4);
    removeBlockData(x, y + 1, z + 4);

    // Celeiro pequeno
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 0; dz++) {
        if (Math.abs(dx) === 2 || dz === -2) {
          setBlock(x + dx + 6, y, z + dz, 'wood');
          setBlock(x + dx + 6, y + 1, z + dz, 'wood');
          setBlock(x + dx + 6, y + 2, z + dz, 'wood');
        }
      }
    }

    // Telhado do celeiro
    for (let dx = -2; dx <= 2; dx++) {
      setBlock(x + dx + 6, y + 3, z - 1, 'brick');
    }
  }

  function buildTower(x, y, z) {
    // Torre de vigia (3x3, altura 12)
    for (let dy = 0; dy < 12; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
            setBlock(x + dx, y + dy, z + dz, 'cobblestone');
          } else if (dy > 0 && dy < 11) {
            removeBlockData(x + dx, y + dy, z + dz); // Interior vazio
          }
        }
      }
    }

    // Escadas internas (simplificadas)
    for (let dy = 0; dy < 11; dy++) {
      const pos = dy % 4;
      switch(pos) {
        case 0: setBlock(x + 1, y + dy, z, 'planks'); break;
        case 1: setBlock(x, y + dy, z + 1, 'planks'); break;
        case 2: setBlock(x - 1, y + dy, z, 'planks'); break;
        case 3: setBlock(x, y + dy, z - 1, 'planks'); break;
      }
    }

    // Topo com ameias
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        if (Math.abs(dx) === 2 || Math.abs(dz) === 2) {
          if ((dx + dz) % 2 === 0) {
            setBlock(x + dx, y + 12, z + dz, 'cobblestone');
            setBlock(x + dx, y + 13, z + dz, 'cobblestone');
          }
        }
      }
    }

    // Tocha no topo
    setBlock(x, y + 14, z, 'torch');

    // Porta
    removeBlockData(x + 1, y, z);
    removeBlockData(x + 1, y + 1, z);
  }

  function buildLibrary(x, y, z) {
    // Base (6x6)
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'planks');
      }
    }

    // Paredes
    for (let dy = 0; dy < 5; dy++) {
      for (let dx = -3; dx <= 3; dx++) {
        for (let dz = -3; dz <= 3; dz++) {
          if (Math.abs(dx) === 3 || Math.abs(dz) === 3) {
            if (dy === 1 && dx === 0 && dz === 3) {
              continue; // Porta
            }
            setBlock(x + dx, y + dy, z + dz, 'planks');
          }
        }
      }
    }

    // Estantes nas paredes internas
    const shelfPositions = [
      { dx: -2, dz: -2 }, { dx: 0, dz: -2 }, { dx: 2, dz: -2 },
      { dx: -2, dz: 2 }, { dx: 2, dz: 2 },
      { dx: -2, dz: 0 }, { dx: 2, dz: 0 }
    ];

    shelfPositions.forEach(pos => {
      setBlock(x + pos.dx, y + 1, z + pos.dz, 'bookshelf');
      setBlock(x + pos.dx, y + 2, z + pos.dz, 'bookshelf');
    });

    // Mesa de trabalho e ba√∫ no centro
    setBlock(x, y + 1, z, 'crafting_table');
    setBlock(x + 1, y + 1, z, 'chest');

    // Telhado
    for (let dy = 0; dy < 3; dy++) {
      const size = 3 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -size; dz <= size; dz++) {
          setBlock(x + dx, y + 5 + dy, z + dz, 'brick');
        }
      }
    }

    // Lanternas
    setBlock(x - 2, y + 3, z - 2, 'lantern');
    setBlock(x + 2, y + 3, z - 2, 'lantern');
    setBlock(x - 2, y + 3, z + 2, 'lantern');
    setBlock(x + 2, y + 3, z + 2, 'lantern');

    // Janelas
    setBlock(x - 3, y + 2, z, 'glass');
    setBlock(x + 3, y + 2, z, 'glass');
  }

  function updateVillagers() {
    villagers.forEach(villager => {
      if (villager.update) {
        villager.update();
      }
    });
  }

  let playerModel = null;

  function createPlayerModel() {
    const group = new THREE.Group();

    // Corpo
    const bodyGeo = new THREE.BoxGeometry(0.6, 0.9, 0.3);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = -0.8;
    group.add(body);

    // Cabe√ßa
    const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = -0.1;
    head.userData.isHead = true;
    group.add(head);

    // Bra√ßos
    const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
    const armMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });

    const leftArm = new THREE.Mesh(armGeo, armMat);
    leftArm.position.set(-0.4, -0.7, 0);
    leftArm.userData.isArm = true;
    leftArm.userData.side = 'left';
    group.add(leftArm);

    const rightArm = new THREE.Mesh(armGeo, armMat);
    rightArm.position.set(0.4, -0.7, 0);
    rightArm.userData.isArm = true;
    rightArm.userData.side = 'right';
    group.add(rightArm);

    // Pernas
    const legGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
    const legMat = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });

    const leftLeg = new THREE.Mesh(legGeo, legMat);
    leftLeg.position.set(-0.15, -1.4, 0);
    leftLeg.userData.isLeg = true;
    leftLeg.userData.side = 'left';
    group.add(leftLeg);

    const rightLeg = new THREE.Mesh(legGeo, legMat);
    rightLeg.position.set(0.15, -1.4, 0);
    rightLeg.userData.isLeg = true;
    rightLeg.userData.side = 'right';
    group.add(rightLeg);

    playerModel = group;
    camera.add(playerModel);
  }

  let walkAnimTime = 0;
  function updatePlayerModel() {
    if (!playerModel) return;

    // Animar baseado no movimento
    const isMoving = keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'];

    if (isMoving && !player.flying) {
      walkAnimTime += 0.15;

      playerModel.traverse(child => {
        if (child.userData.isLeg) {
          const legMove = Math.sin(walkAnimTime) * 0.6;
          if (child.userData.side === 'left') {
            child.rotation.x = legMove;
          } else {
            child.rotation.x = -legMove;
          }
        }

        if (child.userData.isArm) {
          const armMove = Math.sin(walkAnimTime) * 0.5;
          if (child.userData.side === 'left') {
            child.rotation.x = -armMove;
          } else {
            child.rotation.x = armMove;
          }
        }
      });
    } else {
      // Resetar posi√ß√µes quando parado
      playerModel.traverse(child => {
        if (child.userData.isLeg || child.userData.isArm) {
          child.rotation.x *= 0.9;
        }
      });
    }

    // Balan√ßo de cabe√ßa baseado na rota√ß√£o da c√¢mera
    playerModel.traverse(child => {
      if (child.userData.isHead) {
        child.rotation.y = mouse.x * 0.1;
        child.rotation.x = mouse.y * 0.1;
      }
    });
  }

  const originalHandleMouseDown = handleMouseDown;
  handleMouseDown = function(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;

    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

    // Verificar inimigos primeiro
    if (e.button === 0) {
      const enemyIntersects = raycaster.intersectObjects(enemyMeshes);
      if (enemyIntersects.length > 0) {
        const enemyMesh = enemyIntersects[0].object;
        let enemy = null;

        // Encontrar o grupo pai que cont√©m a refer√™ncia ao inimigo
        let current = enemyMesh;
        while (current && !enemy) {
          if (current.userData && current.userData.enemyRef) {
            enemy = current.userData.enemyRef;
          }
          current = current.parent;
        }

        if (enemy) {
          enemy.damage(5);
          return;
        }
      }
    }

    // Chamar fun√ß√£o original para blocos e animais
    originalHandleMouseDown.call(this, e);
  };

  // Modificar a fun√ß√£o startGame
  const originalStartGame = startGame;
  startGame = function() {
    originalStartGame.call(this);

    // Criar modelo do jogador
    createPlayerModel();

    // Gerar uma vila pr√≥xima ao spawn
    generateVillage(30, 30);

    // Spawnar alguns inimigos
    const chunk = worldToChunk(0, 0);
    for (let cx = chunk.x - 2; cx <= chunk.x + 2; cx++) {
      for (let cz = chunk.z - 2; cz <= chunk.z + 2; cz++) {
        if (Math.random() > 0.7) {
          spawnEnemies(cx, cz);
        }
      }
    }

    initMobileControls();
    animate();
  };

  // Atualizar UI para mostrar contagem de entidades
  document.getElementById('animals-count').parentElement.querySelector('strong').textContent = 'Entidades:';





































  // ============================================
  // VARI√ÅVEIS GLOBAIS ADICIONAIS
  // ============================================

  let sky, waterMeshes = [], particles = [], clouds = [];
  let dayNightCycle = 0;
  const DAY_LENGTH = 120000; // 2 minutos para ciclo completo

  // ============================================
  // PERSONAGEM MELHORADO
  // ============================================


  let playerCharacter = null;

  // ============================================
  // SISTEMA DE √ÅGUA
  // ============================================

  class WaterSystem {
    constructor() {
      this.meshes = [];
      this.waterLevels = new Map();
    }

    createWaterBlock(x, y, z) {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshLambertMaterial({
        color: 0x1E90FF,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide
      });

      const water = new THREE.Mesh(geometry, material);
      water.position.set(x, y, z);
      water.userData.isWater = true;
      water.userData.waveOffset = Math.random() * Math.PI * 2;
      water.userData.baseY = y;

      scene.add(water);
      this.meshes.push(water);
      waterMeshes.push(water);

      return water;
    }

    updateWaves(time) {
      for (const water of this.meshes) {
        if (water.userData.isWater) {
          const waveHeight = Math.sin(time * 2 + water.userData.waveOffset) * 0.05;
          water.position.y = water.userData.baseY + waveHeight;

          // Efeito de transpar√™ncia pulsante
          water.material.opacity = 0.6 + Math.sin(time * 3 + water.userData.waveOffset) * 0.1;
        }
      }
    }

    removeWater(x, y, z) {
      for (let i = this.meshes.length - 1; i >= 0; i--) {
        const water = this.meshes[i];
        if (Math.floor(water.position.x) === x &&
                Math.floor(water.position.y) === y &&
                Math.floor(water.position.z) === z) {
          scene.remove(water);
          water.geometry.dispose();
          water.material.dispose();
          this.meshes.splice(i, 1);

          const waterIndex = waterMeshes.indexOf(water);
          if (waterIndex > -1) waterMeshes.splice(waterIndex, 1);
          break;
        }
      }
    }
  }

  let waterSystem = null;

  // ============================================
  // SISTEMA DE PART√çCULAS OTIMIZADO
  // ============================================

  class ParticleSystem {
    constructor() {
      this.particles = [];
      this.maxParticles = 1000;
      this.pool = [];
      this.initPool();
    }

    initPool() {
      for (let i = 0; i < this.maxParticles; i++) {
        const geometry = new THREE.SphereGeometry(0.05, 3, 3);
        const material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const particle = new THREE.Mesh(geometry, material);
        particle.visible = false;
        scene.add(particle);
        this.pool.push(particle);
      }
    }

    emit(position, color, count = 10, velocity = 0.1) {
      for (let i = 0; i < Math.min(count, this.pool.length); i++) {
        const particle = this.pool.pop();
        if (!particle) break;

        particle.position.copy(position);
        particle.position.add(new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2
        ));

        particle.material.color.set(color);
        particle.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * velocity,
                Math.random() * velocity * 0.5,
                (Math.random() - 0.5) * velocity
        );
        particle.userData.life = 1.0;
        particle.userData.decay = 0.02 + Math.random() * 0.02;
        particle.visible = true;

        this.particles.push(particle);
      }
    }

    update() {
      for (let i = this.particles.length - 1; i >= 0; i--) {
        const particle = this.particles[i];

        particle.userData.life -= particle.userData.decay;
        particle.position.add(particle.userData.velocity);
        particle.userData.velocity.y -= 0.01;

        particle.material.opacity = particle.userData.life;
        particle.scale.setScalar(particle.userData.life);

        if (particle.userData.life <= 0) {
          particle.visible = false;
          this.pool.push(particle);
          this.particles.splice(i, 1);
        }
      }
    }
  }

  let particleSystem = null;

  // ============================================
  // C√âU DIN√ÇMICO E ILUMINA√á√ÉO
  // ============================================

  function createSky() {
    // C√©u gradient
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const context = canvas.getContext('2d');

    const gradient = context.createLinearGradient(0, 0, 0, 256);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(0.5, '#98D8F0');
    gradient.addColorStop(1, '#B0E0E6');

    context.fillStyle = gradient;
    context.fillRect(0, 0, 256, 256);

    const texture = new THREE.CanvasTexture(canvas);
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.BackSide,
      fog: false
    });

    sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);
  }

  function createClouds() {
    const cloudCount = 30;
    for (let i = 0; i < cloudCount; i++) {
      const cloudGroup = new THREE.Group();

      // Criar nuvem com m√∫ltiplas esferas
      const cloudPieces = 3 + Math.floor(Math.random() * 3);
      for (let j = 0; j < cloudPieces; j++) {
        const size = 3 + Math.random() * 2;
        const geometry = new THREE.SphereGeometry(size, 8, 8);
        const material = new THREE.MeshLambertMaterial({
          color: 0xFFFFFF,
          transparent: true,
          opacity: 0.8
        });

        const piece = new THREE.Mesh(geometry, material);
        piece.position.set(
                (Math.random() - 0.5) * 8,
                (Math.random() - 0.5) * 3,
                (Math.random() - 0.5) * 8
        );
        cloudGroup.add(piece);
      }

      // Posicionar nuvem no c√©u
      cloudGroup.position.set(
              (Math.random() - 0.5) * 400,
              80 + Math.random() * 40,
              (Math.random() - 0.5) * 400
      );

      cloudGroup.userData.speed = 0.01 + Math.random() * 0.02;
      cloudGroup.userData.direction = new THREE.Vector3(
              Math.random() - 0.5,
              0,
              Math.random() - 0.5
      ).normalize();

      scene.add(cloudGroup);
      clouds.push(cloudGroup);
    }
  }

  function updateDayNightCycle(deltaTime) {
    dayNightCycle = (dayNightCycle + deltaTime * 0.001) % 1;

    const timeOfDay = Math.sin(dayNightCycle * Math.PI * 2);
    const brightness = Math.max(0.3, timeOfDay * 0.5 + 0.5);

    // Atualizar luz ambiente
    scene.traverse(object => {
      if (object.isLight && object.type !== 'AmbientLight') {
        object.intensity = brightness;
      }
    });

    // Atualizar cor do c√©u
    if (sky && sky.material.map) {
      const canvas = sky.material.map.image;
      const context = canvas.getContext('2d');

      const dayColor = `rgb(${135 * brightness}, ${206 * brightness}, ${235 * brightness})`;
      const nightColor = `rgb(${10 * brightness}, ${10 * brightness}, ${40 * brightness})`;

      const gradient = context.createLinearGradient(0, 0, 0, 256);
      gradient.addColorStop(0, timeOfDay > 0 ? dayColor : nightColor);
      gradient.addColorStop(1, timeOfDay > 0 ?
              `rgb(${152 * brightness}, ${216 * brightness}, ${240 * brightness})` :
              `rgb(${5 * brightness}, ${5 * brightness}, ${20 * brightness})`);

      context.fillStyle = gradient;
      context.fillRect(0, 0, 256, 256);

      sky.material.map.needsUpdate = true;
    }

    // Mover nuvens
    clouds.forEach(cloud => {
      cloud.position.add(cloud.userData.direction.clone().multiplyScalar(cloud.userData.speed));

      // Reposicionar nuvens que sa√≠ram do mapa
      if (cloud.position.length() > 500) {
        cloud.position.set(
                (Math.random() - 0.5) * 400,
                80 + Math.random() * 40,
                (Math.random() - 0.5) * 400
        );
      }
    });
  }

  // ============================================
  // SISTEMA DE TEXTURAS PROCEDURAIS
  // ============================================

  const textureCache = {};

  function createTexture(type, size = 64) {
    if (textureCache[type]) return textureCache[type];

    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    switch(type) {
      case 'grass':
        createGrassTexture(ctx, size);
        break;

      case 'dirt':
        createDirtTexture(ctx, size);
        break;

      case 'stone':
        createStoneTexture(ctx, size);
        break;

      case 'wood':
        createWoodTexture(ctx, size);
        break;

      case 'leaves':
        createLeavesTexture(ctx, size);
        break;

      case 'sand':
        createSandTexture(ctx, size);
        break;

      case 'cobblestone':
        createCobblestoneTexture(ctx, size);
        break;

      case 'planks':
        createPlanksTexture(ctx, size);
        break;

      case 'brick':
        createBrickTexture(ctx, size);
        break;

      case 'obsidian':
        createObsidianTexture(ctx, size);
        break;

      case 'glowstone':
        createGlowstoneTexture(ctx, size);
        break;

      case 'quartz':
        createQuartzTexture(ctx, size);
        break;

      case 'bookshelf':
        createBookshelfTexture(ctx, size);
        break;

      case 'coal_ore':
        createStoneTexture(ctx, size);
        // Veios de carv√£o
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(52, 52, 52, 0.8)';
          ctx.fillRect(x, y, 6, 6);
        }
        break;

      case 'iron_ore':
        createStoneTexture(ctx, size);
        // Manchas de ferro
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(216, 175, 147, 0.7)';
          ctx.fillRect(x, y, 8, 8);
        }
        break;

      case 'diamond_ore':
        createStoneTexture(ctx, size);
        // Cristais de diamante
        for (let i = 0; i < 12; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(0, 206, 209, 0.9)';
          ctx.fillRect(x, y, 6, 6);
          // Brilho
          ctx.fillStyle = 'rgba(100, 255, 255, 0.5)';
          ctx.fillRect(x + 2, y + 2, 2, 2);
        }
        break;

      case 'gold_ore':
        createStoneTexture(ctx, size);
        // Veios de ouro
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
          ctx.fillRect(x, y, 7, 7);
          // Brilho dourado
          ctx.fillStyle = 'rgba(255, 235, 100, 0.4)';
          ctx.fillRect(x + 1, y + 1, 3, 3);
        }
        break;

      case 'emerald_ore':
        createStoneTexture(ctx, size);
        // Cristais de esmeralda
        for (let i = 0; i < 12; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(80, 200, 120, 0.9)';
          ctx.fillRect(x, y, 6, 6);
          // Brilho verde
          ctx.fillStyle = 'rgba(100, 255, 150, 0.4)';
          ctx.fillRect(x + 2, y + 2, 2, 2);
        }
        break;

      case 'redstone_ore':
        createStoneTexture(ctx, size);
        // Veios de redstone
        for (let i = 0; i < 18; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
          ctx.fillRect(x, y, 5, 5);
          // Brilho vermelho
          ctx.fillStyle = 'rgba(255, 50, 50, 0.5)';
          ctx.fillRect(x + 1, y + 1, 2, 2);
        }
        break;

      case 'lapis_ore':
        createStoneTexture(ctx, size);
        // Manchas de l√°pis-laz√∫li
        for (let i = 0; i < 16; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(0, 0, 255, 0.8)';
          ctx.fillRect(x, y, 6, 6);
        }
        break;

      case 'gravel':
        // Base cinza
        ctx.fillStyle = '#8B8680';
        ctx.fillRect(0, 0, size, size);
        // Pedrinhas
        for (let i = 0; i < size * 10; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgb(${139 + shade}, ${134 + shade}, ${128 + shade})`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'clay':
        // Base cinza claro
        ctx.fillStyle = '#A0A0A0';
        ctx.fillRect(0, 0, size, size);
        // Textura de argila
        for (let i = 0; i < size * 8; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 30 - 15;
          ctx.fillStyle = `rgb(${160 + shade}, ${160 + shade}, ${160 + shade})`;
          ctx.fillRect(x, y, 3, 3);
        }
        break;

      case 'ice':
        // Base azul claro
        ctx.fillStyle = '#B0E0E6';
        ctx.fillRect(0, 0, size, size);
        // Cristais de gelo
        for (let i = 0; i < 30; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(200, 230, 240, 0.5)';
          ctx.fillRect(x, y, 4, 4);
        }
        // Brilhos
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'snow':
        // Base branca
        ctx.fillStyle = '#FFFAFA';
        ctx.fillRect(0, 0, size, size);
        // Cristais de neve
        for (let i = 0; i < size * 6; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(240, 248, 255, 0.8)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'glass':
        // Base transparente azulada
        ctx.fillStyle = '#ADD8E6';
        ctx.fillRect(0, 0, size, size);
        // Reflexos
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.fillRect(x, y, 6, 2);
        }
        break;

      case 'lantern':
        // Base met√°lica
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(0, 0, size, size);
        // Grades
        ctx.strokeStyle = '#8B7500';
        ctx.lineWidth = 2;
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.moveTo(i * size/4, 0);
          ctx.lineTo(i * size/4, size);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, i * size/4);
          ctx.lineTo(size, i * size/4);
          ctx.stroke();
        }
        // Luz central
        const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/3);
        gradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
        gradient.addColorStop(1, 'rgba(255, 215, 0, 0.3)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        break;

      case 'torch':
        // Base escura
        ctx.fillStyle = '#654321';
        ctx.fillRect(0, 0, size, size);
        // Cabo da tocha
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(size/2 - 4, size/2, 8, size/2);
        // Fogo
        const torchGradient = ctx.createRadialGradient(size/2, size/3, 0, size/2, size/3, size/3);
        torchGradient.addColorStop(0, 'rgba(255, 255, 100, 1)');
        torchGradient.addColorStop(0.5, 'rgba(255, 140, 0, 0.8)');
        torchGradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
        ctx.fillStyle = torchGradient;
        ctx.beginPath();
        ctx.arc(size/2, size/3, size/3, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'prismarine':
        // Base turquesa
        ctx.fillStyle = '#4ECDC4';
        ctx.fillRect(0, 0, size, size);
        // Padr√£o oce√¢nico
        for (let i = 0; i < size * 8; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 60 - 30;
          ctx.fillStyle = `rgba(${78 + shade}, ${205 + shade}, ${196 + shade}, 0.7)`;
          ctx.fillRect(x, y, 4, 4);
        }
        break;

      case 'purpur':
        // Base roxa
        ctx.fillStyle = '#A569BD';
        ctx.fillRect(0, 0, size, size);
        // Padr√£o de purpur
        for (let i = 0; i < size * 6; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgba(${165 + shade}, ${105 + shade}, ${189 + shade}, 0.8)`;
          ctx.fillRect(x, y, 5, 5);
        }
        break;

      case 'endstone':
        // Base amarelada
        ctx.fillStyle = '#E4E096';
        ctx.fillRect(0, 0, size, size);
        // Textura porosa
        for (let i = 0; i < size * 10; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgba(${228 + shade}, ${224 + shade}, ${150 + shade}, 0.8)`;
          ctx.fillRect(x, y, 3, 3);
        }
        break;

      case 'netherite':
        // Base roxa escura
        ctx.fillStyle = '#8B008B';
        ctx.fillRect(0, 0, size, size);
        // Padr√£o met√°lico
        for (let i = 0; i < 40; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(139, 0, 139, 0.6)';
          ctx.fillRect(x, y, 6, 6);
        }
        // Brilhos met√°licos
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(200, 100, 200, 0.4)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_white':
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, size, size);
        // Textura lisa
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(240, 240, 240, 0.3)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_red':
        ctx.fillStyle = '#DC143C';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 20 - 10;
          ctx.fillStyle = `rgba(${220 + shade}, ${20 + shade}, ${60 + shade}, 0.3)`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_blue':
        ctx.fillStyle = '#1E90FF';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 20 - 10;
          ctx.fillStyle = `rgba(${30 + shade}, ${144 + shade}, ${255 + shade}, 0.3)`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_green':
        ctx.fillStyle = '#32CD32';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 20 - 10;
          ctx.fillStyle = `rgba(${50 + shade}, ${205 + shade}, ${50 + shade}, 0.3)`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_yellow':
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 20 - 10;
          ctx.fillStyle = `rgba(${255 + shade}, ${215 + shade}, ${0 + shade}, 0.3)`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_black':
        ctx.fillStyle = '#2F4F4F';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(40, 60, 60, 0.3)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'crafting_table':
        // Base madeira
        createPlanksTexture(ctx, size);
        // Grade de ferramentas no topo
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 2;
        ctx.strokeRect(size/4, size/4, size/2, size/2);
        ctx.beginPath();
        ctx.moveTo(size/2, size/4);
        ctx.lineTo(size/2, 3*size/4);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(size/4, size/2);
        ctx.lineTo(3*size/4, size/2);
        ctx.stroke();
        break;

      case 'furnace':
        createStoneTexture(ctx, size);
        // Abertura da fornalha
        ctx.fillStyle = '#1C1C1C';
        ctx.fillRect(size/4, size/3, size/2, size/3);
        // Borda
        ctx.strokeStyle = '#4A4A4A';
        ctx.lineWidth = 3;
        ctx.strokeRect(size/4, size/3, size/2, size/3);
        break;

      case 'chest':
        createPlanksTexture(ctx, size);
        // Tranca
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(size/2 - 6, size/2 - 4, 12, 8);
        // Detalhes met√°licos
        ctx.strokeStyle = '#8B7500';
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, size, size);
        ctx.beginPath();
        ctx.moveTo(0, size/2);
        ctx.lineTo(size, size/2);
        ctx.stroke();
        break;

      case 'mushroom_red':
        // Base vermelha
        ctx.fillStyle = '#FF0000';
        ctx.fillRect(0, 0, size, size);
        // Pintas brancas
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const r = 2 + Math.random() * 4;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }
        break;

      case 'mushroom_brown':
        // Base marrom
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(0, 0, size, size);
        // Textura de cogumelo
        for (let i = 0; i < size * 5; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgba(${139 + shade}, ${69 + shade}, ${19 + shade}, 0.6)`;
          ctx.fillRect(x, y, 3, 3);
        }
        break;

      case 'pumpkin':
        // Base laranja
        ctx.fillStyle = '#FF8C00';
        ctx.fillRect(0, 0, size, size);
        // Gomos verticais
        ctx.strokeStyle = '#CC7000';
        ctx.lineWidth = 3;
        for (let i = 1; i < 4; i++) {
          ctx.beginPath();
          ctx.moveTo(i * size/4, 0);
          ctx.lineTo(i * size/4, size);
          ctx.stroke();
        }
        // Rosto (opcional)
        ctx.fillStyle = '#000000';
        ctx.fillRect(size/4, size/3, 8, 8);
        ctx.fillRect(3*size/4 - 8, size/3, 8, 8);
        ctx.fillRect(size/3, 2*size/3, size/3, 6);
        break;

      case 'melon':
        // Base verde clara
        ctx.fillStyle = '#90EE90';
        ctx.fillRect(0, 0, size, size);
        // Listras verdes escuras
        ctx.strokeStyle = '#228B22';
        ctx.lineWidth = 4;
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.moveTo(0, i * size/4);
          ctx.lineTo(size, i * size/4);
          ctx.stroke();
        }
        break;

      case 'water':
        // Base azul
        ctx.fillStyle = '#1E90FF';
        ctx.fillRect(0, 0, size, size);
        // Ondas
        for (let i = 0; i < 10; i++) {
          const y = i * size/10;
          ctx.strokeStyle = 'rgba(100, 149, 237, 0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let x = 0; x < size; x += 4) {
            const wave = Math.sin(x * 0.1 + i) * 3;
            ctx.lineTo(x, y + wave);
          }
          ctx.stroke();
        }
        // Brilhos
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(173, 216, 230, 0.4)';
          ctx.fillRect(x, y, 3, 3);
        }
        break;

      case 'bedrock':
        // Base muito escura
        ctx.fillStyle = '#2F2F2F';
        ctx.fillRect(0, 0, size, size);
        // Padr√£o irregular
        for (let i = 0; i < size * 12; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 30 - 15;
          ctx.fillStyle = `rgb(${47 + shade}, ${47 + shade}, ${47 + shade})`;
          ctx.fillRect(x, y, 4, 4);
        }
        // Manchas pretas
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(x, y, 6, 6);
        }
        break;

      default:
        createDefaultTexture(ctx, size, blockTypes[type]?.color || 0x808080);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    textureCache[type] = texture;
    return texture;
  }

  // ============================================
  // SISTEMA DE TEXTURAS PROCEDURAIS MELHORADO
  // ============================================

  function createEnhancedTexture(type, size = 64) {
    if (textureCache[type]) return textureCache[type];

    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    switch(type) {
      case 'grass':
        createEnhancedGrassTexture(ctx, size);
        break;

      case 'dirt':
        createEnhancedDirtTexture(ctx, size);
        break;

      case 'stone':
        createEnhancedStoneTexture(ctx, size);
        break;

      case 'wood':
        createEnhancedWoodTexture(ctx, size);
        break;

      case 'leaves':
        createEnhancedLeavesTexture(ctx, size);
        break;

      case 'sand':
        createEnhancedSandTexture(ctx, size);
        break;

      case 'water':
        createEnhancedWaterTexture(ctx, size);
        break;

      case 'glass':
        createEnhancedGlassTexture(ctx, size);
        break;

      case 'cobblestone':
        createEnhancedCobblestoneTexture(ctx, size);
        break;

      case 'planks':
        createEnhancedPlanksTexture(ctx, size);
        break;

      case 'brick':
        createEnhancedBrickTexture(ctx, size);
        break;

      case 'bedrock':
        createEnhancedBedrockTexture(ctx, size);
        break;

      default:
        // Usar a fun√ß√£o original para outros tipos
        return createTexture(type, size);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    textureCache[type] = texture;
    return texture;
  }

  // ============================================
  // TEXTURAS MELHORADAS
  // ============================================

  function createEnhancedGrassTexture(ctx, size) {
    // Base verde com gradiente
    const gradient = ctx.createLinearGradient(0, 0, 0, size);
    gradient.addColorStop(0, '#7CFC00');
    gradient.addColorStop(0.3, '#6BCD00');
    gradient.addColorStop(0.6, '#5AB000');
    gradient.addColorStop(1, '#4A9000');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o de cor
    for (let i = 0; i < size * 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      const opacity = 0.2 + Math.random() * 0.3;
      ctx.fillStyle = `rgba(${100 + shade}, ${200 + shade}, ${0}, ${opacity})`;
      const s = 1 + Math.random() * 2;
      ctx.fillRect(x, y, s, s);
    }

    // Segunda camada - textura de grama
    for (let i = 0; i < size * 4; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60 - 30;
      ctx.fillStyle = `rgba(${80 + shade}, ${180 + shade}, ${0}, 0.4)`;
      ctx.fillRect(x, y, 3, 3);
    }

    // Manchas escuras (terra aparecendo)
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(70, 50, 20, 0.4)');
      grd.addColorStop(1, 'rgba(70, 50, 20, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Brilhos de orvalho
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(200, 255, 150, 0.3)';
      ctx.fillRect(x, y, 2, 2);
    }

    // Detalhes de grama individual
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = `rgba(90, 180, 0, ${0.2 + Math.random() * 0.3})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.random() * 2 - 1, y - 3 - Math.random() * 2);
      ctx.stroke();
    }
  }

  function createEnhancedDirtTexture(ctx, size) {
    // Base marrom com gradiente
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, '#8B4513');
    gradient.addColorStop(0.5, '#7A3C0F');
    gradient.addColorStop(1, '#6B350D');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o de terra
    for (let i = 0; i < size * 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 80 - 40;
      const opacity = 0.3 + Math.random() * 0.5;
      ctx.fillStyle = `rgba(${139 + shade}, ${69 + shade}, ${19 + shade}, ${opacity})`;
      const s = 2 + Math.random() * 4;
      ctx.fillRect(x, y, s, s);
    }

    // Pedrinhas e cascalho
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40;
      ctx.fillStyle = `rgba(${100 + shade}, ${100 + shade}, ${100 + shade}, 0.4)`;
      const s = 1 + Math.random() * 3;
      ctx.fillRect(x, y, s, s);
    }

    // Ra√≠zes e material org√¢nico
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = 'rgba(60, 40, 20, 0.5)';
      ctx.lineWidth = 1 + Math.random();
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.random() * 8 - 4, y + Math.random() * 8 - 4);
      ctx.stroke();
    }

    // Manchas √∫midas
    for (let i = 0; i < 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 5;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(50, 30, 10, 0.3)');
      grd.addColorStop(1, 'rgba(50, 30, 10, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }
  }

  function createEnhancedStoneTexture(ctx, size) {
    // Base cinza com gradiente
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, '#888888');
    gradient.addColorStop(0.5, '#787878');
    gradient.addColorStop(1, '#686868');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o de pedra
    for (let i = 0; i < size * 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 100 - 50;
      const opacity = 0.2 + Math.random() * 0.4;
      ctx.fillStyle = `rgba(${128 + shade}, ${128 + shade}, ${128 + shade}, ${opacity})`;
      const s = 2 + Math.random() * 5;
      ctx.fillRect(x, y, s, s);
    }

    // Veios minerais
    for (let i = 0; i < 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = `rgba(${150 + Math.random() * 50}, ${150 + Math.random() * 50}, ${150 + Math.random() * 50}, 0.4)`;
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      for (let j = 0; j < 3 + Math.random() * 3; j++) {
        ctx.lineTo(x + Math.random() * 15 - 7.5, y + Math.random() * 15 - 7.5);
      }
      ctx.stroke();
    }

    // Rachaduras
    for (let i = 0; i < 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = 'rgba(40, 40, 40, 0.4)';
      ctx.lineWidth = 0.5 + Math.random();
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.random() * 10 - 5, y + Math.random() * 10 - 5);
      ctx.stroke();
    }

    // Cristais pequenos
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = `rgba(200, 200, 200, ${0.2 + Math.random() * 0.3})`;
      ctx.fillRect(x, y, 1, 1);
    }
  }

  function createEnhancedWoodTexture(ctx, size) {
    // Base madeira
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, size, size);

    // An√©is de crescimento com mais detalhe
    const centerX = size / 2;
    const centerY = size / 2;
    const maxRadius = size * 0.8;

    for (let r = 3; r < maxRadius; r += 2 + Math.random() * 3) {
      const thickness = 1 + Math.random() * 2;
      const shade = Math.random() * 50 - 25;
      const opacity = 0.2 + Math.random() * 0.4;

      ctx.strokeStyle = `rgba(${80 + shade}, ${50 + shade}, ${20 + shade}, ${opacity})`;
      ctx.lineWidth = thickness;

      ctx.beginPath();
      // Anel irregular
      for (let angle = 0; angle <= Math.PI * 2; angle += 0.1) {
        const variation = Math.sin(angle * 8) * 2 + Math.random() * 2;
        const radius = r + variation;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;

        if (angle === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      ctx.stroke();
    }

    // Veios verticais
    for (let i = 0; i < 40; i++) {
      const x = Math.random() * size;
      ctx.strokeStyle = `rgba(70, 45, 15, ${0.1 + Math.random() * 0.2})`;
      ctx.lineWidth = 0.5 + Math.random();
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x + Math.random() * 4 - 2, size);
      ctx.stroke();
    }

    // N√≥s da madeira
    for (let i = 0; i < 3; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 6;

      for (let r = 0; r < radius; r += 1) {
        const shade = Math.random() * 30 - 15;
        ctx.strokeStyle = `rgba(${50 + shade}, ${30 + shade}, ${10 + shade}, 0.3)`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
  }

  function createEnhancedLeavesTexture(ctx, size) {
    // Base verde escuro
    ctx.fillStyle = '#228B22';
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o de folhas
    for (let i = 0; i < size * 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 80 - 40;
      const opacity = 0.3 + Math.random() * 0.5;
      ctx.fillStyle = `rgba(${34 + shade}, ${139 + shade}, ${34 + shade}, ${opacity})`;
      const s = 2 + Math.random() * 4;
      ctx.fillRect(x, y, s, s);
    }

    // Folhas individuais detalhadas
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const size_leaf = 2 + Math.random() * 3;
      const shade = Math.random() * 60 - 30;

      ctx.fillStyle = `rgba(${50 + shade}, ${200 + shade}, ${50 + shade}, ${0.4 + Math.random() * 0.3})`;
      ctx.beginPath();
      // Forma de folha
      ctx.ellipse(x, y, size_leaf, size_leaf * 1.5, Math.random() * Math.PI * 2, 0, Math.PI * 2);
      ctx.fill();
    }

    // Veias das folhas
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = `rgba(20, 100, 20, ${0.2 + Math.random() * 0.2})`;
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.random() * 4 - 2, y + 3 + Math.random() * 2);
      ctx.stroke();
    }

    // √Åreas de luz (onde o sol passa)
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(150, 255, 100, 0.3)');
      grd.addColorStop(1, 'rgba(150, 255, 100, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Buracos/transpar√™ncia
    for (let i = 0; i < 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.fillRect(x, y, 3, 3);
    }
  }

  function createEnhancedSandTexture(ctx, size) {
    // Base areia com gradiente
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, '#F4A460');
    gradient.addColorStop(0.5, '#E39450');
    gradient.addColorStop(1, '#D28440');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - gr√£os de areia
    for (let i = 0; i < size * 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60 - 30;
      const opacity = 0.3 + Math.random() * 0.4;
      ctx.fillStyle = `rgba(${244 + shade}, ${164 + shade}, ${96 + shade}, ${opacity})`;
      ctx.fillRect(x, y, 1, 1);
    }

    // Segunda camada - gr√£os maiores
    for (let i = 0; i < size * 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgba(${240 + shade}, ${160 + shade}, ${90 + shade}, 0.5)`;
      ctx.fillRect(x, y, 2, 2);
    }

    // Manchas mais escuras
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(200, 140, 80, 0.3)');
      grd.addColorStop(1, 'rgba(200, 140, 80, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Brilhos
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(255, 220, 180, 0.4)';
      ctx.fillRect(x, y, 1, 1);
    }
  }

  function createEnhancedWaterTexture(ctx, size) {
    // Base azul com gradiente
    const gradient = ctx.createLinearGradient(0, 0, 0, size);
    gradient.addColorStop(0, '#1E90FF');
    gradient.addColorStop(0.5, '#1873CC');
    gradient.addColorStop(1, '#1565C0');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Ondas (m√∫ltiplas camadas)
    for (let layer = 0; layer < 3; layer++) {
      const amplitude = 4 - layer;
      const frequency = 0.15 + layer * 0.05;
      const yOffset = layer * size / 3;

      for (let y = 0; y < size / 3; y += 2) {
        ctx.strokeStyle = `rgba(${100 + layer * 20}, ${149 + layer * 20}, ${237 + layer * 20}, ${0.3 - layer * 0.1})`;
        ctx.lineWidth = 1 + layer * 0.5;
        ctx.beginPath();

        for (let x = 0; x < size; x += 2) {
          const wave = Math.sin(x * frequency + y * 0.1) * amplitude;
          const wavY = yOffset + y + wave;

          if (x === 0) {
            ctx.moveTo(x, wavY);
          } else {
            ctx.lineTo(x, wavY);
          }
        }
        ctx.stroke();
      }
    }

    // Reflexos de luz (c√°usticos)
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 5;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(173, 216, 230, 0.5)');
      grd.addColorStop(0.5, 'rgba(173, 216, 230, 0.2)');
      grd.addColorStop(1, 'rgba(173, 216, 230, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Espuma/bolhas
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 1 + Math.random() * 2;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function createEnhancedGlassTexture(ctx, size) {
    // Base transparente azulada
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, 'rgba(173, 216, 230, 0.3)');
    gradient.addColorStop(0.5, 'rgba(173, 216, 230, 0.2)');
    gradient.addColorStop(1, 'rgba(173, 216, 230, 0.3)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Reflexos diagonais
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const length = 10 + Math.random() * 20;
      const angle = Math.random() * Math.PI / 4 - Math.PI / 8;

      ctx.strokeStyle = `rgba(255, 255, 255, ${0.2 + Math.random() * 0.3})`;
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
      ctx.stroke();
    }

    // Brilhos pontuais
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
      grd.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Imperfei√ß√µes (bolhas)
    for (let i = 0; i < 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 1 + Math.random() * 2;
      ctx.fillStyle = 'rgba(230, 240, 250, 0.4)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function createEnhancedCobblestoneTexture(ctx, size) {
    // Base cinza escuro
    ctx.fillStyle = '#6B6B6B';
    ctx.fillRect(0, 0, size, size);

    // Pedras individuais com mais detalhe
    const stones = 20;
    const stoneSize = size / 5;

    for (let i = 0; i < stones; i++) {
      const col = i % 5;
      const row = Math.floor(i / 5);
      const x = col * stoneSize + Math.random() * 6 - 3;
      const y = row * stoneSize + Math.random() * 6 - 3;
      const w = stoneSize - Math.random() * 8;
      const h = stoneSize - Math.random() * 8;

      // Base da pedra com gradiente
      const shade = Math.random() * 50 - 25;
      const grd = ctx.createLinearGradient(x, y, x + w, y + h);
      grd.addColorStop(0, `rgb(${107 + shade}, ${107 + shade}, ${107 + shade})`);
      grd.addColorStop(1, `rgb(${87 + shade}, ${87 + shade}, ${87 + shade})`);
      ctx.fillStyle = grd;
      ctx.fillRect(x, y, w, h);

      // Textura interna da pedra
      for (let j = 0; j < 10; j++) {
        const px = x + Math.random() * w;
        const py = y + Math.random() * h;
        const pshade = Math.random() * 40 - 20;
        ctx.fillStyle = `rgba(${107 + pshade}, ${107 + pshade}, ${107 + pshade}, 0.5)`;
        ctx.fillRect(px, py, 2, 2);
      }

      // Contorno da pedra
      ctx.strokeStyle = 'rgba(40, 40, 40, 0.6)';
      ctx.lineWidth = 1 + Math.random();
      ctx.strokeRect(x, y, w, h);

      // Destaque (luz)
      ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + w * 0.3, y);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y + h * 0.3);
      ctx.stroke();
    }

    // Argamassa entre as pedras
    ctx.fillStyle = 'rgba(80, 80, 80, 0.5)';
    for (let i = 1; i < 5; i++) {
      ctx.fillRect(i * stoneSize - 2, 0, 4, size);
      ctx.fillRect(0, i * stoneSize - 2, size, 4);
    }
  }

  function createEnhancedPlanksTexture(ctx, size) {
    // Base madeira clara
    ctx.fillStyle = '#C19A6B';
    ctx.fillRect(0, 0, size, size);

    // T√°buas horizontais com detalhe
    const plankHeight = size / 5;

    for (let i = 0; i < 5; i++) {
      const y = i * plankHeight;
      const shade = Math.random() * 40 - 20;

      // Gradiente na t√°bua
      const grd = ctx.createLinearGradient(0, y, 0, y + plankHeight);
      grd.addColorStop(0, `rgb(${193 + shade}, ${154 + shade}, ${107 + shade})`);
      grd.addColorStop(0.5, `rgb(${183 + shade}, ${144 + shade}, ${97 + shade})`);
      grd.addColorStop(1, `rgb(${193 + shade}, ${154 + shade}, ${107 + shade})`);
      ctx.fillStyle = grd;
      ctx.fillRect(0, y, size, plankHeight - 3);

      // Veios da madeira
      for (let j = 0; j < 30; j++) {
        const x = Math.random() * size;
        const vshade = Math.random() * 30 - 15;
        ctx.strokeStyle = `rgba(${140 + vshade}, ${100 + vshade}, ${60 + vshade}, ${0.15 + Math.random() * 0.2})`;
        ctx.lineWidth = 0.5 + Math.random() * 0.5;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.random() * 4 - 2, y + plankHeight - 3);
        ctx.stroke();
      }

      // N√≥s da madeira
      if (Math.random() > 0.6) {
        const kx = Math.random() * size;
        const ky = y + Math.random() * (plankHeight - 3);
        const kr = 2 + Math.random() * 4;

        for (let r = 0; r < kr; r++) {
          ctx.strokeStyle = `rgba(100, 70, 40, ${0.3 - r * 0.05})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(kx, ky, r, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      // Linha entre t√°buas
      ctx.fillStyle = 'rgba(80, 60, 40, 0.6)';
      ctx.fillRect(0, y + plankHeight - 3, size, 3);

      // Detalhe de sombra na linha
      ctx.fillStyle = 'rgba(60, 40, 20, 0.4)';
      ctx.fillRect(0, y + plankHeight - 3, size, 1);
    }

    // Pregos decorativos
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
      ctx.beginPath();
      ctx.arc(x, y, 1, 0, Math.PI * 2);
      ctx.fill();

      // Brilho do prego
      ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
      ctx.fillRect(x - 0.5, y - 1, 1, 0.5);
    }
  }

  function createEnhancedBrickTexture(ctx, size) {
    // Base tijolo
    ctx.fillStyle = '#B22222';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de tijolos detalhado
    const brickW = size / 5;
    const brickH = size / 10;

    for (let row = 0; row < 10; row++) {
      const offset = (row % 2) * (brickW / 2);

      for (let col = 0; col < 6; col++) {
        const x = col * brickW + offset;
        const y = row * brickH;

        if (x < size && y < size) {
          // Base do tijolo com gradiente
          const shade = Math.random() * 50 - 25;
          const grd = ctx.createLinearGradient(x, y, x + brickW, y + brickH);
          grd.addColorStop(0, `rgb(${178 + shade}, ${34 + shade}, ${34 + shade})`);
          grd.addColorStop(1, `rgb(${158 + shade}, ${24 + shade}, ${24 + shade})`);
          ctx.fillStyle = grd;
          ctx.fillRect(x + 1, y + 1, brickW - 3, brickH - 3);

          // Textura do tijolo
          for (let i = 0; i < 8; i++) {
            const bx = x + 1 + Math.random() * (brickW - 3);
            const by = y + 1 + Math.random() * (brickH - 3);
            const bshade = Math.random() * 40 - 20;
            ctx.fillStyle = `rgba(${178 + bshade}, ${34 + bshade}, ${34 + bshade}, 0.4)`;
            ctx.fillRect(bx, by, 2, 2);
          }

          // Destaque (luz)
          ctx.strokeStyle = 'rgba(220, 80, 80, 0.3)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + 1, y + 1);
          ctx.lineTo(x + brickW - 3, y + 1);
          ctx.moveTo(x + 1, y + 1);
          ctx.lineTo(x + 1, y + brickH - 3);
          ctx.stroke();

          // Sombra
          ctx.strokeStyle = 'rgba(100, 20, 20, 0.4)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + brickW - 2, y + 1);
          ctx.lineTo(x + brickW - 2, y + brickH - 2);
          ctx.lineTo(x + 1, y + brickH - 2);
          ctx.stroke();
        }
      }
    }

    // Argamassa
    ctx.fillStyle = '#CCCCCC';
    for (let row = 0; row < 10; row++) {
      ctx.fillRect(0, row * brickH - 1, size, 2);
    }

    for (let col = 0; col < 6; col++) {
      for (let row = 0; row < 10; row++) {
        const offset = (row % 2) * (brickW / 2);
        const x = col * brickW + offset;
        ctx.fillRect(x - 1, 0, 2, size);
      }
    }
  }

  function createEnhancedBedrockTexture(ctx, size) {
    // Base muito escura
    ctx.fillStyle = '#1C1C1C';
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o escura
    for (let i = 0; i < size * 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      const opacity = 0.3 + Math.random() * 0.4;
      ctx.fillStyle = `rgba(${28 + shade}, ${28 + shade}, ${28 + shade}, ${opacity})`;
      const s = 2 + Math.random() * 5;
      ctx.fillRect(x, y, s, s);
    }

    // Manchas muito escuras (quase pretas)
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 6;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
      grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Cristais escuros
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60;
      ctx.fillStyle = `rgba(${28 + shade}, ${28 + shade}, ${46 + shade}, 0.5)`;
      ctx.fillRect(x, y, 3, 3);
    }

    // Rachaduras profundas
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      for (let j = 0; j < 2 + Math.random() * 3; j++) {
        ctx.lineTo(x + Math.random() * 15 - 7.5, y + Math.random() * 15 - 7.5);
      }
      ctx.stroke();
    }

    // Brilhos m√≠sticos (roxos escuros)
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(100, 50, 150, 0.3)');
      grd.addColorStop(1, 'rgba(100, 50, 150, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }
  }


  function createGrassTexture(ctx, size) {
    // Base verde vibrante
    const gradient = ctx.createLinearGradient(0, 0, 0, size);
    gradient.addColorStop(0, '#7CFC00');
    gradient.addColorStop(0.5, '#6BCD00');
    gradient.addColorStop(1, '#5AB000');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Camadas de grama
    for (let layer = 0; layer < 3; layer++) {
      for (let i = 0; i < size * 10; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const shade = Math.random() * 50 - 25;
        const opacity = 0.3 + Math.random() * 0.4;
        ctx.fillStyle = `rgba(${100 + shade}, ${200 + shade}, ${0}, ${opacity})`;
        ctx.fillRect(x, y, 2, 2);
      }
    }

    // Manchas escuras (sombras)
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 3;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(0, 80, 0, 0.3)');
      grd.addColorStop(1, 'rgba(0, 80, 0, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Brilhos
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(150, 255, 100, 0.4)';
      ctx.fillRect(x, y, 1, 1);
    }
  }

  function createDirtTexture(ctx, size) {
    // Base marrom
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(0, 0, size, size);

    // Textura de terra
    for (let i = 0; i < size * 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60 - 30;
      ctx.fillStyle = `rgb(${139 + shade}, ${69 + shade}, ${19 + shade})`;
      ctx.fillRect(x, y, Math.random() * 3, Math.random() * 3);
    }

    // Pedrinhas
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
      ctx.fillRect(x, y, 2, 2);
    }
  }

  function createStoneTexture(ctx, size) {
    // Base cinza
    ctx.fillStyle = '#808080';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de pedra
    for (let i = 0; i < size * 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 80 - 40;
      ctx.fillStyle = `rgb(${128 + shade}, ${128 + shade}, ${128 + shade})`;
      ctx.fillRect(x, y, Math.random() * 4, Math.random() * 4);
    }

    // Rachaduras
    ctx.strokeStyle = 'rgba(50, 50, 50, 0.3)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 8; i++) {
      ctx.beginPath();
      ctx.moveTo(Math.random() * size, Math.random() * size);
      ctx.lineTo(Math.random() * size, Math.random() * size);
      ctx.stroke();
    }
  }

  function createWoodTexture(ctx, size) {
    // Base madeira
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, size, size);

    // An√©is de crescimento
    const centerX = size / 2;
    const centerY = size / 2;

    for (let r = 5; r < size; r += 4) {
      ctx.strokeStyle = `rgba(${80 + Math.random() * 40}, ${50 + Math.random() * 30}, ${20 + Math.random() * 20}, ${0.3 + Math.random() * 0.3})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Veios de madeira
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(80, 50, 20, 0.2)';
      ctx.fillRect(x, y, 1, size);
    }
  }

  function createLeavesTexture(ctx, size) {
    // Base verde escuro
    ctx.fillStyle = '#228B22';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de folhas
    for (let i = 0; i < size * 6; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60 - 30;
      ctx.fillStyle = `rgba(${34 + shade}, ${139 + shade}, ${34 + shade}, 0.8)`;
      ctx.fillRect(x, y, 3, 3);
    }

    // Folhas individuais
    for (let i = 0; i < 40; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = `rgba(50, 200, 50, ${0.3 + Math.random() * 0.3})`;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function createSandTexture(ctx, size) {
    // Base areia
    ctx.fillStyle = '#F4A460';
    ctx.fillRect(0, 0, size, size);

    // Gr√£os de areia
    for (let i = 0; i < size * 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgb(${244 + shade}, ${164 + shade}, ${96 + shade})`;
      ctx.fillRect(x, y, 1, 1);
    }
  }

  function createCobblestoneTexture(ctx, size) {
    // Base cinza escuro
    ctx.fillStyle = '#6B6B6B';
    ctx.fillRect(0, 0, size, size);

    // Pedras individuais
    const stones = 16;
    const stoneSize = size / 4;

    for (let i = 0; i < stones; i++) {
      const x = (i % 4) * stoneSize + Math.random() * 8;
      const y = Math.floor(i / 4) * stoneSize + Math.random() * 8;
      const w = stoneSize - Math.random() * 4;
      const h = stoneSize - Math.random() * 4;

      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgb(${107 + shade}, ${107 + shade}, ${107 + shade})`;
      ctx.fillRect(x, y, w, h);

      // Contorno
      ctx.strokeStyle = 'rgba(40, 40, 40, 0.5)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, w, h);
    }
  }

  function createPlanksTexture(ctx, size) {
    // Base madeira clara
    ctx.fillStyle = '#C19A6B';
    ctx.fillRect(0, 0, size, size);

    // T√°buas horizontais
    const plankHeight = size / 4;
    for (let i = 0; i < 4; i++) {
      const y = i * plankHeight;
      const shade = Math.random() * 30 - 15;
      ctx.fillStyle = `rgb(${193 + shade}, ${154 + shade}, ${107 + shade})`;
      ctx.fillRect(0, y, size, plankHeight - 2);

      // Veios
      for (let j = 0; j < 20; j++) {
        const x = Math.random() * size;
        ctx.fillStyle = 'rgba(140, 100, 60, 0.2)';
        ctx.fillRect(x, y, 1, plankHeight);
      }

      // Linha entre t√°buas
      ctx.fillStyle = 'rgba(80, 60, 40, 0.5)';
      ctx.fillRect(0, y + plankHeight - 2, size, 2);
    }
  }

  function createBrickTexture(ctx, size) {
    // Base tijolo
    ctx.fillStyle = '#B22222';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de tijolos
    const brickW = size / 4;
    const brickH = size / 8;

    for (let row = 0; row < 8; row++) {
      const offset = (row % 2) * (brickW / 2);
      for (let col = 0; col < 5; col++) {
        const x = col * brickW + offset;
        const y = row * brickH;

        if (x < size && y < size) {
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgb(${178 + shade}, ${34 + shade}, ${34 + shade})`;
          ctx.fillRect(x, y, brickW - 2, brickH - 2);

          // Argamassa
          ctx.fillStyle = '#CCCCCC';
          ctx.fillRect(x, y + brickH - 2, brickW, 2);
          ctx.fillRect(x + brickW - 2, y, 2, brickH);
        }
      }
    }
  }

  function createObsidianTexture(ctx, size) {
    // Base preta
    ctx.fillStyle = '#1C1C2E';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o v√≠treo
    for (let i = 0; i < size * 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60;
      ctx.fillStyle = `rgba(${28 + shade}, ${28 + shade}, ${46 + shade}, 0.6)`;
      ctx.fillRect(x, y, 2, 2);
    }

    // Brilhos
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(100, 100, 150, 0.3)';
      ctx.fillRect(x, y, 3, 3);
    }
  }

  function createGlowstoneTexture(ctx, size) {
    // Base luminosa
    ctx.fillStyle = '#FFFF99';
    ctx.fillRect(0, 0, size, size);

    // Cristais brilhantes
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 50;
      ctx.fillStyle = `rgb(${255}, ${255 - shade}, ${153 + shade})`;
      ctx.fillRect(x, y, 4, 4);
    }

    // Pontos de luz
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, 6);
      gradient.addColorStop(0, 'rgba(255, 255, 200, 0.8)');
      gradient.addColorStop(1, 'rgba(255, 255, 150, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(x - 6, y - 6, 12, 12);
    }
  }

  function createQuartzTexture(ctx, size) {
    // Base branca
    ctx.fillStyle = '#F5F5F5';
    ctx.fillRect(0, 0, size, size);

    // Veios de quartzo
    ctx.strokeStyle = 'rgba(230, 230, 230, 0.5)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 15; i++) {
      ctx.beginPath();
      ctx.moveTo(Math.random() * size, Math.random() * size);
      ctx.lineTo(Math.random() * size, Math.random() * size);
      ctx.stroke();
    }

    // Cristais pequenos
    for (let i = 0; i < size * 5; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.fillRect(x, y, 2, 2);
    }
  }

  function createBookshelfTexture(ctx, size) {
    // Base madeira
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, size, size);

    // Livros
    const bookWidth = size / 8;
    const bookHeight = size / 2;
    const colors = ['#8B0000', '#00008B', '#006400', '#8B4513', '#4B0082', '#FF8C00'];

    for (let i = 0; i < 8; i++) {
      const x = i * bookWidth;
      const y = size / 4;
      const color = colors[Math.floor(Math.random() * colors.length)];

      ctx.fillStyle = color;
      ctx.fillRect(x, y, bookWidth - 2, bookHeight);

      // Lombada do livro
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(x + 2, y + 5, bookWidth - 6, 2);
    }

    // Prateleiras
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(0, 0, size, 4);
    ctx.fillRect(0, size - 4, size, 4);
  }

  function createDefaultTexture(ctx, size, color) {
    const r = (color >> 16) & 255;
    const g = (color >> 8) & 255;
    const b = color & 255;

    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    ctx.fillRect(0, 0, size, size);

    // Ru√≠do b√°sico
    for (let i = 0; i < size * 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgb(${r + shade}, ${g + shade}, ${b + shade})`;
      ctx.fillRect(x, y, 2, 2);
    }
  }

  // ============================================
  // SISTEMA MULTIPLAYER COMPLETO
  // ============================================

  const multiplayer = {
    enabled: false,
    connected: false,
    ws: null,
    serverUrl: 'ws://localhost:8765',
    playerId: null,
    playerName: 'Jogador' + Math.floor(Math.random() * 1000),
    otherPlayers: new Map(),
    lastPositionSent: 0,
    positionUpdateInterval: 50 // ms
  };

  function connectMultiplayer() {
    try {
      multiplayer.ws = new WebSocket(multiplayer.serverUrl);

      multiplayer.ws.onopen = () => {
        multiplayer.connected = true;
        console.log('‚úÖ Conectado ao servidor multiplayer');

        document.getElementById('mp-status').textContent = 'Conectado';
        document.getElementById('mp-status').className = 'mp-connected';

        showNotification('‚úÖ Conectado ao servidor!', 'success');
        updateMultiplayerMenuStatus();

        // Solicitar lista de jogadores
        sendMultiplayerMessage({ type: 'request_players' });
      };

      multiplayer.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleMultiplayerMessage(data);
        } catch (e) {
          console.error('Erro ao processar mensagem:', e);
        }
      };

      multiplayer.ws.onerror = (error) => {
        console.error('‚ùå Erro WebSocket:', error);
        showNotification('‚ùå Erro ao conectar ao servidor', 'error');
      };

      multiplayer.ws.onclose = () => {
        multiplayer.connected = false;
        console.log('üîå Desconectado do servidor');

        document.getElementById('mp-status').textContent = 'Desconectado';
        document.getElementById('mp-status').className = 'mp-disconnected';

        // Remover outros jogadores
        multiplayer.otherPlayers.forEach(player => {
          if (player.mesh) {
            scene.remove(player.mesh);
            player.mesh.traverse(child => {
              if (child.geometry) child.geometry.dispose();
              if (child.material) child.material.dispose();
            });
          }
        });
        multiplayer.otherPlayers.clear();

        showNotification('üîå Desconectado do servidor', 'info');
        updateMultiplayerMenuStatus();
        updatePlayerCount();
      };

    } catch (error) {
      console.error('‚ùå Erro ao conectar:', error);
      showNotification('‚ùå Falha na conex√£o: ' + error.message, 'error');
    }
  }

  function disconnectMultiplayer() {
    if (multiplayer.ws) {
      multiplayer.ws.close();
      multiplayer.ws = null;
    }
    multiplayer.connected = false;
    multiplayer.enabled = false;
  }

  function sendMultiplayerMessage(data) {
    if (multiplayer.connected && multiplayer.ws) {
      try {
        multiplayer.ws.send(JSON.stringify(data));
      } catch (e) {
        console.error('Erro ao enviar mensagem:', e);
      }
    }
  }

  function handleMultiplayerMessage(data) {
    switch (data.type) {
      case 'player_id':
        multiplayer.playerId = data.playerId;
        console.log('üÜî ID recebido:', multiplayer.playerId);

        // Enviar nome do jogador
        const playerName = document.getElementById('mp-player-name').value || multiplayer.playerName;
        sendMultiplayerMessage({
          type: 'set_name',
          name: playerName
        });
        break;

      case 'players_list':
        // Criar meshes para jogadores existentes
        data.players.forEach(playerData => {
          createOtherPlayer(playerData);
        });
        updatePlayerCount();
        break;

      case 'player_connect':
        if (data.playerId !== multiplayer.playerId) {
          addChatMessage('Sistema', `${data.playerName} entrou no jogo`, true);
          updatePlayerCount();
        }
        break;

      case 'player_disconnect':
        if (data.playerId !== multiplayer.playerId) {
          removeOtherPlayer(data.playerId);
          addChatMessage('Sistema', `${data.playerName} saiu do jogo`, true);
          updatePlayerCount();
        }
        break;

      case 'player_update':
        if (data.playerId !== multiplayer.playerId) {
          updateOtherPlayer(data);
        }
        break;

      case 'block_place':
        console.log('üì• Recebendo coloca√ß√£o de bloco:', data.blockType, 'em', data.x, data.y, data.z);
        if (data.playerId !== multiplayer.playerId) {
          // Sincronizar coloca√ß√£o de bloco
          setBlock(data.x, data.y, data.z, data.blockType);

          // Se for √°gua, criar mesh especial
          if (data.blockType === 'water' && waterSystem) {
            waterSystem.createWaterBlock(data.x, data.y, data.z);
          }

          const chunk = worldToChunk(data.x, data.z);
          const chunksToUpdate = new Set();
          chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

          // Atualizar chunks adjacentes
          const localX = ((data.x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
          const localZ = ((data.z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

          if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
          if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
          if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
          if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

          chunksToUpdate.forEach(key => {
            const [cx, cz] = key.split(',').map(Number);
            if (chunkMeshes[key]) {
              buildChunkMesh(cx, cz);
            }
          });
        }
        break;

      case 'block_break':
        console.log('üì• Recebendo quebra de bloco em:', data.x, data.y, data.z);
        if (data.playerId !== multiplayer.playerId) {
          // Sincronizar quebra de bloco
          const block = getBlock(data.x, data.y, data.z);

          // Remover √°gua se for bloco de √°gua
          if (block && block.type === 'water' && waterSystem) {
            waterSystem.removeWater(data.x, data.y, data.z);
          }

          removeBlockData(data.x, data.y, data.z);

          const chunk = worldToChunk(data.x, data.z);
          const chunksToUpdate = new Set();
          chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

          // Atualizar chunks adjacentes
          const localX = ((data.x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
          const localZ = ((data.z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

          if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
          if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
          if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
          if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

          chunksToUpdate.forEach(key => {
            const [cx, cz] = key.split(',').map(Number);
            if (chunkMeshes[key]) {
              buildChunkMesh(cx, cz);
            }
          });
        }
        break;

      case 'block_break':
        if (data.playerId !== multiplayer.playerId) {
          // Sincronizar quebra de bloco
          removeBlockData(data.x, data.y, data.z);
          const chunk = worldToChunk(data.x, data.z);
          buildChunkMesh(chunk.x, chunk.z);
        }
        break;

      case 'chat_message':
        addChatMessage(data.playerName, data.message, false);
        break;

      case 'player_rename':
        if (multiplayer.otherPlayers.has(data.playerId)) {
          multiplayer.otherPlayers.get(data.playerId).name = data.newName;
        }
        addChatMessage('Sistema', `${data.oldName} mudou o nome para ${data.newName}`, true);
        break;
    }
  }

  function createOtherPlayer(playerData) {
    if (multiplayer.otherPlayers.has(playerData.playerId)) return;

    // Criar mesh do jogador (similar ao PlayerCharacter mas simplificado)
    const group = new THREE.Group();

    // Corpo
    const bodyGeo = new THREE.BoxGeometry(0.6, 0.9, 0.3);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.5;
    group.add(body);

    // Cabe√ßa
    const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.2;
    group.add(head);

    // Bra√ßos
    const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
    const armMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });

    const leftArm = new THREE.Mesh(armGeo, armMat);
    leftArm.position.set(-0.4, 0.4, 0);
    group.add(leftArm);

    const rightArm = new THREE.Mesh(armGeo, armMat);
    rightArm.position.set(0.4, 0.4, 0);
    group.add(rightArm);

    // Pernas
    const legGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
    const legMat = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });

    const leftLeg = new THREE.Mesh(legGeo, legMat);
    leftLeg.position.set(-0.15, -0.4, 0);
    group.add(leftLeg);

    const rightLeg = new THREE.Mesh(legGeo, legMat);
    rightLeg.position.set(0.15, -0.4, 0);
    group.add(rightLeg);

    // Nome do jogador acima da cabe√ßa
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.fillRect(0, 0, 256, 64);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(playerData.name, 128, 42);

    const texture = new THREE.CanvasTexture(canvas);
    const spriteMat = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMat);
    sprite.scale.set(2, 0.5, 1);
    sprite.position.y = 2;
    group.add(sprite);

    // Posicionar
    group.position.set(
            playerData.position.x,
            playerData.position.y,
            playerData.position.z
    );

    scene.add(group);

    multiplayer.otherPlayers.set(playerData.playerId, {
      id: playerData.playerId,
      name: playerData.name,
      mesh: group,
      position: playerData.position,
      rotation: playerData.rotation
    });
  }

  function updateOtherPlayer(data) {
    if (!multiplayer.otherPlayers.has(data.playerId)) {
      createOtherPlayer({
        playerId: data.playerId,
        name: `Jogador_${data.playerId}`,
        position: data.position,
        rotation: data.rotation
      });
      return;
    }

    const player = multiplayer.otherPlayers.get(data.playerId);

    if (player.mesh) {
      // Interpola√ß√£o suave de posi√ß√£o
      player.mesh.position.lerp(
              new THREE.Vector3(data.position.x, data.position.y, data.position.z),
              0.3
      );

      // Rota√ß√£o
      if (data.rotation) {
        player.mesh.rotation.y = data.rotation.y;
      }
    }

    player.position = data.position;
    player.rotation = data.rotation;
  }

  function removeOtherPlayer(playerId) {
    if (multiplayer.otherPlayers.has(playerId)) {
      const player = multiplayer.otherPlayers.get(playerId);
      if (player.mesh) {
        scene.remove(player.mesh);
        player.mesh.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
      }
      multiplayer.otherPlayers.delete(playerId);
    }
  }

  function updatePlayerCount() {
    const count = multiplayer.otherPlayers.size;
    document.getElementById('mp-players-count').textContent = count;
  }

  // Sincronizar posi√ß√£o do jogador
  function syncPlayerPosition() {
    if (!multiplayer.connected) return;

    const now = Date.now();
    if (now - multiplayer.lastPositionSent < multiplayer.positionUpdateInterval) return;

    sendMultiplayerMessage({
      type: 'player_update',
      position: {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      },
      rotation: {
        x: mouse.x,
        y: mouse.y
      },
      health: playerHealth
    });

    multiplayer.lastPositionSent = now;
  }

  // Sistema de Chat
  function openChat() {
    const chat = document.getElementById('multiplayer-chat');
    chat.classList.add('open');
    document.getElementById('chat-input').focus();
  }

  function closeChat() {
    document.getElementById('multiplayer-chat').classList.remove('open');
    document.getElementById('chat-input').value = '';
  }

  function sendChatMessage(message) {
    if (!message || !message.trim()) return;

    if (multiplayer.connected) {
      sendMultiplayerMessage({
        type: 'chat_message',
        message: message.trim()
      });
    }

    document.getElementById('chat-input').value = '';
  }

  function addChatMessage(playerName, message, isSystem = false) {
    const chatMessages = document.getElementById('chat-messages');
    const msgDiv = document.createElement('div');
    msgDiv.className = isSystem ? 'chat-msg chat-system' : 'chat-msg chat-player';

    const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });

    if (isSystem) {
      msgDiv.innerHTML = `
      <span class="chat-time">${time}</span>
      <span class="chat-text-system">${message}</span>
    `;
    } else {
      msgDiv.innerHTML = `
      <span class="chat-time">${time}</span>
      <span class="chat-player">${playerName}:</span>
      <span class="chat-text">${message}</span>
    `;
    }

    chatMessages.appendChild(msgDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;

    // Limitar mensagens
    if (chatMessages.children.length > 50) {
      chatMessages.removeChild(chatMessages.firstChild);
    }
  }

  // Teclas do chat
  document.addEventListener('keydown', (e) => {
    if (e.code === 'KeyT' && multiplayer.connected && !document.getElementById('multiplayer-chat').classList.contains('open')) {
      e.preventDefault();
      openChat();
    }

    if (e.code === 'Escape' && document.getElementById('multiplayer-chat').classList.contains('open')) {
      closeChat();
    }
  });

  // Enter para enviar mensagem
  document.getElementById('chat-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      sendChatMessage(e.target.value);
    }
  });


  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 60, 120);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 25, 0);

    renderer = new THREE.WebGLRenderer({
      antialias: true,
      powerPreference: "high-performance",
      alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    raycaster = new THREE.Raycaster();
    raycaster.far = REACH;

    // Ilumina√ß√£o aprimorada
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(100, 100, 50);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 500;
    sun.shadow.camera.left = -100;
    sun.shadow.camera.right = 100;
    sun.shadow.camera.top = 100;
    sun.shadow.camera.bottom = -100;
    scene.add(sun);

    const ambient = new THREE.AmbientLight(0x404040, 0.9);
    scene.add(ambient);

    // Criar sistemas
    createSky();
    createClouds();
    waterSystem = new WaterSystem();
    particleSystem = new ParticleSystem();

    createMaterialsWithEmissive();
    // Inicializar invent√°rio
    initializeInventory();
    createHealthUI();
    createInventoryUI();
    createFullInventoryUI();
    setupEventListeners();


    addVolumetricLighting();

// Melhorar configura√ß√µes de ilumina√ß√£o do renderer
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;

  }


  function buildWatchTower(x, y, z) {
    // Base da torre (5x5)
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'cobblestone');
      }
    }

    // Paredes da torre (3x3 interna)
    for (let dy = 0; dy < 12; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          if (Math.abs(dx) === 2 || Math.abs(dz) === 2) {
            // Abertura para entrada
            if (dy === 0 && dx === 2 && dz === 0) {
              continue;
            }
            // Aberturas para janelas/amiras
            if (dy > 5 && dy < 10 && (dx === 2 || dz === 2)) {
              if (Math.random() > 0.7) {
                continue;
              }
            }
            setBlock(x + dx, y + dy, z + dz, 'cobblestone');
          }
        }
      }
    }

    // Escada interna em espiral
    const stairBlocks = [
      { x: 1, z: 1, yOffset: 0 },
      { x: 1, z: 0, yOffset: 1 },
      { x: 1, z: -1, yOffset: 2 },
      { x: 0, z: -1, yOffset: 3 },
      { x: -1, z: -1, yOffset: 4 },
      { x: -1, z: 0, yOffset: 5 },
      { x: -1, z: 1, yOffset: 6 },
      { x: 0, z: 1, yOffset: 7 }
    ];

    for (let level = 0; level < 10; level++) {
      const stair = stairBlocks[level % stairBlocks.length];
      setBlock(x + stair.x, y + level, z + stair.z, 'planks');

      // Remover bloco acima para passagem
      removeBlockData(x + stair.x, y + level + 1, z + stair.z);
    }

    // Topo da torre com ameias
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        if (Math.abs(dx) === 2 || Math.abs(dz) === 2) {
          setBlock(x + dx, y + 12, z + dz, 'cobblestone');
          // Ameias alternadas
          if ((dx + dz) % 2 === 0) {
            setBlock(x + dx, y + 13, z + dz, 'cobblestone');
          }
        }
      }
    }

    // Laje superior
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + dx, y + 12, z + dz, 'planks');
      }
    }

    // Tocha no topo
    setBlock(x, y + 14, z, 'torch');

    // Poste com lanterna na entrada
    setBlock(x + 3, y, z, 'planks');
    setBlock(x + 3, y + 1, z, 'planks');
    setBlock(x + 3, y + 2, z, 'lantern');

    // Bandeira decorativa (usando madeira e l√£)
    for (let dy = 0; dy < 4; dy++) {
      setBlock(x - 2, y + 8 + dy, z - 2, 'wood');
    }

    // Bandeira (bloco de l√£ vermelha)
    setBlock(x - 2, y + 12, z - 2, 'concrete_red');
    setBlock(x - 2, y + 12, z - 3, 'concrete_red');
    setBlock(x - 3, y + 12, z - 2, 'concrete_red');

    // Pequeno arsenal dentro da torre
    setBlock(x, y + 1, z, 'chest');
    setBlock(x, y + 2, z, 'planks'); // Prateleira
  }

  function buildDetailedFarm(x, y, z) {
    // Cerca externa expandida (16x16)
    for (let dx = -8; dx <= 8; dx++) {
      setBlock(x + dx, y, z - 8, 'planks');
      setBlock(x + dx, y + 1, z - 8, 'planks');
      setBlock(x + dx, y, z + 8, 'planks');
      setBlock(x + dx, y + 1, z + 8, 'planks');
    }
    for (let dz = -7; dz <= 7; dz++) {
      setBlock(x - 8, y, z + dz, 'planks');
      setBlock(x - 8, y + 1, z + dz, 'planks');
      setBlock(x + 8, y, z + dz, 'planks');
      setBlock(x + 8, y + 1, z + dz, 'planks');
    }

    // Port√£o de entrada
    removeBlockData(x, y, z + 8);
    removeBlockData(x, y + 1, z + 8);
    removeBlockData(x + 1, y, z + 8);
    removeBlockData(x + 1, y + 1, z + 8);

    // Campos cultivados com canais de irriga√ß√£o
    for (let section = 0; section < 2; section++) {
      const baseZ = section === 0 ? -6 : 2;

      for (let dx = -6; dx <= -1; dx++) {
        for (let dz = 0; dz < 4; dz++) {
          if (dx === -3 || dx === -4) {
            // Canal de √°gua
            setBlock(x + dx, y, z + baseZ + dz, 'glass'); // √Ågua
          } else {
            // Terra cultivada
            setBlock(x + dx, y, z + baseZ + dz, 'dirt');

            // Plantas em diferentes est√°gios
            if (Math.random() > 0.3) {
              const plants = ['leaves', 'mushroom_brown', 'pumpkin'];
              setBlock(x + dx, y + 1, z + baseZ + dz,
                      plants[Math.floor(Math.random() * plants.length)]);
            }
          }
        }
      }
    }

    // Campo de mel√µes
    for (let dx = 1; dx <= 6; dx++) {
      for (let dz = -6; dz <= -2; dz++) {
        setBlock(x + dx, y, z + dz, 'dirt');
        if ((dx + dz) % 2 === 0) {
          setBlock(x + dx, y + 1, z + dz, 'melon');
        }
      }
    }

    // Pomar (√°rvores frut√≠feras)
    const treesPos = [
      { dx: 4, dz: 2 }, { dx: 6, dz: 4 }, { dx: 2, dz: 5 }
    ];

    treesPos.forEach(pos => {
      // Tronco
      for (let dy = 1; dy <= 3; dy++) {
        setBlock(x + pos.dx, y + dy, z + pos.dz, 'wood');
      }
      // Copa
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          setBlock(x + pos.dx + dx, y + 4, z + pos.dz + dz, 'leaves');
          if (Math.random() > 0.5) {
            setBlock(x + pos.dx + dx, y + 3, z + pos.dz + dz, 'leaves');
          }
        }
      }
      // "Frutas" (manchas vermelhas nas folhas)
      if (Math.random() > 0.5) {
        setBlock(x + pos.dx + 1, y + 4, z + pos.dz, 'mushroom_red');
      }
    });

    // Celeiro grande (8x6)
    const barnX = x - 10;
    const barnZ = z;

    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(barnX + dx, y - 1, barnZ + dz, 'planks');
      }
    }

    // Paredes do celeiro
    for (let dy = 0; dy < 5; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        for (let dz = -3; dz <= 3; dz++) {
          if (Math.abs(dx) === 4 || Math.abs(dz) === 3) {
            if (dy <= 2 && dx >= -1 && dx <= 1 && dz === 3) {
              continue; // Porta grande
            }
            setBlock(barnX + dx, y + dy, barnZ + dz, 'planks');
          }
        }
      }
    }

    // Telhado do celeiro
    for (let dy = 0; dy < 3; dy++) {
      const width = 4 - dy;
      for (let dx = -width; dx <= width; dx++) {
        for (let dz = -3; dz <= 3; dz++) {
          setBlock(barnX + dx, y + 5 + dy, barnZ + dz, 'brick');
        }
      }
    }

    // Janela do celeiro (s√≥t√£o)
    setBlock(barnX, y + 6, barnZ + 3, 'glass');

    // Interior do celeiro - Baias
    setBlock(barnX - 3, y + 1, barnZ - 2, 'planks');
    setBlock(barnX - 3, y + 1, barnZ, 'planks');
    setBlock(barnX - 3, y + 1, barnZ + 2, 'planks');

    // Armazenamento (ba√∫s e barris)
    setBlock(barnX + 3, y + 1, barnZ - 2, 'chest');
    setBlock(barnX + 3, y + 1, barnZ - 1, 'chest');
    setBlock(barnX + 3, y + 1, barnZ, 'chest');

    // Ferramentas na parede
    setBlock(barnX + 3, y + 2, barnZ + 2, 'planks');

    // Moinho de vento decorativo
    const millX = x + 12;
    const millZ = z;

    // Base do moinho (torre)
    for (let dy = 0; dy < 8; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
            setBlock(millX + dx, y + dy, millZ + dz, 'cobblestone');
          }
        }
      }
    }

    // Topo do moinho
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(millX + dx, y + 8, millZ + dz, 'brick');
      }
    }

    // P√°s do moinho (simplificadas)
    // Horizontal
    for (let dx = -3; dx <= 3; dx++) {
      setBlock(millX + dx, y + 5, millZ, 'planks');
    }
    // Vertical
    for (let dz = -3; dz <= 3; dz++) {
      setBlock(millX, y + 5 + dz - 3, millZ, 'planks');
    }

    // Janelas do moinho
    setBlock(millX + 1, y + 3, millZ + 1, 'glass');
    setBlock(millX - 1, y + 6, millZ - 1, 'glass');

    // Ilumina√ß√£o
    setBlock(x, y, z, 'planks');
    setBlock(x, y + 1, z, 'planks');
    setBlock(x, y + 2, z, 'lantern');

    setBlock(barnX, y, barnZ + 4, 'planks');
    setBlock(barnX, y + 1, barnZ + 4, 'planks');
    setBlock(barnX, y + 2, barnZ + 4, 'lantern');
  }

  // ADICIONAR esta fun√ß√£o tamb√©m
  function buildGrandLibrary(x, y, z) {
    // Base expandida (11x11)
    for (let dx = -5; dx <= 5; dx++) {
      for (let dz = -5; dz <= 5; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'planks');
      }
    }

    // Paredes principais
    for (let dy = 0; dy < 7; dy++) {
      for (let dx = -5; dx <= 5; dx++) {
        for (let dz = -5; dz <= 5; dz++) {
          if (Math.abs(dx) === 5 || Math.abs(dz) === 5) {
            // Porta dupla
            if (dy <= 2 && dx >= -1 && dx <= 1 && dz === 5) {
              continue;
            }
            setBlock(x + dx, y + dy, z + dz, 'planks');
          }
        }
      }
    }

    // Segundo andar
    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -4; dz <= 4; dz++) {
        setBlock(x + dx, y + 7, z + dz, 'planks');
      }
    }

    // Paredes segundo andar
    for (let dy = 8; dy < 14; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        for (let dz = -4; dz <= 4; dz++) {
          if (Math.abs(dx) === 4 || Math.abs(dz) === 4) {
            setBlock(x + dx, y + dy, z + dz, 'planks');
          }
        }
      }
    }

    // Janelas primeiro andar
    const firstFloorWindows = [
      { dx: -5, dz: -3 }, { dx: -5, dz: 0 }, { dx: -5, dz: 3 },
      { dx: 5, dz: -3 }, { dx: 5, dz: 0 }, { dx: 5, dz: 3 },
      { dx: -3, dz: -5 }, { dx: 0, dz: -5 }, { dx: 3, dz: -5 }
    ];

    firstFloorWindows.forEach(pos => {
      setBlock(x + pos.dx, y + 3, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 4, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 5, z + pos.dz, 'glass');
    });

    // Janelas segundo andar
    const secondFloorWindows = [
      { dx: -4, dz: -2 }, { dx: -4, dz: 2 },
      { dx: 4, dz: -2 }, { dx: 4, dz: 2 },
      { dx: -2, dz: -4 }, { dx: 2, dz: -4 }
    ];

    secondFloorWindows.forEach(pos => {
      setBlock(x + pos.dx, y + 10, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 11, z + pos.dz, 'glass');
    });

    // Estantes ao longo das paredes - Primeiro andar
    const shelfPositions1F = [];
    for (let dz = -4; dz <= 4; dz += 2) {
      shelfPositions1F.push({ dx: -4, dz: dz });
      shelfPositions1F.push({ dx: 4, dz: dz });
    }
    for (let dx = -4; dx <= 4; dx += 2) {
      if (Math.abs(dx) !== 4) {
        shelfPositions1F.push({ dx: dx, dz: -4 });
      }
    }

    shelfPositions1F.forEach(pos => {
      for (let dy = 1; dy <= 5; dy++) {
        setBlock(x + pos.dx, y + dy, z + pos.dz, 'bookshelf');
      }
    });

    // Estantes segundo andar
    const shelfPositions2F = [];
    for (let dz = -3; dz <= 3; dz += 2) {
      shelfPositions2F.push({ dx: -3, dz: dz });
      shelfPositions2F.push({ dx: 3, dz: dz });
    }
    for (let dx = -3; dx <= 3; dx += 2) {
      shelfPositions2F.push({ dx: dx, dz: -3 });
      shelfPositions2F.push({ dx: dx, dz: 3 });
    }

    shelfPositions2F.forEach(pos => {
      for (let dy = 8; dy <= 12; dy++) {
        setBlock(x + pos.dx, y + dy, z + pos.dz, 'bookshelf');
      }
    });

    // Mesa de leitura central - Primeiro andar
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + dx, y + 1, z + dz, 'planks');
      }
    }

    // Cadeiras ao redor da mesa
    setBlock(x - 2, y + 1, z, 'planks');
    setBlock(x + 2, y + 1, z, 'planks');
    setBlock(x, y + 1, z - 2, 'planks');
    setBlock(x, y + 1, z + 2, 'planks');

    // Mesa de trabalho e ba√∫
    setBlock(x + 3, y + 1, z + 3, 'crafting_table');
    setBlock(x + 3, y + 1, z + 4, 'chest');

    // Escada para o segundo andar
    for (let dy = 0; dy < 7; dy++) {
      setBlock(x + 4, y + dy, z - 4, 'planks');
      setBlock(x + 4, y + dy, z - 3, 'planks');
    }

    // Mesa de estudos segundo andar
    for (let dx = -1; dx <= 1; dx++) {
      setBlock(x + dx, y + 8, z, 'planks');
    }

    // Globo decorativo
    setBlock(x - 2, y + 8, z - 2, 'planks');
    setBlock(x - 2, y + 9, z - 2, 'gold_ore');

    // Telhado em camadas
    for (let dy = 0; dy < 4; dy++) {
      const size = 5 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -size; dz <= size; dz++) {
          setBlock(x + dx, y + 14 + dy, z + dz, 'brick');
        }
      }
    }

    // Torre de observa√ß√£o/estudo no topo
    for (let dy = 0; dy < 5; dy++) {
      setBlock(x, y + 18 + dy, z, 'planks');
      setBlock(x + 1, y + 18 + dy, z, 'planks');
      setBlock(x - 1, y + 18 + dy, z, 'planks');
      setBlock(x, y + 18 + dy, z + 1, 'planks');
      setBlock(x, y + 18 + dy, z - 1, 'planks');
    }

    // Janelas da torre
    setBlock(x + 1, y + 21, z, 'glass');
    setBlock(x - 1, y + 21, z, 'glass');
    setBlock(x, y + 21, z + 1, 'glass');
    setBlock(x, y + 21, z - 1, 'glass');

    // Topo da torre com lanterna
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + dx, y + 23, z + dz, 'brick');
      }
    }
    setBlock(x, y + 24, z, 'glowstone');

    // Ilumina√ß√£o interna - Candelabros
    const lightPos = [
      { dx: -3, dz: -3 }, { dx: 3, dz: -3 },
      { dx: -3, dz: 3 }, { dx: 3, dz: 3 }
    ];

    lightPos.forEach(pos => {
      // Primeiro andar
      setBlock(x + pos.dx, y + 1, z + pos.dz, 'planks');
      setBlock(x + pos.dx, y + 2, z + pos.dz, 'planks');
      setBlock(x + pos.dx, y + 3, z + pos.dz, 'lantern');

      // Segundo andar
      setBlock(x + pos.dx, y + 8, z + pos.dz, 'planks');
      setBlock(x + pos.dx, y + 9, z + pos.dz, 'planks');
      setBlock(x + pos.dx, y + 10, z + pos.dz, 'lantern');
    });

    // Entrada decorativa com colunas
    setBlock(x - 2, y, z + 6, 'quartz');
    setBlock(x - 2, y + 1, z + 6, 'quartz');
    setBlock(x - 2, y + 2, z + 6, 'quartz');
    setBlock(x - 2, y + 3, z + 6, 'lantern');

    setBlock(x + 2, y, z + 6, 'quartz');
    setBlock(x + 2, y + 1, z + 6, 'quartz');
    setBlock(x + 2, y + 2, z + 6, 'quartz');
    setBlock(x + 2, y + 3, z + 6, 'lantern');

    // Placa decorativa
    for (let dx = -3; dx <= 3; dx++) {
      setBlock(x + dx, y + 5, z + 5, 'planks');
    }

    // Jardim de leitura ao ar livre
    for (let dx = -7; dx <= -6; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        setBlock(x + dx, y, z + dz, 'grass');
        if (Math.random() > 0.6) {
          setBlock(x + dx, y + 1, z + dz, 'mushroom_red');
        }
      }
    }

    // Bancos no jardim
    setBlock(x - 6, y + 1, z - 1, 'planks');
    setBlock(x - 6, y + 1, z, 'planks');
    setBlock(x - 6, y + 1, z + 1, 'planks');
  }

  function generateChunk(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);
    if (chunks[chunkKey]) return;

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    for (let x = sx; x < sx + CHUNK_SIZE; x++) {
      for (let z = sz; z < sz + CHUNK_SIZE; z++) {
        const height = getHeight(x, z);

        // Bedrock na base
        setBlock(x, 0, z, 'bedrock');

        // Camadas subterr√¢neas
        const stoneHeight = height - 4;
        for (let y = 1; y < stoneHeight; y++) {
          setBlock(x, y, z, 'stone');
        }

        for (let y = stoneHeight; y < height - 1; y++) {
          setBlock(x, y, z, 'dirt');
        }

        setBlock(x, height - 1, z, 'dirt');
        setBlock(x, height, z, 'grass');

        // Adicionar √°rvores
        if (Math.random() > 0.98 && height < 40) {
          generateTree(x, height + 1, z);
        }

        // Adicionar √°gua em vales
        if (height < 10 && Math.random() > 0.7) {
          for (let y = height + 1; y <= 10; y++) {
            setBlock(x, y, z, 'water');
            waterSystem.createWaterBlock(x, y, z);
          }
        }

        // Flores e vegeta√ß√£o
        if (Math.random() > 0.95 && height < 40) {
          setBlock(x, height + 1, z, 'leaves');
        }
      }
    }

    chunks[chunkKey] = true;
  }

  function generateTree(x, y, z) {
    const treeHeight = Math.floor(Math.random() * 4) + 4;

    // Tronco
    for (let i = 0; i < treeHeight; i++) {
      setBlock(x, y + i, z, 'wood');
    }

    // Copa
    const topY = y + treeHeight - 1;
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 3) {
            setBlock(x + dx, topY + dy, z + dz, 'leaves');
          }
        }
      }
    }
  }

  function removeBlock(x, y, z) {
    const block = getBlock(x, y, z);
    if (!block || block.type === 'bedrock') return;

    // Criar part√≠culas do bloco quebrado
    if (particleSystem) {
      const color = blockTypes[block.type] ? blockTypes[block.type].color : 0xFFFFFF;
      particleSystem.emit(
              new THREE.Vector3(x, y, z),
              color,
              15,
              0.2
      );
    }

    // Remover √°gua se for bloco de √°gua
    if (block.type === 'water') {
      waterSystem.removeWater(x, y, z);
    }

    addToInventory(block.type, 1);
    removeBlockData(x, y, z);

    // Reconstruir chunks
    const chunk = worldToChunk(x, z);
    const chunksToUpdate = new Set();
    chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

    const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

    if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
    if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
    if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
    if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

    chunksToUpdate.forEach(key => {
      const [cx, cz] = key.split(',').map(Number);
      if (chunkMeshes[key]) {
        buildChunkMesh(cx, cz);
      }
    });

    updateFaceCount();
  }

  function placeBlock(x, y, z, type) {
    if (getBlock(x, y, z)) return;

    // Verificar se o bloco est√° dentro do jogador
    const playerBox = new THREE.Box3(
            new THREE.Vector3(
                    camera.position.x - PLAYER_WIDTH/2,
                    camera.position.y - PLAYER_HEIGHT/2,
                    camera.position.z - PLAYER_WIDTH/2
            ),
            new THREE.Vector3(
                    camera.position.x + PLAYER_WIDTH/2,
                    camera.position.y + PLAYER_HEIGHT/2,
                    camera.position.z + PLAYER_WIDTH/2
            )
    );

    const blockBox = new THREE.Box3(
            new THREE.Vector3(x - 0.5, y - 0.5, z - 0.5),
            new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5)
    );

    if (playerBox.intersectsBox(blockBox)) return;

    // Verificar se tem o item no invent√°rio
    const selectedItem = getSelectedItem();
    if (selectedItem === type && removeFromInventory(player.selectedSlot, 1)) {
      setBlock(x, y, z, type);

      // ‚ú® ILUMINA√á√ÉO: Adicionar luz se o bloco for emissivo
      if (blockTypes[type] && blockTypes[type].emissive) {
        addBlockLight(x, y, z, type);
      }

      // Se for √°gua, criar mesh especial
      if (type === 'water') {
        waterSystem.createWaterBlock(x, y, z);
        // Adicionar ilumina√ß√£o suave para √°gua
        addWaterLighting(x, y, z);
      }

      // ‚úÖ SINCRONIZAR MULTIPLAYER
      if (multiplayer.connected) {
        console.log('üì§ Sincronizando coloca√ß√£o de bloco:', type, 'em', x, y, z);
        sendMultiplayerMessage({
          type: 'block_place',
          x: Math.floor(x),
          y: Math.floor(y),
          z: Math.floor(z),
          blockType: type
        });
      }

      // Reconstruir chunks afetados
      const chunk = worldToChunk(x, z);
      const chunksToUpdate = new Set();
      chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

      const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
      const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

      if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
      if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
      if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
      if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

      chunksToUpdate.forEach(key => {
        const [cx, cz] = key.split(',').map(Number);
        if (chunkMeshes[key]) {
          buildChunkMesh(cx, cz);
        }
      });

      updateFaceCount();
    }
  }
  function buildImprovedChurch(x, y, z) {
    // Base maior e mais elaborada (9x14)
    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -7; dz <= 7; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'cobblestone');
      }
    }

    // Escadaria na entrada
    for (let dx = -2; dx <= 2; dx++) {
      setBlock(x + dx, y, z + 8, 'cobblestone');
      setBlock(x + dx, y + 1, z + 9, 'cobblestone');
    }

    // Paredes principais
    for (let dy = 0; dy < 8; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        for (let dz = -7; dz <= 7; dz++) {
          if (Math.abs(dx) === 4 || Math.abs(dz) === 7) {
            // Porta principal (dupla e alta)
            if (dy <= 3 && dx >= -1 && dx <= 1 && dz === 7) {
              continue;
            }
            setBlock(x + dx, y + dy, z + dz, 'quartz');
          }
        }
      }
    }

    // Pilares decorativos nas laterais
    const pillarPositions = [
      { dx: -4, dz: -5 }, { dx: -4, dz: 0 }, { dx: -4, dz: 5 },
      { dx: 4, dz: -5 }, { dx: 4, dz: 0 }, { dx: 4, dz: 5 }
    ];

    pillarPositions.forEach(pos => {
      for (let dy = 0; dy < 8; dy++) {
        setBlock(x + pos.dx, y + dy, z + pos.dz, 'quartz');

        // Detalhe do pilar
        if (dy % 2 === 0) {
          if (pos.dx === -4) {
            setBlock(x + pos.dx - 1, y + dy, z + pos.dz, 'cobblestone');
          } else {
            setBlock(x + pos.dx + 1, y + dy, z + pos.dz, 'cobblestone');
          }
        }
      }
      // Topo do pilar
      setBlock(x + pos.dx, y + 8, z + pos.dz, 'cobblestone');
    });

    // Janelas laterais em arco (vitrais)
    const windowPositions = [
      { dx: -4, dz: -3 }, { dx: -4, dz: 3 },
      { dx: 4, dz: -3 }, { dx: 4, dz: 3 }
    ];

    windowPositions.forEach(pos => {
      // Janela em arco (3 blocos de altura)
      setBlock(x + pos.dx, y + 3, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 4, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 5, z + pos.dz, 'glass');

      // Moldura da janela
      setBlock(x + pos.dx, y + 2, z + pos.dz, 'cobblestone');
      setBlock(x + pos.dx, y + 6, z + pos.dz, 'cobblestone');
    });

    // Janela grande frontal (ros√°cea)
    for (let dx = -2; dx <= 2; dx++) {
      for (let dy = 5; dy <= 7; dy++) {
        if (Math.abs(dx) <= 2 && dy >= 5) {
          setBlock(x + dx, y + dy, z + 7, 'glass');
        }
      }
    }
    // Moldura da ros√°cea
    for (let dx = -3; dx <= 3; dx++) {
      setBlock(x + dx, y + 4, z + 7, 'cobblestone');
      setBlock(x + dx, y + 8, z + 7, 'cobblestone');
    }

    // Torre do sino (central, mais alta e detalhada)
    for (let dy = 0; dy < 15; dy++) {
      // Base da torre (3x3)
      if (dy < 8) {
        for (let dx = -1; dx <= 1; dx++) {
          for (let dz = -1; dz <= 1; dz++) {
            if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
              setBlock(x + dx, y + 8 + dy, z + dz, 'quartz');
            }
          }
        }
      } else {
        // Torre estreita no topo
        setBlock(x, y + 8 + dy, z, 'quartz');
        setBlock(x + 1, y + 8 + dy, z, 'quartz');
        setBlock(x - 1, y + 8 + dy, z, 'quartz');
        setBlock(x, y + 8 + dy, z + 1, 'quartz');
        setBlock(x, y + 8 + dy, z - 1, 'quartz');
      }
    }

    // Sino (vis√≠vel)
    setBlock(x, y + 18, z, 'gold_ore'); // Sino dourado

    // Aberturas da torre do sino
    setBlock(x + 1, y + 17, z, 'glass');
    setBlock(x - 1, y + 17, z, 'glass');
    setBlock(x, y + 17, z + 1, 'glass');
    setBlock(x, y + 17, z - 1, 'glass');

    // Cruz no topo da torre
    for (let dy = 0; dy < 3; dy++) {
      setBlock(x, y + 23 + dy, z, 'gold_ore');
    }
    setBlock(x - 1, y + 24, z, 'gold_ore');
    setBlock(x + 1, y + 24, z, 'gold_ore');

    // Topo da cruz brilhante
    setBlock(x, y + 26, z, 'glowstone');

    // Telhado principal (em V invertido)
    for (let dy = 0; dy < 5; dy++) {
      const width = 4 - dy;
      for (let dx = -width; dx <= width; dx++) {
        for (let dz = -7; dz <= 7; dz++) {
          setBlock(x + dx, y + 8 + dy, z + dz, 'brick');
        }
      }
    }

    // Detalhes do telhado (beirais)
    for (let dz = -7; dz <= 7; dz++) {
      setBlock(x - 5, y + 8, z + dz, 'cobblestone');
      setBlock(x + 5, y + 8, z + dz, 'cobblestone');
    }

    // Interior - Nave central
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -6; dz <= 6; dz++) {
        // Piso de pedra decorativo
        if ((dx + dz) % 2 === 0) {
          setBlock(x + dx, y, z + dz, 'quartz');
        } else {
          setBlock(x + dx, y, z + dz, 'cobblestone');
        }
      }
    }

    // Altar
    for (let dx = -2; dx <= 2; dx++) {
      setBlock(x + dx, y + 1, z - 6, 'quartz');
    }
    for (let dx = -1; dx <= 1; dx++) {
      setBlock(x + dx, y + 2, z - 6, 'quartz');
    }
    setBlock(x, y + 3, z - 6, 'gold_ore'); // Cruz dourada no altar

    // Bancos (fileiras)
    for (let row = -4; row <= 2; row += 2) {
      // Banco esquerdo
      for (let dz = 0; dz < 3; dz++) {
        setBlock(x - 2, y + 1, z + row + dz, 'planks');
      }
      // Banco direito
      for (let dz = 0; dz < 3; dz++) {
        setBlock(x + 2, y + 1, z + row + dz, 'planks');
      }
    }

    // Candelabros (lanternas suspensas)
    const chandPos = [
      { dz: -4 }, { dz: 0 }, { dz: 4 }
    ];

    chandPos.forEach(pos => {
      // Corrente
      for (let dy = 1; dy <= 4; dy++) {
        setBlock(x, y + dy + 3, z + pos.dz, 'planks');
      }
      // Lanterna
      setBlock(x, y + 3, z + pos.dz, 'lantern');
      setBlock(x + 1, y + 3, z + pos.dz, 'lantern');
      setBlock(x - 1, y + 3, z + pos.dz, 'lantern');
    });

    // Tochas nas paredes
    setBlock(x - 3, y + 3, z - 5, 'torch');
    setBlock(x + 3, y + 3, z - 5, 'torch');
    setBlock(x - 3, y + 3, z, 'torch');
    setBlock(x + 3, y + 3, z, 'torch');
    setBlock(x - 3, y + 3, z + 5, 'torch');
    setBlock(x + 3, y + 3, z + 5, 'torch');

    // √ìrg√£o de tubos (decorativo na parede dos fundos)
    for (let dx = -2; dx <= 2; dx++) {
      for (let dy = 2; dy <= 6; dy++) {
        if (Math.abs(dx) === 2 || dy >= 5) {
          setBlock(x + dx, y + dy, z - 7, 'planks');
        }
      }
    }

    // Jardim lateral direito
    for (let dx = 5; dx <= 7; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(x + dx, y, z + dz, 'grass');
        if (Math.random() > 0.7) {
          setBlock(x + dx, y + 1, z + dz, 'leaves');
        }
      }
    }

    // Jardim lateral esquerdo
    for (let dx = -7; dx <= -5; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(x + dx, y, z + dz, 'grass');
        if (Math.random() > 0.7) {
          setBlock(x + dx, y + 1, z + dz, 'leaves');
        }
      }
    }

    // √Årvores decorativas ao lado
    const treePosLeft = { dx: -6, dz: 0 };
    for (let dy = 1; dy <= 4; dy++) {
      setBlock(x + treePosLeft.dx, y + dy, z + treePosLeft.dz, 'wood');
    }
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + treePosLeft.dx + dx, y + 5, z + treePosLeft.dz + dz, 'leaves');
      }
    }

    const treePosRight = { dx: 6, dz: 0 };
    for (let dy = 1; dy <= 4; dy++) {
      setBlock(x + treePosRight.dx, y + dy, z + treePosRight.dz, 'wood');
    }
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + treePosRight.dx + dx, y + 5, z + treePosRight.dz + dz, 'leaves');
      }
    }

    // Cerca decorativa ao redor do jardim
    for (let dx = -8; dx <= 8; dx++) {
      if (Math.abs(dx) >= 5) {
        setBlock(x + dx, y, z - 4, 'planks');
        setBlock(x + dx, y, z + 4, 'planks');
      }
    }

    // Lanternas de ilumina√ß√£o externa
    setBlock(x - 5, y, z + 8, 'planks');
    setBlock(x - 5, y + 1, z + 8, 'planks');
    setBlock(x - 5, y + 2, z + 8, 'lantern');

    setBlock(x + 5, y, z + 8, 'planks');
    setBlock(x + 5, y + 1, z + 8, 'planks');
    setBlock(x + 5, y + 2, z + 8, 'lantern');

    // Lanternas na torre
    setBlock(x - 2, y + 15, z - 2, 'lantern');
    setBlock(x + 2, y + 15, z - 2, 'lantern');
    setBlock(x - 2, y + 15, z + 2, 'lantern');
    setBlock(x + 2, y + 15, z + 2, 'lantern');
  }

  function generateVillage(centerX, centerZ) {
    const villageY = getHeight(centerX, centerZ) + 1;

    // Limpar e nivelar √°rea maior
    for (let x = -35; x <= 35; x++) {
      for (let z = -35; z <= 35; z++) {
        const wx = centerX + x;
        const wz = centerZ + z;
        const wy = getHeight(wx, wz);

        for (let y = wy; y < villageY; y++) {
          setBlock(wx, y, wz, 'dirt');
        }
        setBlock(wx, villageY, wz, 'grass');

        for (let y = villageY + 1; y < villageY + 20; y++) {
          removeBlockData(wx, y, wz);
        }
      }
    }

    // Cerca ao redor da vila
    buildVillageFence(centerX, villageY, centerZ, 32);

    // Caminhos principais
    createDetailedPaths(centerX, villageY, centerZ);

    // Pra√ßa central com fonte
    buildCentralFountain(centerX, villageY + 1, centerZ);

    // Jardins ao redor da fonte
    buildGardens(centerX, villageY, centerZ);

    // Constru√ß√µes residenciais e comerciais
    const buildings = [
      // Casas grandes
      { x: 0, z: 18, type: 'large_house', profession: 'farmer' },
      { x: 18, z: 0, type: 'large_house', profession: 'librarian' },
      { x: -18, z: 0, type: 'large_house', profession: 'blacksmith' },
      { x: 0, z: -18, type: 'large_house', profession: 'priest' },

      // Casas m√©dias
      { x: 12, z: 12, type: 'house', profession: 'butcher' },
      { x: -12, z: -12, type: 'house', profession: 'fisherman' },
      { x: -12, z: 12, type: 'house', profession: 'shepherd' },
      { x: 12, z: -12, type: 'house', profession: 'fletcher' },

      // Constru√ß√µes especiais
      { x: -15, z: 15, type: 'church' },
      { x: 22, z: -12, type: 'farm' },
      { x: -22, z: -12, type: 'tower' },
      { x: 15, z: -20, type: 'library' },
      { x: -25, z: 5, type: 'market' },
      { x: 25, z: 5, type: 'inn' },
      { x: 5, z: 25, type: 'stable' }
    ];

    buildings.forEach(building => {
      const bx = centerX + building.x;
      const bz = centerZ + building.z;

      switch(building.type) {
        case 'large_house':
          buildLargeHouse(bx, villageY + 1, bz);
          if (building.profession) {
            const villager = new Villager(bx, villageY + 2, bz, building.profession);
            villagers.push(villager);
          }
          break;
        case 'house':
          buildDecoratedHouse(bx, villageY + 1, bz);
          if (building.profession) {
            const villager = new Villager(bx, villageY + 2, bz, building.profession);
            villagers.push(villager);
          }
          break;
        case 'church':
          buildImprovedChurch(bx, villageY + 1, bz);
          break;
        case 'farm':
          buildDetailedFarm(bx, villageY + 1, bz);
          break;
        case 'tower':
          buildWatchTower(bx, villageY + 1, bz);
          break;
        case 'library':
          buildGrandLibrary(bx, villageY + 1, bz);
          break;
        case 'market':
          buildMarketplace(bx, villageY + 1, bz);
          break;
        case 'inn':
          buildInn(bx, villageY + 1, bz);
          break;
        case 'stable':
          buildStable(bx, villageY + 1, bz);
          break;
      }
    });

    // Adicionar vegeta√ß√£o decorativa
    addVillageDecoration(centerX, villageY, centerZ);

    villages.push({ x: centerX, z: centerZ });
  }


  function buildVillageFence(x, y, z, radius) {
    for (let angle = 0; angle < 360; angle += 10) {
      const rad = angle * Math.PI / 180;
      const fx = Math.floor(x + Math.cos(rad) * radius);
      const fz = Math.floor(z + Math.sin(rad) * radius);

      setBlock(fx, y, fz, 'planks');
      setBlock(fx, y + 1, fz, 'planks');

      // Postes a cada 45 graus
      if (angle % 45 === 0) {
        setBlock(fx, y + 2, fz, 'planks');
        setBlock(fx, y + 3, fz, 'torch');
      }
    }
  }

  function createDetailedPaths(centerX, villageY, centerZ) {
    // Caminhos principais em cruz
    for (let i = -30; i <= 30; i++) {
      // Horizontal
      setBlock(centerX + i, villageY, centerZ, 'cobblestone');
      setBlock(centerX + i, villageY, centerZ + 1, 'cobblestone');
      setBlock(centerX + i, villageY, centerZ - 1, 'cobblestone');

      // Bordas decorativas
      if (Math.abs(i) % 3 === 0) {
        setBlock(centerX + i, villageY, centerZ + 2, 'stone');
        setBlock(centerX + i, villageY, centerZ - 2, 'stone');
      }

      // Vertical
      setBlock(centerX, villageY, centerZ + i, 'cobblestone');
      setBlock(centerX + 1, villageY, centerZ + i, 'cobblestone');
      setBlock(centerX - 1, villageY, centerZ + i, 'cobblestone');

      if (Math.abs(i) % 3 === 0) {
        setBlock(centerX + 2, villageY, centerZ + i, 'stone');
        setBlock(centerX - 2, villageY, centerZ + i, 'stone');
      }
    }

    // Lanternas ao longo dos caminhos
    for (let i = -28; i <= 28; i += 7) {
      setBlock(centerX + i, villageY + 1, centerZ + 4, 'planks');
      setBlock(centerX + i, villageY + 2, centerZ + 4, 'lantern');

      setBlock(centerX + i, villageY + 1, centerZ - 4, 'planks');
      setBlock(centerX + i, villageY + 2, centerZ - 4, 'lantern');

      setBlock(centerX + 4, villageY + 1, centerZ + i, 'planks');
      setBlock(centerX + 4, villageY + 2, centerZ + i, 'lantern');

      setBlock(centerX - 4, villageY + 1, centerZ + i, 'planks');
      setBlock(centerX - 4, villageY + 2, centerZ + i, 'lantern');
    }
  }

  function buildCentralFountain(x, y, z) {
    // Base da fonte (mais elaborada)
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist <= 3) {
          setBlock(x + dx, y - 1, z + dz, 'cobblestone');
        }
      }
    }

    // Borda externa
    for (let angle = 0; angle < 360; angle += 45) {
      const rad = angle * Math.PI / 180;
      const fx = Math.floor(x + Math.cos(rad) * 3);
      const fz = Math.floor(z + Math.sin(rad) * 3);
      setBlock(fx, y, fz, 'stone');
      setBlock(fx, y + 1, fz, 'stone');
    }

    // Borda interna com √°gua
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist <= 2 && (Math.abs(dx) === 2 || Math.abs(dz) === 2)) {
          setBlock(x + dx, y, z + dz, 'quartz');
          setBlock(x + dx, y + 1, z + dz, 'quartz');
        } else if (dist < 2) {
          setBlock(x + dx, y, z + dz, 'glass'); // √Ågua
        }
      }
    }

    // Coluna central
    for (let dy = 0; dy < 4; dy++) {
      setBlock(x, y + dy, z, 'quartz');
    }

    // Topo decorativo
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        if (dx !== 0 || dz !== 0) {
          setBlock(x + dx, y + 4, z + dz, 'glowstone');
        }
      }
    }
    setBlock(x, y + 5, z, 'glowstone');

    // Jatos de √°gua decorativos
    for (let angle = 0; angle < 360; angle += 90) {
      const rad = angle * Math.PI / 180;
      const wx = Math.floor(x + Math.cos(rad) * 1.5);
      const wz = Math.floor(z + Math.sin(rad) * 1.5);
      setBlock(wx, y + 2, wz, 'glass');
      setBlock(wx, y + 3, wz, 'glass');
    }
  }

  function buildGardens(centerX, villageY, centerZ) {
    const gardenPositions = [
      { x: 7, z: 7 }, { x: -7, z: 7 },
      { x: 7, z: -7 }, { x: -7, z: -7 }
    ];

    gardenPositions.forEach(pos => {
      const gx = centerX + pos.x;
      const gz = centerZ + pos.z;

      // Canteiro
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          setBlock(gx + dx, villageY, gz + dz, 'dirt');

          // Flores e plantas
          if (Math.random() > 0.6) {
            const plants = ['leaves', 'mushroom_red', 'mushroom_brown'];
            setBlock(gx + dx, villageY + 1, gz + dz, plants[Math.floor(Math.random() * plants.length)]);
          }
        }
      }

      // Cerca ao redor
      for (let dx = -3; dx <= 3; dx++) {
        setBlock(gx + dx, villageY, gz - 3, 'planks');
        setBlock(gx + dx, villageY, gz + 3, 'planks');
      }
      for (let dz = -2; dz <= 2; dz++) {
        setBlock(gx - 3, villageY, gz + dz, 'planks');
        setBlock(gx + 3, villageY, gz + dz, 'planks');
      }

      // √Årvore decorativa
      setBlock(gx, villageY, gz, 'dirt');
      for (let dy = 1; dy <= 3; dy++) {
        setBlock(gx, villageY + dy, gz, 'wood');
      }
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          setBlock(gx + dx, villageY + 4, gz + dz, 'leaves');
        }
      }
    });
  }

  function buildLargeHouse(x, y, z) {
    // Base maior (7x7)
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'planks');
      }
    }

    // Paredes
    for (let dy = 0; dy < 5; dy++) {
      for (let dx = -3; dx <= 3; dx++) {
        for (let dz = -3; dz <= 3; dz++) {
          if (Math.abs(dx) === 3 || Math.abs(dz) === 3) {
            if (dy === 1 && dx === 0 && dz === 3) {
              continue; // Porta
            }
            setBlock(x + dx, y + dy, z + dz, 'planks');
          }
        }
      }
    }

    // Segundo andar
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        setBlock(x + dx, y + 5, z + dz, 'planks');
      }
    }

    // Janelas do segundo andar
    setBlock(x - 2, y + 6, z, 'glass');
    setBlock(x + 2, y + 6, z, 'glass');
    setBlock(x, y + 6, z - 2, 'glass');

    // Telhado em camadas
    for (let dy = 0; dy < 4; dy++) {
      const size = 3 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -size; dz <= size; dz++) {
          setBlock(x + dx, y + 5 + dy, z + dz, 'brick');
        }
      }
    }

    // Chamin√©
    for (let dy = 0; dy < 6; dy++) {
      setBlock(x + 2, y + 5 + dy, z + 2, 'brick');
    }
    setBlock(x + 2, y + 11, z + 2, 'cobblestone');

    // Janelas t√©rreo
    setBlock(x - 3, y + 2, z - 1, 'glass');
    setBlock(x - 3, y + 2, z + 1, 'glass');
    setBlock(x + 3, y + 2, z - 1, 'glass');
    setBlock(x + 3, y + 2, z + 1, 'glass');

    // Jardim da frente
    for (let dx = -2; dx <= 2; dx++) {
      setBlock(x + dx, y, z + 4, 'grass');
      if (Math.random() > 0.7) {
        setBlock(x + dx, y + 1, z + 4, 'leaves');
      }
    }

    // Lanternas na entrada
    setBlock(x - 1, y, z + 3, 'planks');
    setBlock(x - 1, y + 1, z + 3, 'planks');
    setBlock(x - 1, y + 2, z + 3, 'lantern');

    setBlock(x + 1, y, z + 3, 'planks');
    setBlock(x + 1, y + 1, z + 3, 'planks');
    setBlock(x + 1, y + 2, z + 3, 'lantern');
  }

  function buildDecoratedHouse(x, y, z) {
    buildHouse(x, y, z); // Casa base original

    // Adicionar decora√ß√£o externa
    // Varanda
    for (let dx = -1; dx <= 1; dx++) {
      setBlock(x + dx, y, z + 3, 'planks');
    }

    // Colunas da varanda
    setBlock(x - 1, y + 1, z + 3, 'planks');
    setBlock(x + 1, y + 1, z + 3, 'planks');

    // Telhado da varanda
    setBlock(x - 1, y + 2, z + 3, 'brick');
    setBlock(x, y + 2, z + 3, 'brick');
    setBlock(x + 1, y + 2, z + 3, 'brick');

    // Jardim lateral
    setBlock(x + 3, y, z - 1, 'dirt');
    setBlock(x + 3, y, z, 'dirt');
    setBlock(x + 3, y, z + 1, 'dirt');

    setBlock(x + 3, y + 1, z - 1, 'leaves');
    setBlock(x + 3, y + 1, z + 1, 'leaves');

    // Cerca decorativa
    setBlock(x + 4, y, z - 2, 'planks');
    setBlock(x + 4, y, z, 'planks');
    setBlock(x + 4, y, z + 2, 'planks');
  }

  function buildMarketplace(x, y, z) {
    // Plataforma elevada (10x10)
    for (let dx = -5; dx <= 5; dx++) {
      for (let dz = -5; dz <= 5; dz++) {
        setBlock(x + dx, y, z + dz, 'planks');
      }
    }

    // Barracas (4 barracas ao redor)
    const stallPositions = [
      { dx: -3, dz: -3 }, { dx: 3, dz: -3 },
      { dx: -3, dz: 3 }, { dx: 3, dz: 3 }
    ];

    stallPositions.forEach(pos => {
      // Base da barraca
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
            setBlock(x + pos.dx + dx, y + 1, z + pos.dz + dz, 'planks');
          }
        }
      }

      // Pilares
      setBlock(x + pos.dx - 1, y + 2, z + pos.dz - 1, 'planks');
      setBlock(x + pos.dx + 1, y + 2, z + pos.dz - 1, 'planks');
      setBlock(x + pos.dx - 1, y + 2, z + pos.dz + 1, 'planks');
      setBlock(x + pos.dx + 1, y + 2, z + pos.dz + 1, 'planks');

      // Telhado
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          if (Math.abs(dx) <= 2 && Math.abs(dz) <= 2) {
            setBlock(x + pos.dx + dx, y + 3, z + pos.dz + dz, 'planks');
          }
        }
      }

      // Itens na barraca (ba√∫s)
      setBlock(x + pos.dx, y + 1, z + pos.dz, 'chest');
    });

    // Lanterna central
    setBlock(x, y + 1, z, 'planks');
    setBlock(x, y + 2, z, 'planks');
    setBlock(x, y + 3, z, 'planks');
    setBlock(x, y + 4, z, 'lantern');
  }

  function buildInn(x, y, z) {
    // Base grande (8x10)
    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -5; dz <= 5; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'planks');
      }
    }

    // Paredes
    for (let dy = 0; dy < 6; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        for (let dz = -5; dz <= 5; dz++) {
          if (Math.abs(dx) === 4 || Math.abs(dz) === 5) {
            if (dy === 1 && dx === 0 && dz === 5) {
              continue; // Porta principal
            }
            if (dy === 1 && dx === -4 && dz === 0) {
              continue; // Porta lateral
            }
            setBlock(x + dx, y + dy, z + dz, 'planks');
          }
        }
      }
    }

    // Segundo andar
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -4; dz <= 4; dz++) {
        setBlock(x + dx, y + 6, z + dz, 'planks');
      }
    }

    // Janelas - primeiro andar
    for (let dz = -3; dz <= 3; dz += 3) {
      setBlock(x - 4, y + 2, z + dz, 'glass');
      setBlock(x + 4, y + 2, z + dz, 'glass');
    }

    // Janelas - segundo andar
    for (let dx = -2; dx <= 2; dx += 2) {
      setBlock(x + dx, y + 7, z - 4, 'glass');
      setBlock(x + dx, y + 7, z + 4, 'glass');
    }

    // Telhado
    for (let dy = 0; dy < 4; dy++) {
      const size = 4 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -5; dz <= 5; dz++) {
          setBlock(x + dx, y + 6 + dy, z + dz, 'brick');
        }
      }
    }

    // Placa de madeira (simulando placa da pousada)
    setBlock(x - 2, y + 3, z + 5, 'planks');
    setBlock(x - 1, y + 3, z + 5, 'planks');
    setBlock(x, y + 3, z + 5, 'planks');
    setBlock(x + 1, y + 3, z + 5, 'planks');
    setBlock(x + 2, y + 3, z + 5, 'planks');

    // Lanternas na entrada
    setBlock(x - 2, y, z + 6, 'planks');
    setBlock(x - 2, y + 1, z + 6, 'planks');
    setBlock(x - 2, y + 2, z + 6, 'lantern');

    setBlock(x + 2, y, z + 6, 'planks');
    setBlock(x + 2, y + 1, z + 6, 'planks');
    setBlock(x + 2, y + 2, z + 6, 'lantern');

    // Mesa e cadeiras dentro (mob√≠lia b√°sica)
    setBlock(x - 2, y + 1, z - 2, 'planks'); // Mesa
    setBlock(x - 2, y + 1, z + 2, 'planks');
    setBlock(x + 2, y + 1, z - 2, 'planks');
    setBlock(x + 2, y + 1, z + 2, 'planks');
  }

  function buildStable(x, y, z) {
    // Base (12x8)
    for (let dx = -6; dx <= 6; dx++) {
      for (let dz = -4; dz <= 4; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'dirt');
      }
    }

    // Paredes laterais (abertas na frente e atr√°s)
    for (let dy = 0; dy < 4; dy++) {
      for (let dz = -4; dz <= 4; dz++) {
        setBlock(x - 6, y + dy, z + dz, 'planks');
        setBlock(x + 6, y + dy, z + dz, 'planks');
      }
    }

    // Paredes de tr√°s e frente parciais
    for (let dx = -5; dx <= 5; dx++) {
      setBlock(x + dx, y, z - 4, 'planks');
      setBlock(x + dx, y + 1, z - 4, 'planks');

      if (Math.abs(dx) > 2) {
        setBlock(x + dx, y, z + 4, 'planks');
        setBlock(x + dx, y + 1, z + 4, 'planks');
      }
    }

    // Pilares
    for (let dy = 0; dy < 4; dy++) {
      setBlock(x - 5, y + dy, z - 3, 'planks');
      setBlock(x - 5, y + dy, z + 3, 'planks');
      setBlock(x + 5, y + dy, z - 3, 'planks');
      setBlock(x + 5, y + dy, z + 3, 'planks');
    }

    // Telhado
    for (let dy = 0; dy < 3; dy++) {
      const width = 6 - dy;
      for (let dx = -width; dx <= width; dx++) {
        for (let dz = -4; dz <= 4; dz++) {
          setBlock(x + dx, y + 4 + dy, z + dz, 'planks');
        }
      }
    }

    // Baias (compartimentos)
    for (let i = -4; i <= 4; i += 4) {
      for (let dx = -1; dx <= 1; dx++) {
        setBlock(x + dx, y, z + i, 'planks');
      }
      // Comedouros
      setBlock(x - 5, y + 1, z + i, 'planks');
      setBlock(x + 5, y + 1, z + i, 'planks');
    }

    // Porta dupla
    removeBlockData(x - 1, y, z + 4);
    removeBlockData(x - 1, y + 1, z + 4);
    removeBlockData(x + 1, y, z + 4);
    removeBlockData(x + 1, y + 1, z + 4);

    // Lanternas
    setBlock(x - 5, y + 3, z, 'lantern');
    setBlock(x + 5, y + 3, z, 'lantern');
  }

  function addVillageDecoration(centerX, villageY, centerZ) {
    // √Årvores decorativas ao redor
    const treePositions = [
      { x: 20, z: 20 }, { x: -20, z: 20 },
      { x: 20, z: -20 }, { x: -20, z: -20 },
      { x: 25, z: 0 }, { x: -25, z: 0 },
      { x: 0, z: 25 }, { x: 0, z: -25 }
    ];

    treePositions.forEach(pos => {
      const tx = centerX + pos.x;
      const tz = centerZ + pos.z;

      // Tronco
      for (let dy = 0; dy < 5; dy++) {
        setBlock(tx, villageY + 1 + dy, tz, 'wood');
      }

      // Copa
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          for (let dy = 0; dy <= 2; dy++) {
            if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 3) {
              setBlock(tx + dx, villageY + 5 + dy, tz + dz, 'leaves');
            }
          }
        }
      }
    });

    // Bancos ao redor da fonte
    for (let angle = 0; angle < 360; angle += 90) {
      const rad = angle * Math.PI / 180;
      const bx = Math.floor(centerX + Math.cos(rad) * 6);
      const bz = Math.floor(centerZ + Math.sin(rad) * 6);

      setBlock(bx, villageY, bz, 'planks');
      setBlock(bx - 1, villageY, bz, 'planks');
      setBlock(bx + 1, villageY, bz, 'planks');
    }
  }

  function startGame() {
    document.getElementById('main-menu').style.display = 'none';

    const chunk = worldToChunk(0, 0);
    player.lastChunk = chunk;

    const chunksToLoad = [];
    for (let cx = chunk.x - RENDER_DISTANCE; cx <= chunk.x + RENDER_DISTANCE; cx++) {
      for (let cz = chunk.z - RENDER_DISTANCE; cz <= chunk.z + RENDER_DISTANCE; cz++) {
        chunksToLoad.push([cx, cz]);
      }
    }

    chunksToLoad.forEach(([cx, cz]) => {
      generateChunk(cx, cz);
      spawnAnimals(cx, cz);
    });

    chunksToLoad.forEach(([cx, cz]) => {
      buildChunkMesh(cx, cz);
    });

    // Criar personagem
    playerCharacter = new PlayerCharacter();
    playerCharacter.setPosition(0, 25, 0);
    scene.add(playerCharacter.group);

    // Spawnar inimigos
    chunksToLoad.forEach(([cx, cz]) => {
      spawnEnemies(cx, cz);
    });

    // Gerar vila
    generateVillage(30, 30);

    controls.locked = true;
    renderer.domElement.requestPointerLock();

    animate();
  }


  blockTypes.water = { color: 0x1E90FF, name: '√Ågua', hardness: 0.5 };



  function cleanupUnusedResources() {
    // Limpar geometrias n√£o utilizadas
    for (let key in chunkMeshes) {
      const chunk = chunkMeshes[key];
      if (!scene.children.includes(chunk)) {
        chunk.children.forEach(child => {
          child.geometry.dispose();
          child.material.dispose();
        });
        delete chunkMeshes[key];
      }
    }

    // Limpar part√≠culas antigas
    if (particles.length > 1000) {
      particles.splice(0, particles.length - 1000).forEach(p => {
        scene.remove(p);
        p.geometry.dispose();
        p.material.dispose();
      });
    }

    // Limpar anima√ß√µes de quebra antigas
    if (breakingAnimations.length > 50) {
      breakingAnimations.splice(0, breakingAnimations.length - 50).forEach(anim => {
        anim.particles.forEach(p => {
          scene.remove(p);
          p.geometry.dispose();
          p.material.dispose();
        });
      });
    }
  }

  // Chamar cleanup periodicamente
  setInterval(cleanupUnusedResources, 30000);




  // Sistema de Controles Mobile
  const mobileControls = {
    enabled: false,
    joystick: { active: false, x: 0, y: 0 },
    look: { active: false, startX: 0, startY: 0 },
    buttons: {
      jump: false,
      fly: false,
      sprint: false,
      break: false,
      place: false
    }
  };

  function initMobileControls() {
    // Detectar dispositivo mobile
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
            || (window.matchMedia && window.matchMedia("(max-width: 768px)").matches);

    if (!isMobile) {
      document.querySelector('.mobile-controls').style.display = 'none';
      return;
    }

    mobileControls.enabled = true;

    // Joystick Virtual
    setupJoystick();

    // Look Around (toque na direita)
    setupLookControls();

    // Bot√µes de A√ß√£o
    setupActionButtons();

    // Auto-lock ao iniciar
    controls.locked = true;
  }

  function setupJoystick() {
    const joystick = document.getElementById('mobile-joystick');
    const stick = document.getElementById('joystick-stick');
    const rect = joystick.getBoundingClientRect();
    const centerX = rect.width / 2;
    const centerY = rect.height / 2;
    const maxDistance = 35;

    joystick.addEventListener('touchstart', (e) => {
      e.preventDefault();
      mobileControls.joystick.active = true;
    });

    joystick.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!mobileControls.joystick.active) return;

      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();

      let dx = touch.clientX - rect.left - centerX;
      let dy = touch.clientY - rect.top - centerY;

      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance > maxDistance) {
        const angle = Math.atan2(dy, dx);
        dx = Math.cos(angle) * maxDistance;
        dy = Math.sin(angle) * maxDistance;
      }

      stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

      // Normalizar valores (-1 a 1)
      mobileControls.joystick.x = dx / maxDistance;
      mobileControls.joystick.y = dy / maxDistance;

      // Simular teclas WASD
      keys['KeyW'] = mobileControls.joystick.y < -0.3;
      keys['KeyS'] = mobileControls.joystick.y > 0.3;
      keys['KeyA'] = mobileControls.joystick.x < -0.3;
      keys['KeyD'] = mobileControls.joystick.x > 0.3;
    });

    joystick.addEventListener('touchend', (e) => {
      e.preventDefault();
      mobileControls.joystick.active = false;
      mobileControls.joystick.x = 0;
      mobileControls.joystick.y = 0;

      stick.style.transform = 'translate(-50%, -50%)';

      keys['KeyW'] = false;
      keys['KeyS'] = false;
      keys['KeyA'] = false;
      keys['KeyD'] = false;
    });
  }

  function setupLookControls() {
    const lookArea = document.getElementById('mobile-look');
    let lastTouchX = 0;
    let lastTouchY = 0;

    lookArea.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      lastTouchX = touch.clientX;
      lastTouchY = touch.clientY;
      mobileControls.look.active = true;

      // Indicador visual
      showTouchIndicator(touch.clientX, touch.clientY);
    });

    lookArea.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!mobileControls.look.active) return;

      const touch = e.touches[0];
      const deltaX = touch.clientX - lastTouchX;
      const deltaY = touch.clientY - lastTouchY;

      // Sensibilidade ajustada para mobile
      const sensitivity = 0.003;
      mouse.x -= deltaX * sensitivity;
      mouse.y -= deltaY * sensitivity;
      mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));

      lastTouchX = touch.clientX;
      lastTouchY = touch.clientY;
    });

    lookArea.addEventListener('touchend', (e) => {
      e.preventDefault();
      mobileControls.look.active = false;
    });
  }

  function setupActionButtons() {
    // Pular
    const jumpBtn = document.getElementById('mobile-jump');
    jumpBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys['Space'] = true;
      jumpBtn.classList.add('active');
    });
    jumpBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      keys['Space'] = false;
      jumpBtn.classList.remove('active');
    });

    // Quebrar bloco
    const breakBtn = document.getElementById('mobile-break');
    breakBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      handleMouseDown({ button: 0 });
      breakBtn.classList.add('active');
    });
    breakBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      handleMouseUp({ button: 0 });
      breakBtn.classList.remove('active');
    });

    // Colocar bloco
    const placeBtn = document.getElementById('mobile-place');
    placeBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      handleMouseDown({ button: 2 });
      placeBtn.classList.add('active');
    });
    placeBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      handleMouseUp({ button: 2 });
      placeBtn.classList.remove('active');
    });

    // Modo voo
    const flyBtn = document.getElementById('mobile-fly');
    flyBtn.addEventListener('click', (e) => {
      e.preventDefault();
      player.flying = !player.flying;
      document.getElementById('mode').textContent = player.flying ? 'Voo' : 'Normal';
      flyBtn.classList.toggle('active', player.flying);
    });

    // Invent√°rio
    const invBtn = document.getElementById('mobile-inventory');
    invBtn.addEventListener('click', (e) => {
      e.preventDefault();
      toggleFullInventory();
    });

    // Sprint
    const sprintBtn = document.getElementById('mobile-sprint');
    sprintBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys['ShiftLeft'] = true;
      sprintBtn.classList.add('active');
    });
    sprintBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      keys['ShiftLeft'] = false;
      sprintBtn.classList.remove('active');
    });


    const prevSlotBtn = document.getElementById('mobile-prev-slot');
    if (prevSlotBtn) {
      prevSlotBtn.addEventListener('click', (e) => {
        e.preventDefault();
        const newSlot = (player.selectedSlot - 1 + player.hotbarSlots) % player.hotbarSlots;
        selectSlot(newSlot);
      });
    }

// Pr√≥ximo slot
    const nextSlotBtn = document.getElementById('mobile-next-slot');
    if (nextSlotBtn) {
      nextSlotBtn.addEventListener('click', (e) => {
        e.preventDefault();
        const newSlot = (player.selectedSlot + 1) % player.hotbarSlots;
        selectSlot(newSlot);
      });
    }


  }

  function showTouchIndicator(x, y) {
    const indicator = document.createElement('div');
    indicator.className = 'touch-indicator';
    indicator.style.left = x + 'px';
    indicator.style.top = y + 'px';
    document.body.appendChild(indicator);

    setTimeout(() => {
      indicator.remove();
    }, 300);
  }

  // Prevenir zoom indesejado em mobile
  document.addEventListener('touchmove', (e) => {
    if (e.scale !== 1) {
      e.preventDefault();
    }
  }, { passive: false });

  // Prevenir duplo toque para zoom
  let lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
      e.preventDefault();
    }
    lastTouchEnd = now;
  }, false);
  document.addEventListener('DOMContentLoaded', () => {
    const menuContainer = document.querySelector('.menu-container');
    if (menuContainer) {
      const settingsBtn = document.createElement('button');
      settingsBtn.className = 'menu-settings-btn';
      settingsBtn.innerHTML = '‚öôÔ∏è Configura√ß√µes';
      settingsBtn.onclick = openSettings;
      menuContainer.appendChild(settingsBtn);
    }
  });



  // ============================================
  // SISTEMA DE CONFIGURA√á√ïES
  // ============================================

  const gameSettings = {
    graphics: {
      renderDistance: 6,
      antialiasing: false,
      shadows: true,
      fog: true,
      particles: 'all',
      fpsLimit: 'unlimited'
    },
    gameplay: {
      difficulty: 'normal',
      creative: false,
      autoJump: false,
      mobSpawn: 50,
      healthRegen: 5
    },
    controls: {
      mouseSensitivity: 10,
      invertY: false,
      touchSensitivity: 10
    },
    audio: {
      masterVolume: 70,
      sfxVolume: 80,
      musicVolume: 50,
      ambientVolume: 60
    }
  };

  // Carregar configura√ß√µes salvas
  function loadSettings() {
    const saved = localStorage.getItem('minecraftSettings');
    if (saved) {
      try {
        const parsed = JSON.parse(saved);
        Object.assign(gameSettings, parsed);
        applySettings();
        updateSettingsUI();
      } catch (e) {
        console.error('Erro ao carregar configura√ß√µes:', e);
      }
    }
  }

  // Salvar configura√ß√µes
  function saveSettings() {
    localStorage.setItem('minecraftSettings', JSON.stringify(gameSettings));
    applySettings();
    showNotification('‚úÖ Configura√ß√µes salvas com sucesso!', 'success');
  }

  // Restaurar padr√£o
  function resetSettings() {
    if (confirm('Deseja restaurar todas as configura√ß√µes para o padr√£o?')) {
      localStorage.removeItem('minecraftSettings');
      location.reload();
    }
  }

  // Aplicar configura√ß√µes ao jogo
  function applySettings() {
    // Gr√°ficos
    if (gameSettings.graphics.shadows) {
      renderer.shadowMap.enabled = true;
    } else {
      renderer.shadowMap.enabled = false;
    }

    if (gameSettings.graphics.fog) {
      scene.fog = new THREE.Fog(0x87CEEB, 60, 120);
    } else {
      scene.fog = null;
    }

    // Dist√¢ncia de renderiza√ß√£o
    if (typeof RENDER_DISTANCE !== 'undefined') {
      // Atualizar chunks se mudou
      const newDistance = parseInt(gameSettings.graphics.renderDistance);
      if (newDistance !== RENDER_DISTANCE) {
        // Recarregar chunks
        updateVisibleChunks();
      }
    }

    // Dificuldade
    switch(gameSettings.gameplay.difficulty) {
      case 'peaceful':
        // Remover todos os inimigos
        enemies.forEach(e => e.remove());
        enemies = [];
        break;
      case 'easy':
        // Reduzir dano
        enemyTypes.zombie.damage = 2;
        enemyTypes.skeleton.damage = 1;
        break;
      case 'normal':
        // Dano padr√£o
        enemyTypes.zombie.damage = 3;
        enemyTypes.skeleton.damage = 2;
        break;
      case 'hard':
        // Aumentar dano
        enemyTypes.zombie.damage = 5;
        enemyTypes.skeleton.damage = 4;
        break;
    }

    // Modo criativo
    if (gameSettings.gameplay.creative) {
      player.flying = true;
      playerHealth = MAX_HEALTH;
      // Dar itens ilimitados
      for (let type in blockTypes) {
        addToInventory(type, 64);
      }
    }
  }

  // Atualizar interface de configura√ß√µes
  function updateSettingsUI() {
    // Gr√°ficos
    document.getElementById('render-distance').value = gameSettings.graphics.renderDistance;
    document.getElementById('render-distance-value').textContent = gameSettings.graphics.renderDistance;

    updateSwitchState('antialiasing', gameSettings.graphics.antialiasing);
    updateSwitchState('shadows', gameSettings.graphics.shadows);
    updateSwitchState('fog', gameSettings.graphics.fog);

    document.getElementById('particles-select').value = gameSettings.graphics.particles;
    document.getElementById('fps-select').value = gameSettings.graphics.fpsLimit;

    // Gameplay
    document.getElementById('difficulty-select').value = gameSettings.gameplay.difficulty;
    updateSwitchState('creative', gameSettings.gameplay.creative);
    updateSwitchState('autojump', gameSettings.gameplay.autoJump);

    document.getElementById('mob-spawn').value = gameSettings.gameplay.mobSpawn;
    document.getElementById('mob-spawn-value').textContent = gameSettings.gameplay.mobSpawn + '%';

    document.getElementById('health-regen').value = gameSettings.gameplay.healthRegen;
    document.getElementById('health-regen-value').textContent = gameSettings.gameplay.healthRegen;

    // Controles
    document.getElementById('mouse-sensitivity').value = gameSettings.controls.mouseSensitivity;
    document.getElementById('mouse-sensitivity-value').textContent = gameSettings.controls.mouseSensitivity;

    updateSwitchState('invertY', gameSettings.controls.invertY);

    document.getElementById('touch-sensitivity').value = gameSettings.controls.touchSensitivity;
    document.getElementById('touch-sensitivity-value').textContent = gameSettings.controls.touchSensitivity;

    // √Åudio
    document.getElementById('master-volume').value = gameSettings.audio.masterVolume;
    document.getElementById('master-volume-value').textContent = gameSettings.audio.masterVolume + '%';

    document.getElementById('sfx-volume').value = gameSettings.audio.sfxVolume;
    document.getElementById('sfx-volume-value').textContent = gameSettings.audio.sfxVolume + '%';

    document.getElementById('music-volume').value = gameSettings.audio.musicVolume;
    document.getElementById('music-volume-value').textContent = gameSettings.audio.musicVolume + '%';

    document.getElementById('ambient-volume').value = gameSettings.audio.ambientVolume;
    document.getElementById('ambient-volume-value').textContent = gameSettings.audio.ambientVolume + '%';
  }

  // Atualizar estado do switch
  function updateSwitchState(id, active) {
    const switchEl = document.getElementById(id + '-switch');
    if (switchEl) {
      if (active) {
        switchEl.classList.add('active');
      } else {
        switchEl.classList.remove('active');
      }
    }
  }

  // Atualizar configura√ß√£o
  function updateSetting(key, value) {
    const parts = key.split('.');
    if (parts.length === 1) {
      // Encontrar categoria
      for (let category in gameSettings) {
        if (gameSettings[category].hasOwnProperty(key)) {
          gameSettings[category][key] = value;
          break;
        }
      }
    }

    // Atualizar valores exibidos
    const valueEl = document.getElementById(key.toLowerCase().replace(/([A-Z])/g, '-$1') + '-value');
    if (valueEl) {
      if (key.includes('Volume') || key.includes('Spawn')) {
        valueEl.textContent = value + '%';
      } else {
        valueEl.textContent = value;
      }
    }

    // Aplicar em tempo real
    applySettings();
  }

  // Toggle switch
  function toggleSwitch(id) {
    const switchEl = document.getElementById(id + '-switch');
    const isActive = switchEl.classList.contains('active');

    if (isActive) {
      switchEl.classList.remove('active');
    } else {
      switchEl.classList.add('active');
    }

    // Atualizar configura√ß√£o
    for (let category in gameSettings) {
      if (gameSettings[category].hasOwnProperty(id)) {
        gameSettings[category][id] = !isActive;
        break;
      }
    }

    applySettings();
  }

  // Trocar tab
  function switchTab(tabName) {
    // Desativar todas as tabs
    document.querySelectorAll('.settings-tab').forEach(tab => {
      tab.classList.remove('active');
    });
    document.querySelectorAll('.settings-content').forEach(content => {
      content.classList.remove('active');
    });

    // Ativar tab selecionada
    event.target.classList.add('active');
    document.getElementById('tab-' + tabName).classList.add('active');
  }

  // Abrir configura√ß√µes
  function openSettings() {
    document.getElementById('settings-menu').classList.add('open');
    updateSettingsUI();
    updateStatsDisplay();

    // Atualizar stats periodicamente
    if (!window.statsInterval) {
      window.statsInterval = setInterval(updateStatsDisplay, 1000);
    }
  }

  // Fechar configura√ß√µes
  function closeSettings() {
    document.getElementById('settings-menu').classList.remove('open');

    if (window.statsInterval) {
      clearInterval(window.statsInterval);
      window.statsInterval = null;
    }
  }

  // Atualizar exibi√ß√£o de estat√≠sticas
  function updateStatsDisplay() {
    const fps = parseInt(document.getElementById('fps').textContent) || 60;
    document.getElementById('stat-fps').textContent = fps;

    const chunks = Object.keys(chunks).length;
    document.getElementById('stat-chunks').textContent = chunks;

    const totalEntities = animals.length + enemies.length + villagers.length;
    document.getElementById('stat-entities').textContent = totalEntities;

    if (performance.memory) {
      const memoryMB = (performance.memory.usedJSHeapSize / 1048576).toFixed(0);
      document.getElementById('stat-memory').textContent = memoryMB + 'MB';
    }
  }

  // Exportar dados do jogo
  function exportGameData() {
    const data = {
      world: worldData,
      player: {
        position: {
          x: camera.position.x,
          y: camera.position.y,
          z: camera.position.z
        },
        inventory: player.inventory,
        health: playerHealth
      },
      settings: gameSettings,
      timestamp: Date.now()
    };

    const json = JSON.stringify(data);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `minecraft-world-${Date.now()}.json`;
    a.click();

    showNotification('‚úÖ Mundo exportado com sucesso!', 'success');
  }

  // Importar dados do jogo
  function importGameData() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';

    input.onchange = (e) => {
      const file = e.target.files[0];
      const reader = new FileReader();

      reader.onload = (event) => {
        try {
          const data = JSON.parse(event.target.result);

          if (confirm('Importar este mundo ir√° substituir o mundo atual. Continuar?')) {
            worldData = data.world;
            player.inventory = data.player.inventory;
            playerHealth = data.player.health;

            camera.position.set(
                    data.player.position.x,
                    data.player.position.y,
                    data.player.position.z
            );

            if (data.settings) {
              Object.assign(gameSettings, data.settings);
            }

            // Recarregar chunks
            chunks = {};
            chunkMeshes = {};
            updateVisibleChunks();

            showNotification('‚úÖ Mundo importado com sucesso!', 'success');
            closeSettings();
          }
        } catch (e) {
          showNotification('‚ùå Erro ao importar mundo: ' + e.message, 'error');
        }
      };

      reader.readAsText(file);
    };

    input.click();
  }

  // Limpar dados do jogo
  function resetGameData() {
    if (confirm('ATEN√á√ÉO: Isto ir√° apagar TODO o progresso do jogo! Continuar?')) {
      if (confirm('Tem certeza absoluta? Esta a√ß√£o n√£o pode ser desfeita!')) {
        localStorage.clear();
        location.reload();
      }
    }
  }

  // Sistema de notifica√ß√µes
  function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
    color: white;
    padding: 15px 25px;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    z-index: 10000;
    animation: slideIn 0.3s ease;
  `;
    notification.textContent = message;

    document.body.appendChild(notification);

    setTimeout(() => {
      notification.style.animation = 'slideOut 0.3s ease';
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }

  // Adicionar anima√ß√µes de slide
  const style = document.createElement('style');
  style.textContent = `
  @keyframes slideIn {
    from { transform: translateX(400px); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  @keyframes slideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(400px); opacity: 0; }
  }
`;
  document.head.appendChild(style);

  // Carregar configura√ß√µes ao iniciar
  loadSettings();

  // Atalho de teclado para abrir configura√ß√µes (ESC)
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Escape' && controls.locked) {
      openSettings();
      document.exitPointerLock();
      controls.locked = false;
    }
  });


  // Adicionar ap√≥s a declara√ß√£o da c√¢mera (pr√≥ximo √† linha onde camera √© criada)
  const frustum = new THREE.Frustum();
  const cameraViewProjectionMatrix = new THREE.Matrix4();

  // MODIFICAR a fun√ß√£o updateVisibleChunks
  function updateVisibleChunks() {
    const px = camera.position.x;
    const pz = camera.position.z;
    const chunk = worldToChunk(px, pz);

    // Atualizar frustum da c√¢mera
    camera.updateMatrixWorld();
    cameraViewProjectionMatrix.multiplyMatrices(
            camera.projectionMatrix,
            camera.matrixWorldInverse
    );
    frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);

    const chunksToGenerate = [];
    const chunksToMesh = [];

    for (let cx = chunk.x - RENDER_DISTANCE; cx <= chunk.x + RENDER_DISTANCE; cx++) {
      for (let cz = chunk.z - RENDER_DISTANCE; cz <= chunk.z + RENDER_DISTANCE; cz++) {
        const chunkKey = getChunkKey(cx, cz);

        // Verificar se o chunk est√° dentro do frustum
        if (!isChunkInFrustum(cx, cz)) {
          continue;
        }

        if (!chunks[chunkKey]) {
          chunksToGenerate.push([cx, cz]);
        } else if (!chunkMeshes[chunkKey]) {
          chunksToMesh.push([cx, cz]);
        }
      }
    }

    chunksToGenerate.forEach(([cx, cz]) => {
      generateChunk(cx, cz);
      spawnAnimals(cx, cz);
      spawnEnemies(cx, cz);
    });

    chunksToMesh.forEach(([cx, cz]) => buildChunkMesh(cx, cz));

    const chunksToRemove = [];
    for (let key in chunkMeshes) {
      const [cx, cz] = key.split(',').map(Number);
      const dx = Math.abs(cx - chunk.x);
      const dz = Math.abs(cz - chunk.z);

      if (dx > RENDER_DISTANCE || dz > RENDER_DISTANCE) {
        chunksToRemove.push(key);
      }
    }

    chunksToRemove.forEach(key => {
      const [cx, cz] = key.split(',').map(Number);
      scene.remove(chunkMeshes[key]);
      chunkMeshes[key].children.forEach(child => {
        child.geometry.dispose();
      });
      delete chunkMeshes[key];
      removeAnimalsInChunk(cx, cz);
      removeEnemiesInChunk(cx, cz);
    });

    updateFaceCount();
  }

  // ADICIONAR nova fun√ß√£o para verificar se chunk est√° no frustum
  function isChunkInFrustum(cx, cz) {
    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    // Criar bounding box do chunk
    const chunkBox = new THREE.Box3(
            new THREE.Vector3(sx, 0, sz),
            new THREE.Vector3(sx + CHUNK_SIZE, 50, sz + CHUNK_SIZE)
    );

    return frustum.intersectsBox(chunkBox);
  }

  function animate() {
    requestAnimationFrame(animate);

    const deltaTime = 0.016;

    if (controls.locked && !document.getElementById('inventory-full').classList.contains('open')) {
      updatePlayer();
      updateBreaking();

      // ‚úÖ ADICIONAR AQUI - Sincroniza√ß√£o Multiplayer
      if (multiplayer.connected) {
        syncPlayerPosition();
      }

      if (playerCharacter) {
        const isMoving = keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'];
        const isJumping = !player.canJump;
        const isRunning = keys['ShiftLeft'] && isMoving;

        playerCharacter.updateAnimation(deltaTime, isMoving, isJumping, isRunning);

        playerCharacter.setPosition(
                camera.position.x,
                camera.position.y - 1.6,
                camera.position.z
        );
        playerCharacter.setRotation(camera.rotation.y);
      }
    }

    // Atualizar frustum da c√¢mera
    camera.updateMatrixWorld();
    cameraViewProjectionMatrix.multiplyMatrices(
            camera.projectionMatrix,
            camera.matrixWorldInverse
    );
    frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);

    // Frustum culling - ocultar chunks fora da vis√£o
    for (let key in chunkMeshes) {
      const [cx, cz] = key.split(',').map(Number);
      const mesh = chunkMeshes[key];

      if (mesh) {
        mesh.visible = isChunkInFrustum(cx, cz);
      }
    }

    // Atualizar sistemas
    if (waterSystem) waterSystem.updateWaves(performance.now() * 0.001);
    if (particleSystem) particleSystem.update();
    updateDayNightCycle(deltaTime);

    updateBreakAnimations();
    updateAnimals();
    updateEnemies();
    updateVillagers();

    renderer.render(scene, camera);

    frames++;
    const now = performance.now();

    if (now - lastFaceUpdate > 2000) {
      updateFaceCount();
      lastFaceUpdate = now;
    }

    if (now >= lastTime + 1000) {
      const fps = Math.round(frames * 1000 / (now - lastTime));
      document.getElementById('fps').textContent = fps;
      document.getElementById('fps').className = fps >= 50 ? 'performance-good' : fps >= 30 ? 'performance-ok' : 'performance-bad';

      document.getElementById('pos').textContent =
              `${Math.floor(camera.position.x)}, ${Math.floor(camera.position.y)}, ${Math.floor(camera.position.z)}`;
      document.getElementById('chunks').textContent = Object.keys(chunks).length;
      document.getElementById('total').textContent = Object.keys(worldData).length;
      document.getElementById('animals-count').textContent = `${animals.length} | I:${enemies.length} | A:${villagers.length}`;

      frames = 0;
      lastTime = now;
    }
  }

  function openMultiplayerMenu() {
    document.getElementById('multiplayer-menu').classList.add('open');
    updateMultiplayerMenuStatus();
  }

  function closeMultiplayerMenu() {
    document.getElementById('multiplayer-menu').classList.remove('open');
  }

  function toggleMultiplayerConnection() {
    if (multiplayer.connected) {
      disconnectMultiplayer();
    } else {
      const serverUrl = document.getElementById('mp-server-url').value;
      const playerName = document.getElementById('mp-player-name').value;

      multiplayer.serverUrl = serverUrl;
      multiplayer.enabled = true;

      connectMultiplayer();

      if (playerName) {
        setTimeout(() => {
          sendMultiplayerMessage({
            type: 'set_name',
            name: playerName
          });
        }, 1000);
      }
    }

    updateMultiplayerMenuStatus();
  }

  function updateMultiplayerMenuStatus() {
    const btn = document.getElementById('mp-connect-btn');
    const status = document.getElementById('mp-connection-status');
    const indicator = document.getElementById('mp-indicator');

    if (multiplayer.connected) {
      btn.textContent = 'Desconectar';
      btn.classList.remove('danger');
      status.textContent = 'Conectado ao servidor';
      indicator.className = 'mp-status-indicator online';
      document.getElementById('multiplayer-status').classList.remove('hidden');
    } else {
      btn.textContent = 'Conectar';
      btn.classList.add('mp-button');
      status.textContent = 'N√£o conectado';
      indicator.className = 'mp-status-indicator offline';
      document.getElementById('multiplayer-status').classList.add('hidden');
    }
  }

  // Adicionar bot√£o de multiplayer ao menu principal
  document.addEventListener('DOMContentLoaded', () => {
    const menuContainer = document.querySelector('.menu-container');
    if (menuContainer) {
      const mpBtn = document.createElement('button');
      mpBtn.className = 'start-button';
      mpBtn.style.background = 'linear-gradient(135deg, #2196F3, #1565C0)';
      mpBtn.innerHTML = 'üåê MULTIPLAYER';
      mpBtn.onclick = openMultiplayerMenu;

      const startBtn = document.querySelector('.start-button');
      if (startBtn) {
        startBtn.parentNode.insertBefore(mpBtn, startBtn.nextSibling);
      }
    }
  });























  // ============================================
  // SISTEMA DE TEXTURAS ULTRA-REALISTAS
  // ============================================

  // Fun√ß√£o auxiliar: Ru√≠do Perlin simplificado
  function perlinNoise(x, y) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    x -= Math.floor(x);
    y -= Math.floor(y);
    const u = fade(x);
    const v = fade(y);
    const hash = (X * 57 + Y * 113) % 256;
    return lerp(v, lerp(u, grad(hash, x, y), grad(hash + 1, x - 1, y)),
            lerp(u, grad(hash + 1, x, y - 1), grad(hash + 2, x - 1, y - 1)));
  }

  function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
  function lerp(t, a, b) { return a + t * (b - a); }
  function grad(hash, x, y) {
    const h = hash & 3;
    return ((h & 1) === 0 ? x : -x) + ((h & 2) === 0 ? y : -y);
  }

  // Fun√ß√£o auxiliar: Ru√≠do fractal (m√∫ltiplas oitavas)
  function fractalNoise(x, y, octaves = 4) {
    let total = 0;
    let frequency = 1;
    let amplitude = 1;
    let maxValue = 0;

    for (let i = 0; i < octaves; i++) {
      total += perlinNoise(x * frequency, y * frequency) * amplitude;
      maxValue += amplitude;
      amplitude *= 0.5;
      frequency *= 2;
    }

    return total / maxValue;
  }

  // Fun√ß√£o auxiliar: Simular ilumina√ß√£o direcional
  function applyLighting(ctx, x, y, width, height, intensity = 0.3) {
    const gradient = ctx.createRadialGradient(
            x + width * 0.3, y + height * 0.3, 0,
            x + width * 0.5, y + height * 0.5, width
    );
    gradient.addColorStop(0, `rgba(255, 255, 255, ${intensity})`);
    gradient.addColorStop(0.5, `rgba(255, 255, 255, ${intensity * 0.3})`);
    gradient.addColorStop(1, `rgba(0, 0, 0, ${intensity * 0.2})`);
    ctx.fillStyle = gradient;
    ctx.fillRect(x, y, width, height);
  }

  // ============================================
  // TEXTURAS ULTRA-REALISTAS
  // ============================================

  function createUltraRealisticGrassTexture(ctx, size) {
    // Base com gradiente complexo
    const bgGradient = ctx.createLinearGradient(0, 0, size, size);
    bgGradient.addColorStop(0, '#6FB849');
    bgGradient.addColorStop(0.2, '#7CFC00');
    bgGradient.addColorStop(0.5, '#6BCD00');
    bgGradient.addColorStop(0.7, '#5AB000');
    bgGradient.addColorStop(1, '#4A9000');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, size, size);

    // Camada de ru√≠do Perlin para varia√ß√£o natural
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const i = (y * size + x) * 4;
        const noise = fractalNoise(x * 0.1, y * 0.1, 5);
        const factor = 0.7 + noise * 0.3;

        data[i] = Math.floor(data[i] * factor);
        data[i + 1] = Math.floor(data[i + 1] * factor);
        data[i + 2] = Math.floor(data[i + 2] * factor);
      }
    }
    ctx.putImageData(imageData, 0, 0);

    // Fibras de grama individuais (alta densidade)
    for (let i = 0; i < 200; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const height = 3 + Math.random() * 5;
      const angle = Math.random() * Math.PI / 6 - Math.PI / 12;
      const thickness = 0.3 + Math.random() * 0.5;
      const shade = Math.random() * 60 - 30;
      const alpha = 0.3 + Math.random() * 0.4;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      // Haste da grama com gradiente
      const grassGrad = ctx.createLinearGradient(0, 0, 0, -height);
      grassGrad.addColorStop(0, `rgba(${60 + shade}, ${120 + shade}, ${20 + shade}, ${alpha})`);
      grassGrad.addColorStop(0.5, `rgba(${80 + shade}, ${180 + shade}, ${30 + shade}, ${alpha})`);
      grassGrad.addColorStop(1, `rgba(${100 + shade}, ${220 + shade}, ${40 + shade}, ${alpha * 0.7})`);

      ctx.strokeStyle = grassGrad;
      ctx.lineWidth = thickness;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(
              Math.random() * 2 - 1, -height * 0.5,
              Math.random() * 2 - 1, -height
      );
      ctx.stroke();

      ctx.restore();
    }

    // Manchas de terra/musgo
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 6;
      const shade = Math.random() * 40 - 20;

      const dirtGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
      dirtGrad.addColorStop(0, `rgba(${90 + shade}, ${70 + shade}, ${30 + shade}, 0.6)`);
      dirtGrad.addColorStop(0.5, `rgba(${70 + shade}, ${50 + shade}, ${20 + shade}, 0.4)`);
      dirtGrad.addColorStop(1, `rgba(${70 + shade}, ${50 + shade}, ${20 + shade}, 0)`);
      ctx.fillStyle = dirtGrad;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // Orvalho/got√≠culas de √°gua
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 0.5 + Math.random() * 1.5;

      // Got√≠cula com reflexo
      const dropGrad = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);
      dropGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
      dropGrad.addColorStop(0.4, 'rgba(200, 230, 255, 0.6)');
      dropGrad.addColorStop(1, 'rgba(150, 200, 230, 0.3)');
      ctx.fillStyle = dropGrad;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();

      // Brilho especular
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.beginPath();
      ctx.arc(x - r * 0.4, y - r * 0.4, r * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Sombras de grama (ambient occlusion)
    ctx.fillStyle = 'rgba(0, 30, 0, 0.1)';
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillRect(x, y, 2, 2);
    }

    // Ilumina√ß√£o geral
    applyLighting(ctx, 0, 0, size, size, 0.15);
  }

  function createUltraRealisticDirtTexture(ctx, size) {
    // Base com gradiente complexo
    const bgGradient = ctx.createRadialGradient(size * 0.5, size * 0.5, 0, size * 0.5, size * 0.5, size * 0.8);
    bgGradient.addColorStop(0, '#9B6B3F');
    bgGradient.addColorStop(0.5, '#8B4513');
    bgGradient.addColorStop(1, '#6B3410');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, size, size);

    // Ru√≠do Perlin para textura base
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const i = (y * size + x) * 4;
        const noise1 = fractalNoise(x * 0.08, y * 0.08, 4);
        const noise2 = fractalNoise(x * 0.15, y * 0.15, 3);
        const factor = 0.6 + noise1 * 0.3 + noise2 * 0.1;

        data[i] = Math.floor(data[i] * factor);
        data[i + 1] = Math.floor(data[i + 1] * factor);
        data[i + 2] = Math.floor(data[i + 2] * factor);
      }
    }
    ctx.putImageData(imageData, 0, 0);

    // Agregados de terra (torr√µes)
    for (let i = 0; i < 40; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 8;
      const shade = Math.random() * 50 - 25;
      const segments = 6 + Math.floor(Math.random() * 6);

      ctx.fillStyle = `rgba(${120 + shade}, ${80 + shade}, ${40 + shade}, ${0.5 + Math.random() * 0.3})`;
      ctx.beginPath();

      for (let j = 0; j <= segments; j++) {
        const angle = (j / segments) * Math.PI * 2;
        const r = radius * (0.8 + Math.random() * 0.4);
        const px = x + Math.cos(angle) * r;
        const py = y + Math.sin(angle) * r;

        if (j === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();

      // Sombra do torr√£o
      ctx.fillStyle = 'rgba(40, 25, 10, 0.4)';
      ctx.beginPath();
      ctx.ellipse(x + 1, y + 2, radius * 0.8, radius * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Pedrinhas e cascalho
    for (let i = 0; i < 80; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const w = 1 + Math.random() * 4;
      const h = 1 + Math.random() * 3;
      const shade = Math.random() * 60;

      // Pedrinha com forma irregular
      ctx.fillStyle = `rgba(${100 + shade}, ${100 + shade}, ${100 + shade}, ${0.6 + Math.random() * 0.3})`;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(Math.random() * Math.PI);
      ctx.fillRect(-w/2, -h/2, w, h);

      // Brilho na pedrinha
      ctx.fillStyle = 'rgba(200, 200, 200, 0.4)';
      ctx.fillRect(-w/2, -h/2, w * 0.4, h * 0.4);

      // Sombra
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(w/4, h/4, w * 0.4, h * 0.4);

      ctx.restore();
    }

    // Ra√≠zes e material org√¢nico
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const length = 10 + Math.random() * 20;
      const segments = 5 + Math.floor(Math.random() * 5);

      ctx.strokeStyle = `rgba(${50 + Math.random() * 30}, ${30 + Math.random() * 20}, ${10 + Math.random() * 10}, ${0.4 + Math.random() * 0.3})`;
      ctx.lineWidth = 0.5 + Math.random() * 1.5;
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(x, y);

      let currentX = x;
      let currentY = y;

      for (let j = 0; j < segments; j++) {
        currentX += (Math.random() - 0.5) * 8;
        currentY += (Math.random() - 0.5) * 8;
        ctx.lineTo(currentX, currentY);
      }
      ctx.stroke();
    }

    // Manchas de umidade
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 4 + Math.random() * 10;

      const wetGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
      wetGrad.addColorStop(0, 'rgba(60, 40, 20, 0.5)');
      wetGrad.addColorStop(0.5, 'rgba(70, 50, 25, 0.3)');
      wetGrad.addColorStop(1, 'rgba(80, 60, 30, 0)');
      ctx.fillStyle = wetGrad;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // Textura micro-detalhada
    for (let i = 0; i < size * 3; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgba(${100 + shade}, ${70 + shade}, ${40 + shade}, 0.2)`;
      ctx.fillRect(x, y, 1, 1);
    }

    // Ilumina√ß√£o direcional
    applyLighting(ctx, 0, 0, size, size, 0.2);
  }

  function createUltraRealisticStoneTexture(ctx, size) {
    // Base com gradiente radial
    const bgGradient = ctx.createRadialGradient(size * 0.3, size * 0.3, 0, size * 0.5, size * 0.5, size);
    bgGradient.addColorStop(0, '#9A9A9A');
    bgGradient.addColorStop(0.5, '#808080');
    bgGradient.addColorStop(1, '#606060');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, size, size);

    // Ru√≠do Perlin multi-oitava
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const i = (y * size + x) * 4;
        const noise1 = fractalNoise(x * 0.05, y * 0.05, 6);
        const noise2 = fractalNoise(x * 0.2, y * 0.2, 3);
        const factor = 0.5 + noise1 * 0.4 + noise2 * 0.1;

        data[i] = Math.floor(data[i] * factor);
        data[i + 1] = Math.floor(data[i + 1] * factor);
        data[i + 2] = Math.floor(data[i + 2] * factor);
      }
    }
    ctx.putImageData(imageData, 0, 0);

    // Forma√ß√µes rochosas (camadas sedimentares)
    for (let layer = 0; layer < 8; layer++) {
      const y = (layer / 8) * size + Math.random() * 8;
      const thickness = 2 + Math.random() * 4;
      const shade = Math.random() * 60 - 30;

      ctx.fillStyle = `rgba(${128 + shade}, ${128 + shade}, ${128 + shade}, ${0.2 + Math.random() * 0.3})`;
      ctx.fillRect(0, y, size, thickness);

      // Varia√ß√£o dentro da camada
      for (let i = 0; i < size / 2; i++) {
        const x = Math.random() * size;
        const localShade = Math.random() * 30 - 15;
        ctx.fillStyle = `rgba(${128 + shade + localShade}, ${128 + shade + localShade}, ${128 + shade + localShade}, 0.3)`;
        ctx.fillRect(x, y, 4, thickness);
      }
    }

    // Veios minerais complexos
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const segments = 5 + Math.floor(Math.random() * 8);
      const veinType = Math.random();

      let color;
      if (veinType < 0.3) {
        color = `rgba(${180 + Math.random() * 40}, ${180 + Math.random() * 40}, ${180 + Math.random() * 40}, 0.5)`;
      } else if (veinType < 0.6) {
        color = `rgba(${140 + Math.random() * 30}, ${120 + Math.random() * 30}, ${100 + Math.random() * 30}, 0.4)`;
      } else {
        color = `rgba(${100 + Math.random() * 30}, ${100 + Math.random() * 30}, ${120 + Math.random() * 40}, 0.4)`;
      }

      ctx.strokeStyle = color;
      ctx.lineWidth = 0.5 + Math.random() * 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      ctx.beginPath();
      ctx.moveTo(x, y);

      let currentX = x;
      let currentY = y;

      for (let j = 0; j < segments; j++) {
        currentX += (Math.random() - 0.5) * 12;
        currentY += (Math.random() - 0.5) * 12;
        ctx.lineTo(currentX, currentY);

        // Ramifica√ß√µes
        if (Math.random() > 0.7) {
          const branchX = currentX + (Math.random() - 0.5) * 8;
          const branchY = currentY + (Math.random() - 0.5) * 8;
          ctx.moveTo(currentX, currentY);
          ctx.lineTo(branchX, branchY);
          ctx.moveTo(currentX, currentY);
        }
      }
      ctx.stroke();
    }

    // Rachaduras profundas e realistas
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const segments = 3 + Math.floor(Math.random() * 5);

      // Sombra da rachadura
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(x, y);

      let currentX = x;
      let currentY = y;

      for (let j = 0; j < segments; j++) {
        currentX += (Math.random() - 0.5) * 10;
        currentY += (Math.random() - 0.5) * 10;
        ctx.lineTo(currentX, currentY);
      }
      ctx.stroke();

      // Luz na borda da rachadura
      ctx.strokeStyle = 'rgba(160, 160, 160, 0.3)';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    // Cristais pequenos e brilhantes
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const size_crystal = 0.5 + Math.random() * 2;

      // Cristal
      ctx.fillStyle = `rgba(${220 + Math.random() * 35}, ${220 + Math.random() * 35}, ${240 + Math.random() * 15}, ${0.4 + Math.random() * 0.4})`;
      ctx.fillRect(x, y, size_crystal, size_crystal);

      // Brilho especular
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.fillRect(x, y, size_crystal * 0.5, size_crystal * 0.5);
    }

    // Poros e imperfei√ß√µes
    for (let i = 0; i < 100; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 0.3 + Math.random() * 1;

      ctx.fillStyle = 'rgba(40, 40, 40, 0.5)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Ilumina√ß√£o direcional forte
    applyLighting(ctx, 0, 0, size, size, 0.25);
  }

  function createUltraRealisticWoodTexture(ctx, size) {
    // Base com gradiente de madeira
    const bgGradient = ctx.createLinearGradient(0, 0, size, 0);
    bgGradient.addColorStop(0, '#7A5230');
    bgGradient.addColorStop(0.5, '#654321');
    bgGradient.addColorStop(1, '#5A3A1F');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, size, size);

    // Centro do tronco
    const centerX = size / 2 + (Math.random() - 0.5) * size * 0.2;
    const centerY = size / 2 + (Math.random() - 0.5) * size * 0.2;

    // An√©is de crescimento ultra-realistas
    const numRings = 15 + Math.floor(Math.random() * 10);
    const maxRadius = Math.sqrt(2) * size;

    for (let ring = 0; ring < numRings; ring++) {
      const baseRadius = (ring / numRings) * maxRadius;
      const thickness = 2 + Math.random() * 5;
      const isDarkRing = ring % 2 === 0;
      const shade = isDarkRing ? -20 - Math.random() * 20 : 10 + Math.random() * 20;
      const opacity = 0.3 + Math.random() * 0.4;

      ctx.strokeStyle = `rgba(${80 + shade}, ${50 + shade}, ${20 + shade}, ${opacity})`;
      ctx.lineWidth = thickness;

      ctx.beginPath();

      // Anel irregular e natural
      for (let angle = 0; angle <= Math.PI * 2; angle += 0.05) {
        const noise1 = perlinNoise(Math.cos(angle) * 2, Math.sin(angle) * 2);
        const noise2 = perlinNoise(Math.cos(angle * 3) * 0.5, Math.sin(angle * 3) * 0.5);
        const variation = noise1 * 8 + noise2 * 3;
        const radius = baseRadius + variation;

        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;

        if (angle === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      ctx.stroke();

      // Varia√ß√£o de densidade dentro do anel
      if (isDarkRing) {
        ctx.strokeStyle = `rgba(${60 + shade}, ${40 + shade}, ${15 + shade}, ${opacity * 0.5})`;
        ctx.lineWidth = thickness * 0.3;
        ctx.stroke();
      }
    }

    // Veios verticais (fibras da madeira)
    for (let i = 0; i < 80; i++) {
      const x = Math.random() * size;
      const segments = 3 + Math.floor(Math.random() * 4);
      const shade = Math.random() * 40 - 20;

      ctx.strokeStyle = `rgba(${70 + shade}, ${45 + shade}, ${18 + shade}, ${0.15 + Math.random() * 0.2})`;
      ctx.lineWidth = 0.3 + Math.random() * 1;
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(x, 0);

      let currentX = x;
      let currentY = 0;

      for (let j = 0; j < segments; j++) {
        currentX += (Math.random() - 0.5) * 3;
        currentY += size / segments;
        ctx.lineTo(currentX, currentY);
      }
      ctx.stroke();
    }

    // N√≥s da madeira (defeitos naturais)
    const numKnots = 2 + Math.floor(Math.random() * 4);
    for (let i = 0; i < numKnots; i++) {
      const kx = Math.random() * size;
      const ky = Math.random() * size;
      const kRadius = 4 + Math.random() * 12;
      const shade = -30 - Math.random() * 30;

      // C√≠rculos conc√™ntricos do n√≥
      for (let r = 0; r < kRadius; r += 0.5 + Math.random()) {
        const ringShade = shade + Math.random() * 20;
        const alpha = 0.3 + (1 - r / kRadius) * 0.5;

        ctx.strokeStyle = `rgba(${60 + ringShade}, ${40 + ringShade}, ${15 + ringShade}, ${alpha})`;
        ctx.lineWidth = 1 + Math.random() * 2;

        ctx.beginPath();

        // N√≥ irregular
        for (let angle = 0; angle <= Math.PI * 2; angle += 0.2) {
          const noise = perlinNoise(Math.cos(angle) * 5, Math.sin(angle) * 5);
          const radius = r + noise * 2;
          const x = kx + Math.cos(angle) * radius;
          const y = ky + Math.sin(angle) * radius;

          if (angle === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.stroke();
      }

      // Centro do n√≥ (mais escuro)
      const centerGrad = ctx.createRadialGradient(kx, ky, 0, kx, ky, kRadius * 0.3);
      centerGrad.addColorStop(0, `rgba(${40 + shade}, ${25 + shade}, ${10 + shade}, 0.8)`);
      centerGrad.addColorStop(1, `rgba(${50 + shade}, ${30 + shade}, ${12 + shade}, 0.4)`);
      ctx.fillStyle = centerGrad;
      ctx.beginPath();
      ctx.arc(kx, ky, kRadius * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Textura de poros (pequenos buracos)
    for (let i = 0; i < 150; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 0.2 + Math.random() * 0.8;

      ctx.fillStyle = 'rgba(40, 25, 10, 0.4)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Manchas e varia√ß√µes de cor
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 10;
      const shade = Math.random() * 30 - 15;

      const spotGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
      spotGrad.addColorStop(0, `rgba(${90 + shade}, ${60 + shade}, ${30 + shade}, 0.3)`);
      spotGrad.addColorStop(1, `rgba(${90 + shade}, ${60 + shade}, ${30 + shade}, 0)`);
      ctx.fillStyle = spotGrad;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // Ilumina√ß√£o com reflexos de verniz
    applyLighting(ctx, 0, 0, size, size, 0.18);

    // Brilho especular (verniz)
    const glossGrad = ctx.createRadialGradient(size * 0.3, size * 0.3, 0, size * 0.5, size * 0.5, size * 0.8);
    glossGrad.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
    glossGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.05)');
    glossGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
    ctx.fillStyle = glossGrad;
    ctx.fillRect(0, 0, size, size);
  }

  function createUltraRealisticLeavesTexture(ctx, size) {
    // Base verde com varia√ß√£o
    const bgGradient = ctx.createRadialGradient(size * 0.4, size * 0.4, 0, size * 0.5, size * 0.5, size);
    bgGradient.addColorStop(0, '#32A832');
    bgGradient.addColorStop(0.5, '#228B22');
    bgGradient.addColorStop(1, '#1A6B1A');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, size, size);

    // Ru√≠do de fundo para densidade
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const i = (y * size + x) * 4;
        const noise = fractalNoise(x * 0.12, y * 0.12, 4);
        const factor = 0.6 + noise * 0.4;

        data[i] = Math.floor(data[i] * factor);
        data[i + 1] = Math.floor(data[i + 1] * factor);
        data[i + 2] = Math.floor(data[i + 2] * factor);
      }
    }
    ctx.putImageData(imageData, 0, 0);

    // Folhas individuais detalhadas
    for (let i = 0; i < 100; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const leafSize = 3 + Math.random() * 6;
      const angle = Math.random() * Math.PI * 2;
      const shade = Math.random() * 80 - 40;
      const alpha = 0.4 + Math.random() * 0.4;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      // Forma da folha (el√≠ptica com ponta)
      const leafGrad = ctx.createLinearGradient(-leafSize, 0, leafSize, 0);
      leafGrad.addColorStop(0, `rgba(${40 + shade}, ${160 + shade}, ${40 + shade}, ${alpha})`);
      leafGrad.addColorStop(0.5, `rgba(${50 + shade}, ${200 + shade}, ${50 + shade}, ${alpha})`);
      leafGrad.addColorStop(1, `rgba(${45 + shade}, ${180 + shade}, ${45 + shade}, ${alpha * 0.8})`);

      ctx.fillStyle = leafGrad;
      ctx.beginPath();
      ctx.ellipse(0, 0, leafSize, leafSize * 1.6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Nervura central
      ctx.strokeStyle = `rgba(${30 + shade}, ${120 + shade}, ${30 + shade}, ${alpha * 0.8})`;
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(0, -leafSize * 1.4);
      ctx.lineTo(0, leafSize * 1.4);
      ctx.stroke();

      // Nervuras secund√°rias
      for (let j = 0; j < 4; j++) {
        const offset = (j - 1.5) * leafSize * 0.5;
        ctx.beginPath();
        ctx.moveTo(0, offset);
        ctx.lineTo(-leafSize * 0.7, offset - leafSize * 0.3);
        ctx.moveTo(0, offset);
        ctx.lineTo(leafSize * 0.7, offset - leafSize * 0.3);
        ctx.stroke();
      }

      // Destaque (reflexo de luz)
      ctx.fillStyle = `rgba(150, 255, 100, ${alpha * 0.3})`;
      ctx.beginPath();
      ctx.ellipse(-leafSize * 0.3, -leafSize * 0.5, leafSize * 0.3, leafSize * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    // √Åreas de sombra (profundidade)
    for (let i = 0; i < 40; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 4 + Math.random() * 10;

      const shadowGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
      shadowGrad.addColorStop(0, 'rgba(10, 50, 10, 0.5)');
      shadowGrad.addColorStop(0.5, 'rgba(20, 70, 20, 0.3)');
      shadowGrad.addColorStop(1, 'rgba(20, 70, 20, 0)');
      ctx.fillStyle = shadowGrad;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // √Åreas iluminadas (luz solar filtrada)
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 8;

      const lightGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
      lightGrad.addColorStop(0, 'rgba(150, 255, 100, 0.4)');
      lightGrad.addColorStop(0.5, 'rgba(100, 230, 80, 0.2)');
      lightGrad.addColorStop(1, 'rgba(100, 230, 80, 0)');
      ctx.fillStyle = lightGrad;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // Buracos e imperfei√ß√µes (insetos)
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 1 + Math.random() * 3;

      // Buraco com sombra
      ctx.fillStyle = 'rgba(0, 20, 0, 0.7)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();

      // Borda do buraco
      ctx.strokeStyle = 'rgba(60, 40, 20, 0.5)';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Got√≠culas de √°gua
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 0.8 + Math.random() * 2;

      const dropGrad = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);
      dropGrad.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
      dropGrad.addColorStop(0.4, 'rgba(200, 240, 255, 0.5)');
      dropGrad.addColorStop(1, 'rgba(150, 220, 240, 0.2)');
      ctx.fillStyle = dropGrad;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();

      // Brilho especular
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.beginPath();
      ctx.arc(x - r * 0.4, y - r * 0.4, r * 0.35, 0, Math.PI * 2);
      ctx.fill();
    }

    // Ilumina√ß√£o ambiente
    applyLighting(ctx, 0, 0, size, size, 0.12);
  }

  // ============================================
  // SUBSTITUA A CHAMADA createTexture POR createEnhancedTexture
  // ============================================

  function createMaterialsWithEmissive() {
    for (let type in blockTypes) {
      const block = blockTypes[type];

      // Usar texturas ultra-realistas para blocos principais
      let texture;
      if (['grass', 'dirt', 'stone', 'wood', 'leaves'].includes(type)) {
        // Criar texturas ultra-realistas
        const canvas = document.createElement('canvas');
        canvas.width = 128; // Maior resolu√ß√£o
        canvas.height = 128;
        const ctx = canvas.getContext('2d');

        switch(type) {
          case 'grass':
            createUltraRealisticGrassTexture(ctx, 128);
            break;
          case 'dirt':
            createUltraRealisticDirtTexture(ctx, 128);
            break;
          case 'stone':
            createUltraRealisticStoneTexture(ctx, 128);
            break;
          case 'wood':
            createUltraRealisticWoodTexture(ctx, 128);
            break;
          case 'leaves':
            createUltraRealisticLeavesTexture(ctx, 128);
            break;
        }

        texture = new THREE.CanvasTexture(canvas);
        texture.magFilter = THREE.LinearFilter; // Filtro suave para maior qualidade
        texture.minFilter = THREE.LinearMipmapLinearFilter;
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // M√°xima qualidade
      } else {
        // Usar fun√ß√£o original para outros blocos
        texture = createEnhancedTexture(type);
      }

      if (block.emissive) {
        materials[type] = new THREE.MeshBasicMaterial({
          map: texture,
          emissive: block.color,
          emissiveIntensity: 0.8
        });
      } else if (type === 'glass' || type === 'ice') {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });
      } else if (type === 'water') {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
      } else if (type === 'leaves') {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,
          opacity: 0.9,
          side: THREE.DoubleSide,
          alphaTest: 0.5
        });
      } else {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          flatShading: false
        });
      }
    }
  }



  // ============================================
  // SISTEMA DE ILUMINA√á√ÉO REALISTA
  // ============================================

  const lightingSystem = {
    lights: new Map(),
    maxLights: 50, // Limite para performance
    lightRange: 12,
    updateQueue: []
  };

  // Adicionar luz para bloco emissivo
  function addBlockLight(x, y, z, type) {
    const blockInfo = blockTypes[type];
    if (!blockInfo || !blockInfo.emissive) return;

    const lightKey = `${x},${y},${z}`;

    // Remover luz existente se houver
    removeBlockLight(x, y, z);

    // Configurar cor e intensidade baseado no tipo de bloco
    let color, intensity, distance;

    switch(type) {
      case 'torch':
        color = 0xFF8C00;
        intensity = 1.5;
        distance = 10;
        break;
      case 'lantern':
        color = 0xFFD700;
        intensity = 2.0;
        distance = 12;
        break;
      case 'glowstone':
        color = 0xFFFF99;
        intensity = 2.5;
        distance = 14;
        break;
      default:
        color = blockInfo.color;
        intensity = 1.2;
        distance = 10;
    }

    // Criar luz pontual
    const light = new THREE.PointLight(color, intensity, distance);
    light.position.set(x, y, z);
    light.castShadow = true;

    // Configurar sombras suaves
    light.shadow.mapSize.width = 512;
    light.shadow.mapSize.height = 512;
    light.shadow.camera.near = 0.5;
    light.shadow.camera.far = distance;
    light.shadow.bias = -0.0001;

    scene.add(light);

    lightingSystem.lights.set(lightKey, {
      light: light,
      type: type,
      x: x,
      y: y,
      z: z
    });

    // Adicionar efeito de part√≠culas para tochas
    if (type === 'torch') {
      addTorchParticles(x, y, z);
    }

    return light;
  }

  // Remover luz de bloco
  function removeBlockLight(x, y, z) {
    const lightKey = `${x},${y},${z}`;
    const lightData = lightingSystem.lights.get(lightKey);

    if (lightData) {
      scene.remove(lightData.light);
      lightData.light.dispose();
      lightingSystem.lights.delete(lightKey);
    }
  }

  // Atualizar luzes pr√≥ximas ao jogador
  function updateDynamicLighting() {
    const playerPos = camera.position;
    const updateRadius = 30;

    lightingSystem.lights.forEach((lightData, key) => {
      const dx = lightData.x - playerPos.x;
      const dy = lightData.y - playerPos.y;
      const dz = lightData.z - playerPos.z;
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

      // Otimiza√ß√£o: desativar luzes muito distantes
      if (dist > updateRadius) {
        lightData.light.visible = false;
      } else {
        lightData.light.visible = true;

        // Efeito de cintila√ß√£o suave para tochas
        if (lightData.type === 'torch') {
          const flicker = 0.95 + Math.sin(Date.now() * 0.01 + lightData.x) * 0.05;
          lightData.light.intensity = 1.5 * flicker;
        }
      }
    });
  }

  // Adicionar part√≠culas de fogo para tochas
  function addTorchParticles(x, y, z) {
    if (!particleSystem) return;

    setInterval(() => {
      // Verificar se a tocha ainda existe
      const block = getBlock(x, y, z);
      if (!block || block.type !== 'torch') return;

      // Emitir part√≠culas de fuma√ßa/fogo
      const colors = [0xFF8C00, 0xFF6B00, 0xFFB347, 0x888888];
      const color = colors[Math.floor(Math.random() * colors.length)];

      particleSystem.emit(
              new THREE.Vector3(x + (Math.random() - 0.5) * 0.2, y + 0.5, z + (Math.random() - 0.5) * 0.2),
              color,
              2,
              0.05
      );
    }, 200);
  }

  // Sistema de ilumina√ß√£o ambiente din√¢mica
  function updateAmbientLighting() {
    const timeOfDay = dayNightCycle;

    // Simular ciclo dia/noite
    const sunIntensity = Math.max(0.3, Math.sin(timeOfDay * Math.PI * 2) * 0.7 + 0.5);

    // Atualizar luz direcional (sol)
    scene.traverse(obj => {
      if (obj.isDirectionalLight) {
        obj.intensity = sunIntensity;

        // Mover posi√ß√£o do sol
        const sunAngle = timeOfDay * Math.PI * 2;
        obj.position.set(
                Math.cos(sunAngle) * 100,
                Math.sin(sunAngle) * 100,
                50
        );
      }

      if (obj.isAmbientLight) {
        obj.intensity = 0.4 + sunIntensity * 0.3;
      }
    });

    // Ajustar cor do c√©u
    if (sky && sky.material) {
      const skyColor = new THREE.Color();
      if (sunIntensity > 0.5) {
        // Dia
        skyColor.setHSL(0.55, 0.7, 0.5 + sunIntensity * 0.3);
      } else {
        // Noite
        skyColor.setHSL(0.6, 0.3, 0.1 + sunIntensity * 0.2);
      }
      sky.material.color = skyColor;
    }
  }

  // Escanear e adicionar luzes para blocos existentes
  function scanAndAddLights(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;

    for (let x = sx; x < sx + CHUNK_SIZE; x++) {
      for (let z = sz; z < sz + CHUNK_SIZE; z++) {
        for (let y = 0; y < 50; y++) {
          const block = getBlock(x, y, z);
          if (block && blockTypes[block.type] && blockTypes[block.type].emissive) {
            addBlockLight(x, y, z, block.type);
          }
        }
      }
    }
  }

  // Remover luzes de chunk descarregado
  function removeLightsInChunk(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;
    const ex = sx + CHUNK_SIZE;
    const ez = sz + CHUNK_SIZE;

    const lightsToRemove = [];

    lightingSystem.lights.forEach((lightData, key) => {
      if (lightData.x >= sx && lightData.x < ex &&
              lightData.z >= sz && lightData.z < ez) {
        lightsToRemove.push(key);
      }
    });

    lightsToRemove.forEach(key => {
      const [x, y, z] = key.split(',').map(Number);
      removeBlockLight(x, y, z);
    });
  }

  // Sistema de ilumina√ß√£o volum√©trica (god rays)
  function addVolumetricLighting() {
    // Adicionar luz volum√©trica sutil
    const volumetricLight = new THREE.SpotLight(0xffffff, 0.3);
    volumetricLight.position.set(50, 100, 50);
    volumetricLight.angle = Math.PI / 6;
    volumetricLight.penumbra = 0.5;
    volumetricLight.decay = 2;
    volumetricLight.distance = 200;

    volumetricLight.castShadow = true;
    volumetricLight.shadow.mapSize.width = 1024;
    volumetricLight.shadow.mapSize.height = 1024;

    scene.add(volumetricLight);

    return volumetricLight;
  }

  // Ilumina√ß√£o especial para √°gua
  function addWaterLighting(x, y, z) {
    const waterLight = new THREE.PointLight(0x4499FF, 0.3, 8);
    waterLight.position.set(x, y, z);
    scene.add(waterLight);

    return waterLight;
  }

  // Efeito de brilho para blocos especiais
  function addGlowEffect(mesh, color, intensity = 1) {
    mesh.traverse(child => {
      if (child.isMesh && child.material) {
        child.material.emissive = new THREE.Color(color);
        child.material.emissiveIntensity = intensity;
      }
    });
  }










  init();
</script>
</body>
</html>
