<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft Ultra Otimizado - Sistema Completo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      overflow: hidden;
      font-family: 'Courier New', monospace;
      background: #000;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.9);
      padding: 12px 18px;
      border-radius: 8px;
      z-index: 100;
      font-size: 12px;
      line-height: 1.8;
      max-width: 250px;
    }
    .performance-good { color: #00ff00; }
    .performance-ok { color: #ffff00; }
    .performance-bad { color: #ff0000; }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      z-index: 100;
      pointer-events: none;
    }
    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 0 3px rgba(0,0,0,0.8);
    }
    #crosshair::before {
      width: 2px;
      height: 20px;
      left: 9px;
    }
    #crosshair::after {
      width: 20px;
      height: 2px;
      top: 9px;
    }

    /* Invent√°rio Expandido */
    #inventory-bar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 5px;
      z-index: 100;
    }
    .inv-slot {
      width: 55px;
      height: 55px;
      background: rgba(0, 0, 0, 0.85);
      border: 3px solid #444;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
      border-radius: 6px;
      position: relative;
    }
    .inv-slot.active {
      border-color: #fff;
      background: rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 15px rgba(255,255,255,0.6);
      transform: scale(1.1);
    }
    .block-icon {
      width: 35px;
      height: 35px;
      margin-bottom: 3px;
      border-radius: 3px;
    }
    .slot-count {
      position: absolute;
      bottom: 2px;
      right: 5px;
      font-size: 10px;
      font-weight: bold;
      color: white;
      text-shadow: 1px 1px 2px black;
    }

    /* Sistema de Vida */
    #health-container {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 3px;
      z-index: 100;
    }
    .heart {
      width: 20px;
      height: 20px;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23ff0000" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
      background-size: contain;
    }
    .heart.half {
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23ff0000" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/><path fill="%23777777" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" transform="scale(-1,1) translate(-24,0)"/></svg>');
    }
    .heart.empty {
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23777777" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
    }

    /* Invent√°rio Completo */
    #inventory-full {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 4px solid #555;
      border-radius: 10px;
      padding: 20px;
      z-index: 200;
      display: none;
      grid-template-columns: repeat(9, 50px);
      gap: 5px;
      max-width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
    }
    #inventory-full.open {
      display: grid;
    }
    .inv-full-slot {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid #666;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      position: relative;
    }
    .inv-full-slot.has-item {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Menu Inicial Moderno */
    #main-menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: 'Minecraft', 'Courier New', monospace;
    }

    .menu-container {
      background: rgba(0, 0, 0, 0.85);
      padding: 40px;
      border-radius: 20px;
      border: 4px solid #4CAF50;
      box-shadow: 0 0 40px rgba(76, 175, 80, 0.5),
      inset 0 0 20px rgba(76, 175, 80, 0.2);
      max-width: 800px;
      width: 90%;
      text-align: center;
      animation: glow 2s infinite alternate;
    }

    @keyframes glow {
      from { box-shadow: 0 0 30px rgba(76, 175, 80, 0.5); }
      to { box-shadow: 0 0 50px rgba(76, 175, 80, 0.8); }
    }

    .menu-title {
      font-size: 48px;
      color: #4CAF50;
      text-shadow: 3px 3px 0 #000,
      0 0 20px #4CAF50;
      margin-bottom: 30px;
      letter-spacing: 3px;
    }

    .menu-subtitle {
      font-size: 20px;
      color: #fff;
      margin-bottom: 40px;
      line-height: 1.6;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      margin: 30px 0;
      padding: 20px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      border: 2px solid #4CAF50;
    }

    .control-item {
      background: rgba(76, 175, 80, 0.1);
      padding: 12px;
      border-radius: 8px;
      text-align: left;
      color: white;
      border: 1px solid #4CAF50;
      transition: all 0.3s;
    }

    .control-item:hover {
      transform: translateY(-3px);
      background: rgba(76, 175, 80, 0.2);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .control-item strong {
      color: #4CAF50;
      font-size: 16px;
      display: block;
      margin-bottom: 5px;
    }

    .features-grid {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 30px 0;
      flex-wrap: wrap;
    }

    .feature {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 10px;
      min-width: 150px;
      transition: transform 0.3s;
    }

    .feature:hover {
      transform: scale(1.05);
    }

    .feature-icon {
      font-size: 36px;
      margin-bottom: 10px;
      display: block;
    }

    .feature-text {
      color: white;
      font-size: 14px;
    }

    .start-button {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      color: white;
      border: none;
      padding: 20px 60px;
      font-size: 24px;
      font-weight: bold;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      margin-top: 20px;
      text-transform: uppercase;
      letter-spacing: 2px;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
    }

    .start-button:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
      background: linear-gradient(135deg, #66BB6A, #388E3C);
    }

    .start-button:active {
      transform: translateY(-2px);
    }

    .menu-footer {
      margin-top: 30px;
      color: #888;
      font-size: 14px;
    }

    /* Barra de Progresso de Quebra */
    .break-progress {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100px;
      height: 8px;
      background: rgba(0,0,0,0.7);
      border-radius: 4px;
      overflow: hidden;
      display: none;
      z-index: 100;
    }
    .break-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000, #ffff00);
      width: 0%;
      transition: width 0.1s;
    }

    /* Controles Mobile */
    .mobile-controls {
      display: none;
      position: fixed;
      z-index: 150;
    }

    @media (max-width: 768px), (pointer: coarse) {
      .mobile-controls {
        display: block;
      }
    }

    /* Joystick Virtual */
    #mobile-joystick {
      position: fixed;
      bottom: 80px;
      left: 30px;
      width: 120px;
      height: 120px;
      background: rgba(0, 0, 0, 0.3);
      border: 3px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      touch-action: none;
    }

    #joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.7);
      border: 2px solid rgba(0, 0, 0, 0.5);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.1s;
    }

    /* √Årea de Look Around */
    #mobile-look {
      position: fixed;
      top: 0;
      right: 0;
      width: 50%;
      height: 100%;
      background: rgba(0, 0, 0, 0.05);
      touch-action: none;
      pointer-events: auto;
    }

    /* Bot√µes de A√ß√£o */
    .mobile-buttons {
      position: fixed;
      bottom: 80px;
      right: 30px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .mobile-btn {
      width: 60px;
      height: 60px;
      background: rgba(0, 0, 0, 0.6);
      border: 3px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
      user-select: none;
      font-weight: bold;
    }

    .mobile-btn:active {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(0.95);
    }

    .mobile-btn.active {
      background: rgba(76, 175, 80, 0.8);
      border-color: #4CAF50;
    }

    /* Bot√µes Superiores */
    .mobile-top-buttons {
      position: fixed;
      top: 80px;
      right: 10px;
      display: flex;
      gap: 10px;
    }

    .mobile-top-btn {
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 8px;
      color: white;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
    }

    /* Indicador de toque */
    .touch-indicator {
      position: fixed;
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      animation: touch-pulse 0.3s;
      z-index: 200;
    }

    @keyframes touch-pulse {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
    }

    /* Ajustes para mobile */
    @media (max-width: 768px) {
      #info {
        font-size: 10px;
        padding: 8px 12px;
        max-width: 200px;
      }

      #inventory-bar {
        bottom: 10px;
        transform: translateX(-50%) scale(0.8);
      }

      .inv-slot {
        width: 45px;
        height: 45px;
      }

      #crosshair {
        width: 15px;
        height: 15px;
      }
    }

  </style>
</head>
<body>
<div id="main-menu">
  <div class="menu-container">
    <h1 class="menu-title">‚õèÔ∏è MINECRAFT ULTRA OTIMIZADO ‚õèÔ∏è</h1>

    <p class="menu-subtitle">
      Uma experi√™ncia completa de Minecraft com gr√°ficos otimizados, sistema de vida,
      animais e invent√°rio expandido. Tudo rodando diretamente no seu navegador!
    </p>

    <div class="controls-grid">
      <div class="control-item">
        <strong>W/A/S/D</strong>
        <span>Movimenta√ß√£o</span>
      </div>
      <div class="control-item">
        <strong>ESPA√áO</strong>
        <span>Pular</span>
      </div>
      <div class="control-item">
        <strong>SHIFT</strong>
        <span>Correr / Descer (Voo)</span>
      </div>
      <div class="control-item">
        <strong>MOUSE</strong>
        <span>Olhar ao redor</span>
      </div>
      <div class="control-item">
        <strong>CLIQUE ESQUERDO</strong>
        <span>Quebrar bloco</span>
      </div>
      <div class="control-item">
        <strong>CLIQUE DIREITO</strong>
        <span>Colocar bloco</span>
      </div>
      <div class="control-item">
        <strong>SCROLL / 1-9</strong>
        <span>Trocar bloco</span>
      </div>
      <div class="control-item">
        <strong>F</strong>
        <span>Alternar Modo Voo</span>
      </div>
      <div class="control-item">
        <strong>E</strong>
        <span>Abrir Invent√°rio</span>
      </div>
      <div class="control-item">
        <strong>Q</strong>
        <span>Jogar Item</span>
      </div>
    </div>

    <div class="features-grid">
      <div class="feature">
        <span class="feature-icon">‚ö°</span>
        <span class="feature-text">Alto Desempenho</span>
      </div>
      <div class="feature">
        <span class="feature-icon">‚ù§Ô∏è</span>
        <span class="feature-text">Sistema de Vida</span>
      </div>
      <div class="feature">
        <span class="feature-icon">üêÆ</span>
        <span class="feature-text">Animais Interativos</span>
      </div>
      <div class="feature">
        <span class="feature-icon">üéí</span>
        <span class="feature-text">36 Slots</span>
      </div>
      <div class="feature">
        <span class="feature-icon">üåç</span>
        <span class="feature-text">Mundo Gerado</span>
      </div>
    </div>

    <button class="start-button" onclick="startGame()">
      üéÆ INICIAR JOGO
    </button>

    <p class="menu-footer">
      Desenvolvido com Three.js ‚Ä¢ Otimizado para navegadores modernos
    </p>
  </div>
</div>

<div id="info">
  <div class="info-item"><strong>Posi√ß√£o:</strong> <span id="pos" class="highlight">0, 0, 0</span></div>
  <div class="info-item"><strong>FPS:</strong> <span id="fps" class="performance-good">60</span></div>
  <div class="info-item"><strong>Chunks:</strong> <span id="chunks" class="highlight">0</span></div>
  <div class="info-item"><strong>Faces:</strong> <span id="visible" class="highlight">0</span></div>
  <div class="info-item"><strong>Blocos:</strong> <span id="total" class="highlight">0</span></div>
  <div class="info-item"><strong>Animais:</strong> <span id="animals-count" class="highlight">0</span></div>
  <div class="info-item"><strong>Modo:</strong> <span id="mode" class="highlight">Normal</span></div>
  <div class="info-item"><strong>Bloco:</strong> <span id="selected-block" class="highlight">Grama</span></div>
</div>

<div id="health-container"></div>
<div id="crosshair"></div>
<div class="break-progress" id="break-progress">
  <div class="break-progress-fill"></div>
</div>
<div id="inventory-bar"></div>
<div id="inventory-full"></div>

<!-- Controles Mobile -->
<div class="mobile-controls">
  <!-- Joystick Virtual -->
  <div id="mobile-joystick">
    <div id="joystick-stick"></div>
  </div>

  <!-- √Årea de Look Around -->
  <div id="mobile-look"></div>

  <!-- Bot√µes de A√ß√£o -->
  <div class="mobile-buttons">
    <button class="mobile-btn" id="mobile-jump">‚Üë</button>
    <button class="mobile-btn" id="mobile-break">‚öí</button>
    <button class="mobile-btn" id="mobile-place">+</button>
  </div>

  <!-- Bot√µes Superiores -->
  <div class="mobile-top-buttons">
    <button class="mobile-top-btn" id="mobile-fly">‚úà</button>
    <button class="mobile-top-btn" id="mobile-inventory">üéí</button>
    <button class="mobile-top-btn" id="mobile-sprint">‚ö°</button>
  </div>
</div>

<button class="mobile-top-btn" id="mobile-prev-slot">‚óÄ</button>
<button class="mobile-top-btn" id="mobile-next-slot">‚ñ∂</button>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  let scene, camera, renderer, raycaster;
  let worldData = {};
  let chunks = {};
  let chunkMeshes = {};
  let inventory = {};
  let materials = {};
  let breakingAnimations = [];
  let animals = [];
  let animalMeshes = [];

  const CHUNK_SIZE = 16;
  const RENDER_DISTANCE = 6;
  const MAX_HEALTH = 20;
  let playerHealth = MAX_HEALTH;

  const player = {
    velocity: new THREE.Vector3(),
    canJump: false,
    selectedSlot: 0,
    flying: false,
    breaking: null,
    breakProgress: 0,
    lastChunk: { x: 0, z: 0 },
    inventorySlots: 36,
    hotbarSlots: 9
  };

  // Sistema de invent√°rio
  player.inventory = Array(player.inventorySlots).fill().map(() => ({
    type: null,
    count: 0
  }));

  let keys = {};
  let mouse = { x: 0, y: 0 };
  let controls = { locked: false };

  const GRAVITY = -0.018;
  const JUMP_SPEED = 0.28;
  const MOVE_SPEED = 0.15;
  const SPRINT_SPEED = 0.28;
  const FLY_SPEED = 0.4;
  const REACH = 7;
  const BREAK_TIME = 500;
  let lastTime = performance.now();
  let frames = 0;
  let lastFaceUpdate = 0;
  const blockTypes = {
    grass: { color: 0x7CFC00, name: 'Grama', hardness: 1 },
    dirt: { color: 0x8B4513, name: 'Terra', hardness: 1 },
    stone: { color: 0x808080, name: 'Pedra', hardness: 3 },
    wood: { color: 0x654321, name: 'Madeira', hardness: 2 },
    leaves: { color: 0x228B22, name: 'Folhas', hardness: 0.5 },
    sand: { color: 0xF4A460, name: 'Areia', hardness: 1 },
    cobblestone: { color: 0x6B6B6B, name: 'Pedregulho', hardness: 3 },
    coal_ore: { color: 0x343434, name: 'Carv√£o', hardness: 4 },
    iron_ore: { color: 0xD8AF93, name: 'Ferro', hardness: 5 },
    gold_ore: { color: 0xFFD700, name: 'Ouro', hardness: 5 },
    diamond_ore: { color: 0x00CED1, name: 'Diamante', hardness: 6 },
    bedrock: { color: 0x2F2F2F, name: 'Bedrock', hardness: 999 },
    planks: { color: 0xC19A6B, name: 'T√°buas', hardness: 2 },
    brick: { color: 0xB22222, name: 'Tijolo', hardness: 3 },
    glass: { color: 0xADD8E6, name: 'Vidro', hardness: 0.3 },
    obsidian: { color: 0x1C1C2E, name: 'Obsidiana', hardness: 8 },
    ice: { color: 0xB0E0E6, name: 'Gelo', hardness: 0.5 },
    snow: { color: 0xFFFAFA, name: 'Neve', hardness: 0.2 },
    gravel: { color: 0x8B8680, name: 'Cascalho', hardness: 1 },
    clay: { color: 0xA0A0A0, name: 'Argila', hardness: 1 },
    emerald_ore: { color: 0x50C878, name: 'Esmeralda', hardness: 6 },
    redstone_ore: { color: 0xFF0000, name: 'Redstone', hardness: 5 },


    // NOVOS BLOCOS ESPECIAIS - LUMINOSOS
    glowstone: { color: 0xFFFF99, name: 'Pedra Luminosa', hardness: 0.5, emissive: true },
    lantern: { color: 0xFFD700, name: 'Lanterna', hardness: 0.5, emissive: true },
    torch: { color: 0xFF8C00, name: 'Tocha', hardness: 0.1, emissive: true },

    // BLOCOS DECORATIVOS
    quartz: { color: 0xF5F5F5, name: 'Quartzo', hardness: 2 },
    prismarine: { color: 0x4ECDC4, name: 'Prismarinho', hardness: 3 },
    purpur: { color: 0xA569BD, name: 'Purpur', hardness: 3 },
    endstone: { color: 0xE4E096, name: 'Pedra do End', hardness: 4 },

    // BLOCOS DE CONSTRU√á√ÉO
    concrete_white: { color: 0xFFFFFF, name: 'Concreto Branco', hardness: 2 },
    concrete_red: { color: 0xDC143C, name: 'Concreto Vermelho', hardness: 2 },
    concrete_blue: { color: 0x1E90FF, name: 'Concreto Azul', hardness: 2 },
    concrete_green: { color: 0x32CD32, name: 'Concreto Verde', hardness: 2 },
    concrete_yellow: { color: 0xFFD700, name: 'Concreto Amarelo', hardness: 2 },
    concrete_black: { color: 0x2F4F4F, name: 'Concreto Preto', hardness: 2 },

    // BLOCOS FUNCIONAIS
    crafting_table: { color: 0x8B4513, name: 'Mesa de Trabalho', hardness: 2.5 },
    furnace: { color: 0x696969, name: 'Fornalha', hardness: 4 },
    chest: { color: 0xA0522D, name: 'Ba√∫', hardness: 2.5 },
    bookshelf: { color: 0x654321, name: 'Estante', hardness: 1.5 },

    // BLOCOS NATURAIS ESPECIAIS
    mushroom_red: { color: 0xFF0000, name: 'Cogumelo Vermelho', hardness: 0.2 },
    mushroom_brown: { color: 0x8B4513, name: 'Cogumelo Marrom', hardness: 0.2 },
    pumpkin: { color: 0xFF8C00, name: 'Ab√≥bora', hardness: 1 },
    melon: { color: 0x90EE90, name: 'Melancia', hardness: 1 },

    // BLOCOS DE MIN√âRIO RAROS
    lapis_ore: { color: 0x0000FF, name: 'L√°pis-laz√∫li', hardness: 4 },
    netherite: { color: 0x8B008B, name: 'Netherite', hardness: 10 }
  };

  const animalTypes = {
    cow: {
      name: 'Vaca',
      health: 10,
      size: { width: 1, height: 1.6, depth: 1.5 },
      color: 0x8B4513,
      drops: ['leather', 'beef'],
      dropCount: { min: 1, max: 3 }
    },
    pig: {
      name: 'Porco',
      health: 8,
      size: { width: 0.9, height: 0.9, depth: 1 },
      color: 0xFFB6C1,
      drops: ['pork'],
      dropCount: { min: 1, max: 3 }
    },
    sheep: {
      name: 'Ovelha',
      health: 8,
      size: { width: 1.2, height: 1.3, depth: 1.6 },
      color: 0xFFFFFF,
      drops: ['wool'],
      dropCount: { min: 1, max: 2 }
    }
  };

  const itemTypes = {
    ...blockTypes,
    leather: { color: 0x8B4513, name: 'Couro' },
    beef: { color: 0x8B0000, name: 'Carne Bovina' },
    pork: { color: 0xFFC0CB, name: 'Carne de Porco' },
    wool: { color: 0xFFFFFF, name: 'L√£' }
  };


  function createHealthUI() {
    const container = document.getElementById('health-container');
    for (let i = 0; i < MAX_HEALTH / 2; i++) {
      const heart = document.createElement('div');
      heart.className = 'heart';
      container.appendChild(heart);
    }
    updateHealthUI();
  }

  function updateHealthUI() {
    const hearts = document.querySelectorAll('.heart');
    hearts.forEach((heart, index) => {
      const heartIndex = index * 2;
      if (playerHealth >= heartIndex + 2) {
        heart.className = 'heart';
      } else if (playerHealth >= heartIndex + 1) {
        heart.className = 'heart half';
      } else {
        heart.className = 'heart empty';
      }
    });
  }

  function damagePlayer(amount) {
    playerHealth = Math.max(0, playerHealth - amount);
    updateHealthUI();

    // Verificar morte
    if (playerHealth <= 0) {
      playerHealth = MAX_HEALTH;
      camera.position.set(0, 25, 0);
      player.velocity.set(0, 0, 0);
      updateHealthUI();
    }
  }

  function healPlayer(amount) {
    playerHealth = Math.min(MAX_HEALTH, playerHealth + amount);
    updateHealthUI();
  }

  function initializeInventory() {
    // Blocos b√°sicos
    addToInventory('grass', 64);
    addToInventory('dirt', 64);
    addToInventory('stone', 32);
    addToInventory('wood', 32);
    addToInventory('planks', 32);

    // Blocos decorativos
    addToInventory('concrete_white', 16);
    addToInventory('concrete_blue', 16);
    addToInventory('brick', 16);
    addToInventory('quartz', 16);

    // Blocos luminosos
    addToInventory('glowstone', 16);
    addToInventory('lantern', 16);
    addToInventory('torch', 32);

    // Blocos funcionais
    addToInventory('crafting_table', 4);
    addToInventory('chest', 4);
    addToInventory('furnace', 2);

    player.selectedSlot = 0;
  }

  function createMaterialsWithEmissive() {
    for (let type in blockTypes) {
      const block = blockTypes[type];
      const texture = createTexture(type);

      if (block.emissive) {
        // Material emissivo para blocos que brilham
        materials[type] = new THREE.MeshBasicMaterial({
          map: texture,
          emissive: block.color,
          emissiveIntensity: 0.8
        });
      } else if (type === 'glass' || type === 'ice') {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });
      } else if (type === 'water') {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
      } else if (type === 'leaves') {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,
          opacity: 0.9,
          side: THREE.DoubleSide,
          alphaTest: 0.5
        });
      } else {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          flatShading: false // ‚úÖ Desativado para melhor apar√™ncia com texturas
        });
      }
    }
  }
  function createCoalOreTexture(ctx, size) {
    createStoneTexture(ctx, size);

    // Veios de carv√£o
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(52, 52, 52, 0.8)';
      ctx.fillRect(x, y, 6, 6);
    }
  }

  function createIronOreTexture(ctx, size) {
    createStoneTexture(ctx, size);

    // Manchas de ferro
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(216, 175, 147, 0.7)';
      ctx.fillRect(x, y, 8, 8);
    }
  }

  function createDiamondOreTexture(ctx, size) {
    createStoneTexture(ctx, size);

    // Cristais de diamante
    for (let i = 0; i < 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(0, 206, 209, 0.9)';
      ctx.fillRect(x, y, 6, 6);

      // Brilho
      ctx.fillStyle = 'rgba(100, 255, 255, 0.5)';
      ctx.fillRect(x + 2, y + 2, 2, 2);
    }
  }
  function addToInventory(type, count) {
    // Encontrar slot existente com o mesmo tipo
    for (let i = 0; i < player.inventory.length; i++) {
      if (player.inventory[i].type === type && player.inventory[i].count < 64) {
        const availableSpace = 64 - player.inventory[i].count;
        const toAdd = Math.min(count, availableSpace);
        player.inventory[i].count += toAdd;
        count -= toAdd;
        if (count <= 0) break;
      }
    }

    // Se ainda h√° itens, encontrar slot vazio
    if (count > 0) {
      for (let i = 0; i < player.inventory.length; i++) {
        if (player.inventory[i].count === 0) {
          player.inventory[i].type = type;
          player.inventory[i].count = Math.min(count, 64);
          count -= player.inventory[i].count;
          if (count <= 0) break;
        }
      }
    }

    updateInventoryUI();
    updateFullInventoryUI();
  }

  function removeFromInventory(slotIndex, count = 1) {
    if (slotIndex < 0 || slotIndex >= player.inventory.length) return false;
    if (player.inventory[slotIndex].count >= count) {
      player.inventory[slotIndex].count -= count;
      if (player.inventory[slotIndex].count <= 0) {
        player.inventory[slotIndex].type = null;
        player.inventory[slotIndex].count = 0;
      }
      updateInventoryUI();
      updateFullInventoryUI();
      return true;
    }
    return false;
  }

  function getSelectedItem() {
    const slot = player.inventory[player.selectedSlot];
    return slot.count > 0 ? slot.type : null;
  }

  function createInventoryUI() {
    const invBar = document.getElementById('inventory-bar');
    invBar.innerHTML = '';

    for (let i = 0; i < player.hotbarSlots; i++) {
      const slot = document.createElement('div');
      slot.className = `inv-slot ${i === player.selectedSlot ? 'active' : ''}`;
      slot.dataset.index = i;

      const slotData = player.inventory[i];
      if (slotData.count > 0) {
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div class="block-icon" style="background: #${colorHex}"></div>
                    <div class="slot-count">${slotData.count}</div>
                `;
      }

      slot.onclick = () => selectSlot(i);
      invBar.appendChild(slot);
    }
  }

  function createFullInventoryUI() {
    const invFull = document.getElementById('inventory-full');
    invFull.innerHTML = '';

    for (let i = 0; i < player.inventorySlots; i++) {
      const slot = document.createElement('div');
      slot.className = 'inv-full-slot';
      slot.dataset.index = i;

      const slotData = player.inventory[i];
      if (slotData.count > 0) {
        slot.classList.add('has-item');
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div style="width: 35px; height: 35px; background: #${colorHex}; border-radius: 3px;"></div>
                    <div style="position: absolute; bottom: 2px; right: 5px; font-size: 10px; color: white;">${slotData.count}</div>
                `;
      }

      invFull.appendChild(slot);
    }
  }

  function updateInventoryUI() {
    const slots = document.querySelectorAll('#inventory-bar .inv-slot');
    slots.forEach((slot, i) => {
      const slotData = player.inventory[i];
      slot.classList.toggle('active', i === player.selectedSlot);

      if (slotData.count > 0) {
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div class="block-icon" style="background: #${colorHex}"></div>
                    <div class="slot-count">${slotData.count}</div>
                `;
      } else {
        slot.innerHTML = '';
      }
    });

    const selectedItem = getSelectedItem();
    document.getElementById('selected-block').textContent = selectedItem ? itemTypes[selectedItem].name : 'Vazio';
  }

  function updateFullInventoryUI() {
    const slots = document.querySelectorAll('#inventory-full .inv-full-slot');
    slots.forEach((slot, i) => {
      const slotData = player.inventory[i];
      slot.innerHTML = '';

      if (slotData.count > 0) {
        slot.classList.add('has-item');
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div style="width: 35px; height: 35px; background: #${colorHex}; border-radius: 3px;"></div>
                    <div style="position: absolute; bottom: 2px; right: 5px; font-size: 10px; color: white;">${slotData.count}</div>
                `;
      } else {
        slot.classList.remove('has-item');
      }
    });
  }

  function selectSlot(index) {
    if (index >= 0 && index < player.hotbarSlots) {
      player.selectedSlot = index;
      updateInventoryUI();
    }
  }

  function toggleFullInventory() {
    const invFull = document.getElementById('inventory-full');
    invFull.classList.toggle('open');
    controls.locked = !invFull.classList.contains('open');

    if (invFull.classList.contains('open')) {
      document.exitPointerLock();
      updateFullInventoryUI();
    } else {
      renderer.domElement.requestPointerLock();
    }
  }

  function getHeight(x, z) {
    const n1 = noise(x * 0.04, z * 0.04) * 10;
    const n2 = noise(x * 0.08, z * 0.08) * 5;
    const n3 = noise(x * 0.15, z * 0.15) * 2;
    return Math.floor(12 + n1 + n2 + n3);
  }

  function getBlockKey(x, y, z) {
    return `${x},${y},${z}`;
  }

  function getChunkKey(cx, cz) {
    return `${cx},${cz}`;
  }

  function worldToChunk(x, z) {
    return {
      x: Math.floor(x / CHUNK_SIZE),
      z: Math.floor(z / CHUNK_SIZE)
    };
  }

  function setBlock(x, y, z, type) {
    worldData[getBlockKey(x, y, z)] = { x, y, z, type };
  }

  function getBlock(x, y, z) {
    return worldData[getBlockKey(x, y, z)];
  }

  function removeBlockData(x, y, z) {
    delete worldData[getBlockKey(x, y, z)];
  }

  function removeAnimalsInChunk(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;
    const ex = sx + CHUNK_SIZE;
    const ez = sz + CHUNK_SIZE;

    for (let i = animals.length - 1; i >= 0; i--) {
      const animal = animals[i];
      if (animal.x >= sx && animal.x < ex && animal.z >= sz && animal.z < ez) {
        animal.remove();
        animals.splice(i, 1);
      }
    }
  }

  function buildChunkMesh(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);

    if (chunkMeshes[chunkKey]) {
      scene.remove(chunkMeshes[chunkKey]);
      chunkMeshes[chunkKey].children.forEach(child => {
        child.geometry.dispose();
      });
      delete chunkMeshes[chunkKey];
    }

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    const geometriesByType = {};

    for (let type in blockTypes) {
      geometriesByType[type] = {
        positions: [],
        normals: [],
        indices: [],
        vertexCount: 0
      };
    }

    let totalFaces = 0;

    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
      for (let lz = 0; lz < CHUNK_SIZE; lz++) {
        for (let y = 0; y < 40; y++) {
          const x = sx + lx;
          const z = sz + lz;
          const block = getBlock(x, y, z);

          if (!block) continue;

          const geo = geometriesByType[block.type];

          const faces = [
            { dir: [1, 0, 0], corners: [[1, 0, 0], [1, 1, 0], [1, 1, 1], [1, 0, 1]] },
            { dir: [-1, 0, 0], corners: [[0, 0, 1], [0, 1, 1], [0, 1, 0], [0, 0, 0]] },
            { dir: [0, 1, 0], corners: [[0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 1, 0]] },
            { dir: [0, -1, 0], corners: [[0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 0, 1]] },
            { dir: [0, 0, 1], corners: [[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]] },
            { dir: [0, 0, -1], corners: [[1, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0]] }
          ];

          for (let face of faces) {
            const [dx, dy, dz] = face.dir;
            const neighbor = getBlock(x + dx, y + dy, z + dz);

            if (!neighbor) {
              const baseIdx = geo.vertexCount;

              for (let corner of face.corners) {
                geo.positions.push(
                        x + corner[0] - 0.5,
                        y + corner[1] - 0.5,
                        z + corner[2] - 0.5
                );
                geo.normals.push(dx, dy, dz);
              }

              geo.indices.push(
                      baseIdx, baseIdx + 1, baseIdx + 2,
                      baseIdx, baseIdx + 2, baseIdx + 3
              );

              geo.vertexCount += 4;
              totalFaces++;
            }
          }
        }
      }
    }

    const group = new THREE.Group();

    for (let type in geometriesByType) {
      const geo = geometriesByType[type];

      if (geo.positions.length === 0) continue;

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(geo.positions, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(geo.normals, 3));
      geometry.setIndex(geo.indices);

      const mesh = new THREE.Mesh(geometry, materials[type]);
      mesh.userData.chunkKey = chunkKey;
      mesh.userData.type = type;
      group.add(mesh);
    }

    if (group.children.length > 0) {
      scene.add(group);
      chunkMeshes[chunkKey] = group;
      chunkMeshes[chunkKey].userData.faceCount = totalFaces;
    }

    return totalFaces;
  }

  function updateVisibleChunks() {
    const px = camera.position.x;
    const pz = camera.position.z;
    const chunk = worldToChunk(px, pz);

    const chunksToGenerate = [];
    const chunksToMesh = [];

    for (let cx = chunk.x - RENDER_DISTANCE; cx <= chunk.x + RENDER_DISTANCE; cx++) {
      for (let cz = chunk.z - RENDER_DISTANCE; cz <= chunk.z + RENDER_DISTANCE; cz++) {
        const chunkKey = getChunkKey(cx, cz);

        if (!chunks[chunkKey]) {
          chunksToGenerate.push([cx, cz]);
        } else if (!chunkMeshes[chunkKey]) {
          chunksToMesh.push([cx, cz]);
        }
      }
    }

    chunksToGenerate.forEach(([cx, cz]) => {
      generateChunk(cx, cz);
      spawnAnimals(cx, cz);
      spawnEnemies(cx, cz); // ‚úÖ ADICIONAR ESTA LINHA
    });

    chunksToMesh.forEach(([cx, cz]) => buildChunkMesh(cx, cz));

    const chunksToRemove = [];
    for (let key in chunkMeshes) {
      const [cx, cz] = key.split(',').map(Number);
      const dx = Math.abs(cx - chunk.x);
      const dz = Math.abs(cz - chunk.z);

      if (dx > RENDER_DISTANCE || dz > RENDER_DISTANCE) {
        chunksToRemove.push(key);
      }
    }

    chunksToRemove.forEach(key => {
      const [cx, cz] = key.split(',').map(Number);
      scene.remove(chunkMeshes[key]);
      chunkMeshes[key].children.forEach(child => {
        child.geometry.dispose();
      });
      delete chunkMeshes[key];
      removeAnimalsInChunk(cx, cz);
      removeEnemiesInChunk(cx, cz); // ‚úÖ ADICIONAR ESTA LINHA
    });

    updateFaceCount();
  }

  function removeEnemiesInChunk(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;
    const ex = sx + CHUNK_SIZE;
    const ez = sz + CHUNK_SIZE;

    for (let i = enemies.length - 1; i >= 0; i--) {
      const enemy = enemies[i];
      if (enemy.x >= sx && enemy.x < ex && enemy.z >= sz && enemy.z < ez) {
        enemy.remove();
        enemies.splice(i, 1);
      }
    }
  }
  function updateFaceCount() {
    let totalFaces = 0;
    for (let key in chunkMeshes) {
      if (chunkMeshes[key].userData.faceCount) {
        totalFaces += chunkMeshes[key].userData.faceCount;
      }
    }
    document.getElementById('visible').textContent = totalFaces;
  }

  function createBreakAnimation(block) {
    const particles = [];
    const color = blockTypes[block.type] ? blockTypes[block.type].color : 0xFFFFFF;

    for (let i = 0; i < 6; i++) {
      const p = new THREE.Mesh(
              new THREE.BoxGeometry(0.12, 0.12, 0.12),
              new THREE.MeshBasicMaterial({ color, transparent: true })
      );

      p.position.set(
              block.x + (Math.random() - 0.5) * 0.4,
              block.y + (Math.random() - 0.5) * 0.4,
              block.z + (Math.random() - 0.5) * 0.4
      );

      p.velocity = new THREE.Vector3(
              (Math.random() - 0.5) * 0.08,
              Math.random() * 0.12,
              (Math.random() - 0.5) * 0.08
      );

      scene.add(p);
      particles.push(p);
    }

    breakingAnimations.push({ particles, created: Date.now() });
  }

  function updateBreakAnimations() {
    const now = Date.now();
    breakingAnimations = breakingAnimations.filter(anim => {
      const age = now - anim.created;
      if (age > 400) {
        anim.particles.forEach(p => {
          scene.remove(p);
          p.geometry.dispose();
          p.material.dispose();
        });
        return false;
      }

      anim.particles.forEach(p => {
        p.velocity.y -= 0.01;
        p.position.add(p.velocity);
        p.material.opacity = 1 - (age / 400);
      });

      return true;
    });
  }

  function setupEventListeners() {
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;

      // Selecionar slots 1-9
      if (e.code >= 'Digit1' && e.code <= 'Digit9') {
        const idx = parseInt(e.code.slice(-1)) - 1;
        if (idx < player.hotbarSlots) selectSlot(idx);
      }

      // Modo voo
      if (e.code === 'KeyF') {
        player.flying = !player.flying;
        document.getElementById('mode').textContent = player.flying ? 'Voo' : 'Normal';
      }

      // Invent√°rio completo
      if (e.code === 'KeyE') {
        toggleFullInventory();
      }

      // Jogar item
      if (e.code === 'KeyQ' && !document.getElementById('inventory-full').classList.contains('open')) {
        const selectedItem = getSelectedItem();
        if (selectedItem && removeFromInventory(player.selectedSlot, 1)) {
          // Criar entidade do item jogado
          const itemMesh = new THREE.Mesh(
                  new THREE.BoxGeometry(0.3, 0.3, 0.3),
                  new THREE.MeshLambertMaterial({ color: itemTypes[selectedItem].color })
          );
          itemMesh.position.copy(camera.position);
          itemMesh.velocity = new THREE.Vector3(
                  camera.getWorldDirection(new THREE.Vector3()).x * 0.5,
                  0.3,
                  camera.getWorldDirection(new THREE.Vector3()).z * 0.5
          );
          scene.add(itemMesh);

          // Remover ap√≥s 5 segundos
          setTimeout(() => {
            if (itemMesh.parent) {
              scene.remove(itemMesh);
            }
          }, 5000);
        }
      }

      // Reproduzir animais (debug)
      if (e.code === 'KeyR') {
        const chunk = worldToChunk(camera.position.x, camera.position.z);
        spawnAnimals(chunk.x, chunk.z);
      }
    });

    document.addEventListener('keyup', (e) => keys[e.code] = false);

    document.addEventListener('mousemove', (e) => {
      if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;

      // Corre√ß√£o: Controles desinvertidos - movimento do mouse mais suave
      mouse.x -= e.movementX * 0.002; // Invertido o sinal para desinverter
      mouse.y -= e.movementY * 0.002; // Mantido para controle vertical normal

      mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
    });

    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('wheel', handleScroll);
    document.addEventListener('contextmenu', (e) => e.preventDefault());
    window.addEventListener('resize', onWindowResize);

    document.addEventListener('pointerlockchange', () => {
      controls.locked = document.pointerLockElement === renderer.domElement;
    });
  }

  function handleInventoryScroll(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;
    if (mobileControls.enabled) return; // Desabilitar scroll em mobile

    e.preventDefault();
    const dir = e.deltaY > 0 ? 1 : -1;
    const newSlot = (player.selectedSlot + dir + player.hotbarSlots) % player.hotbarSlots;
    selectSlot(newSlot);
  }

  document.addEventListener('wheel', handleInventoryScroll);

  function handleMouseDown(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;

    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

    // Verificar colis√£o com animais primeiro
    const animalIntersects = raycaster.intersectObjects(animalMeshes);
    if (animalIntersects.length > 0 && e.button === 0) {
      const animalMesh = animalIntersects[0].object;
      const animal = animals.find(a => a.mesh === animalMesh);
      if (animal) {
        if (animal.damage(1)) {
          // Animal morto
          damagePlayer(1); // Dano ao jogador por matar animal
        }
      }
      return;
    }

    // Verificar colis√£o com blocos
    const allMeshes = [];
    for (let key in chunkMeshes) {
      allMeshes.push(...chunkMeshes[key].children);
    }

    const intersects = raycaster.intersectObjects(allMeshes);
    if (intersects.length === 0) return;

    const hit = intersects[0];
    const hitPos = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(-0.1));
    const bx = Math.round(hitPos.x);
    const by = Math.round(hitPos.y);
    const bz = Math.round(hitPos.z);

    if (e.button === 0) {
      const block = getBlock(bx, by, bz);
      if (block && block.type !== 'bedrock') {
        player.breaking = { x: bx, y: by, z: bz };
        player.breakStartTime = Date.now();
        player.breakBlockType = block.type;

        // Mostrar barra de progresso
        const progressBar = document.getElementById('break-progress');
        progressBar.style.display = 'block';
      }
    } else if (e.button === 2) {
      const placePos = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(0.5));
      const px = Math.round(placePos.x);
      const py = Math.round(placePos.y);
      const pz = Math.round(placePos.z);

      const selectedItem = getSelectedItem();
      if (selectedItem && blockTypes[selectedItem]) {
        placeBlock(px, py, pz, selectedItem);
      }
    }
  }

  function handleMouseUp(e) {
    if (e.button === 0) {
      player.breaking = null;
      player.breakProgress = 0;
      document.getElementById('break-progress').style.display = 'none';
    }
  }

  function updateBreaking() {
    if (player.breaking) {
      const block = getBlock(player.breaking.x, player.breaking.y, player.breaking.z);
      if (!block || block.type !== player.breakBlockType) {
        player.breaking = null;
        document.getElementById('break-progress').style.display = 'none';
        return;
      }

      const hardness = blockTypes[block.type].hardness;
      const elapsed = Date.now() - player.breakStartTime;
      player.breakProgress = elapsed / (BREAK_TIME * hardness);

      // Atualizar barra de progresso
      const progressFill = document.querySelector('.break-progress-fill');
      progressFill.style.width = `${Math.min(player.breakProgress * 100, 100)}%`;

      if (player.breakProgress >= 1) {
        removeBlock(player.breaking.x, player.breaking.y, player.breaking.z);
        player.breaking = null;
        player.breakProgress = 0;
        document.getElementById('break-progress').style.display = 'none';
      }
    }
  }

  function handleScroll(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;
    e.preventDefault();
    const dir = e.deltaY > 0 ? 1 : -1;
    const newSlot = (player.selectedSlot + dir + player.hotbarSlots) % player.hotbarSlots;
    selectSlot(newSlot);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }


  function playAnimalSound(type) {
    // Esta fun√ß√£o pode ser expandida para adicionar sons
    console.log(`${type} fez barulho!`);
  }

  function checkAnimalCollision(position) {
    for (const animal of animals) {
      if (animal.boundingBox) {
        const playerBox = new THREE.Box3(
                new THREE.Vector3(position.x - 0.3, position.y - 1.8, position.z - 0.3),
                new THREE.Vector3(position.x + 0.3, position.y + 0.2, position.z + 0.3)
        );

        if (animal.boundingBox.intersectsBox(playerBox)) {
          return animal;
        }
      }
    }
    return null;
  }


  class Animal {
    constructor(type, x, y, z) {
      this.type = type;
      this.x = x;
      this.y = y;
      this.z = z;
      this.health = animalTypes[type].health;
      this.targetX = x;
      this.targetZ = z;
      this.speed = 0.02;
      this.moveTimer = 0;
      this.idleTimer = 0;
      this.mesh = null; // Inicializar como null
      this.direction = new THREE.Vector3(0, 0, 1);
      this.velocity = new THREE.Vector3();
      this.isMoving = false;
      this.headRotation = 0;
      this.legRotation = 0;
      this.animationTime = 0;
      this.boundingBox = null;

      // Criar o mesh imediatamente
      this.createMesh();
    }

    // Fun√ß√µes de cria√ß√£o de geometria espec√≠fica para cada animal
    createCowMesh() {
      const group = new THREE.Group();

      // Corpo principal
      const bodyGeometry = new THREE.BoxGeometry(1, 0.8, 1.5);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.7;
      group.add(body);

      // Cabe√ßa
      const headGeometry = new THREE.BoxGeometry(0.7, 0.6, 0.7);
      const headMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.set(0, 0.9, 0.9);
      group.add(head);

      // Focinho
      const snoutGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.4);
      const snoutMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
      const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
      snout.position.set(0, 0.8, 1.25);
      group.add(snout);

      // Chifres
      const hornGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 6);
      const hornMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
      const horn1 = new THREE.Mesh(hornGeometry, hornMaterial);
      horn1.position.set(0.3, 1.2, 1);
      horn1.rotation.x = Math.PI / 2;
      group.add(horn1);

      const horn2 = new THREE.Mesh(hornGeometry, hornMaterial);
      horn2.position.set(-0.3, 1.2, 1);
      horn2.rotation.x = Math.PI / 2;
      group.add(horn2);

      // Orelhas
      const earGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.15);
      const earMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const ear1 = new THREE.Mesh(earGeometry, earMaterial);
      ear1.position.set(0.35, 1.1, 0.7);
      ear1.rotation.z = Math.PI / 6;
      group.add(ear1);

      const ear2 = new THREE.Mesh(earGeometry, earMaterial);
      ear2.position.set(-0.35, 1.1, 0.7);
      ear2.rotation.z = -Math.PI / 6;
      group.add(ear2);

      // Pernas
      const legGeometry = new THREE.BoxGeometry(0.25, 0.8, 0.25);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });

      const legPositions = [
        { x: 0.35, y: 0.4, z: 0.5 },
        { x: -0.35, y: 0.4, z: 0.5 },
        { x: 0.35, y: 0.4, z: -0.5 },
        { x: -0.35, y: 0.4, z: -0.5 }
      ];

      legPositions.forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        leg.position.set(pos.x, pos.y, pos.z);
        leg.userData.originalY = pos.y;
        leg.userData.isLeg = true;
        group.add(leg);
      });

      // Cauda
      const tailGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.4, 6);
      const tailMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const tail = new THREE.Mesh(tailGeometry, tailMaterial);
      tail.position.set(0, 1, -0.8);
      tail.rotation.x = Math.PI / 4;
      group.add(tail);

      return group;
    }

    createPigMesh() {
      const group = new THREE.Group();

      // Corpo principal (esf√©rico)
      const bodyGeometry = new THREE.SphereGeometry(0.6, 8, 8);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.scale.set(1.3, 1, 1);
      body.position.y = 0.7;
      group.add(body);

      // Cabe√ßa
      const headGeometry = new THREE.BoxGeometry(0.6, 0.5, 0.6);
      const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.set(0, 0.8, 0.8);
      group.add(head);

      // Focinho
      const snoutGeometry = new THREE.BoxGeometry(0.4, 0.25, 0.3);
      const snoutMaterial = new THREE.MeshLambertMaterial({ color: 0xFF9999 });
      const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
      snout.position.set(0, 0.75, 1.1);
      group.add(snout);

      // Orelhas
      const earGeometry = new THREE.BoxGeometry(0.2, 0.15, 0.1);
      const earMaterial = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const ear1 = new THREE.Mesh(earGeometry, earMaterial);
      ear1.position.set(0.3, 1.1, 0.7);
      ear1.rotation.z = Math.PI / 4;
      group.add(ear1);

      const ear2 = new THREE.Mesh(earGeometry, earMaterial);
      ear2.position.set(-0.3, 1.1, 0.7);
      ear2.rotation.z = -Math.PI / 4;
      group.add(ear2);

      // Pernas curtas
      const legGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.2);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });

      const legPositions = [
        { x: 0.4, y: 0.25, z: 0.4 },
        { x: -0.4, y: 0.25, z: 0.4 },
        { x: 0.4, y: 0.25, z: -0.4 },
        { x: -0.4, y: 0.25, z: -0.4 }
      ];

      legPositions.forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        leg.position.set(pos.x, pos.y, pos.z);
        leg.userData.originalY = pos.y;
        leg.userData.isLeg = true;
        group.add(leg);
      });

      // Rabinho encaracolado
      const tailGeometry = new THREE.TorusGeometry(0.1, 0.03, 8, 16, Math.PI);
      const tailMaterial = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const tail = new THREE.Mesh(tailGeometry, tailMaterial);
      tail.position.set(0, 0.8, -0.8);
      tail.rotation.y = Math.PI / 2;
      group.add(tail);

      return group;
    }

    createSheepMesh() {
      const group = new THREE.Group();

      // Corpo principal (fofinho com blocos extras para simular l√£)
      const bodyGeometry = new THREE.BoxGeometry(1.2, 0.9, 1.6);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.8;
      group.add(body);

      // Blocos extras para dar volume √† l√£
      const woolGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.4);
      const woolMaterial = new THREE.MeshLambertMaterial({ color: 0xF8F8F8 });

      const woolPositions = [
        { x: 0.3, y: 1.2, z: 0.3 },
        { x: -0.3, y: 1.2, z: 0.3 },
        { x: 0.3, y: 1.2, z: -0.3 },
        { x: -0.3, y: 1.2, z: -0.3 },
        { x: 0, y: 1.2, z: 0 }
      ];

      woolPositions.forEach(pos => {
        const wool = new THREE.Mesh(woolGeometry, woolMaterial);
        wool.position.set(pos.x, pos.y, pos.z);
        group.add(wool);
      });

      // Cabe√ßa
      const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
      const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.set(0, 0.9, 1.1);
      group.add(head);

      // Orelhas
      const earGeometry = new THREE.BoxGeometry(0.15, 0.25, 0.08);
      const earMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDAB9 });
      const ear1 = new THREE.Mesh(earGeometry, earMaterial);
      ear1.position.set(0.25, 1.1, 1);
      ear1.rotation.z = Math.PI / 6;
      group.add(ear1);

      const ear2 = new THREE.Mesh(earGeometry, earMaterial);
      ear2.position.set(-0.25, 1.1, 1);
      ear2.rotation.z = -Math.PI / 6;
      group.add(ear2);

      // Pernas
      const legGeometry = new THREE.BoxGeometry(0.25, 0.8, 0.25);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });

      const legPositions = [
        { x: 0.4, y: 0.4, z: 0.6 },
        { x: -0.4, y: 0.4, z: 0.6 },
        { x: 0.4, y: 0.4, z: -0.6 },
        { x: -0.4, y: 0.4, z: -0.6 }
      ];

      legPositions.forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        leg.position.set(pos.x, pos.y, pos.z);
        leg.userData.originalY = pos.y;
        leg.userData.isLeg = true;
        group.add(leg);
      });

      // Olhos
      const eyeGeometry = new THREE.SphereGeometry(0.05, 6, 6);
      const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
      const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
      eye1.position.set(0.2, 0.95, 1.35);
      group.add(eye1);

      const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
      eye2.position.set(-0.2, 0.95, 1.35);
      group.add(eye2);

      return group;
    }

    createMesh() {

      const group = new THREE.Group();

      // Cores por profiss√£o
      const professionColors = {
        farmer: 0x8B4513,
        librarian: 0xFFFFFF,
        blacksmith: 0x696969,
        priest: 0x800080,
        butcher: 0xFFEBCD,
        fisherman: 0x4682B4,  // NOVO
        shepherd: 0x90EE90,   // NOVO
        fletcher: 0xD2691E,   // NOVO
        cartographer: 0xFFD700 // NOVO
      };

      const color = professionColors[this.profession] || 0x8B4513;

      switch(this.type) {
        case 'cow':
          this.mesh = this.createCowMesh();
          break;
        case 'pig':
          this.mesh = this.createPigMesh();
          break;
        case 'sheep':
          this.mesh = this.createSheepMesh();
          break;
        default:
          const animalType = animalTypes[this.type];
          const geometry = new THREE.BoxGeometry(
                  animalType.size.width,
                  animalType.size.height,
                  animalType.size.depth
          );
          const material = new THREE.MeshLambertMaterial({ color: animalType.color });
          this.mesh = new THREE.Mesh(geometry, material);
      }

      this.mesh.position.set(this.x, this.y, this.z);
      scene.add(this.mesh);
      animalMeshes.push(this.mesh);

      // Adicionar bounding box para colis√£o
      this.boundingBox = new THREE.Box3().setFromObject(this.mesh);
    }

    update() {
      this.moveTimer++;
      this.idleTimer++;
      this.animationTime += 0.1;

      // Movimento aleat√≥rio
      if (this.moveTimer > 120 && Math.random() < 0.01) {
        this.isMoving = true;
        this.targetX = this.x + (Math.random() - 0.5) * 8;
        this.targetZ = this.z + (Math.random() - 0.5) * 8;
        this.moveTimer = 0;
        this.idleTimer = 0;
      }

      // Parar ap√≥s certo tempo
      if (this.idleTimer > 60) {
        this.isMoving = false;
      }

      // Movimento em dire√ß√£o ao alvo
      if (this.isMoving) {
        const dx = this.targetX - this.x;
        const dz = this.targetZ - this.z;
        const distance = Math.sqrt(dx * dx + dz * dz);

        if (distance > 0.5) {
          this.x += (dx / distance) * this.speed;
          this.z += (dz / distance) * this.speed;

          // Verificar colis√£o com blocos
          const blockBelow = getBlock(Math.floor(this.x), Math.floor(this.y - 1), Math.floor(this.z));
          if (!blockBelow) {
            this.isMoving = false;
            this.y -= 1;
          }

          // Atualizar dire√ß√£o
          this.direction.set(dx, 0, dz).normalize();

          // Animar pernas
          this.animateLegs();
        } else {
          this.isMoving = false;
        }
      }

      // Anima√ß√£o de respira√ß√£o suave
      this.animateBreathing();

      // Anima√ß√£o de cabe√ßa (olhar ao redor)
      this.animateHead();

      // Atualizar posi√ß√£o e rota√ß√£o do mesh
      if (this.mesh) {
        this.mesh.position.set(this.x, this.y, this.z);

        // Rota√ß√£o suave na dire√ß√£o do movimento
        if (this.isMoving) {
          const targetRotation = Math.atan2(-this.direction.x, -this.direction.z);
          this.mesh.rotation.y += (targetRotation - this.mesh.rotation.y) * 0.1;
        }

        // Atualizar bounding box
        if (this.boundingBox) {
          this.boundingBox.setFromObject(this.mesh);
        }
      }
    }

    animateLegs() {
      if (!this.mesh) return;

      this.mesh.traverse(child => {
        if (child.userData && child.userData.isLeg) {
          const legMove = Math.sin(this.animationTime * 8) * 0.1;
          child.position.y = child.userData.originalY + legMove;
        }
      });
    }

    animateBreathing() {
      if (!this.mesh) return;

      const breathScale = 1 + Math.sin(this.animationTime * 2) * 0.01;
      this.mesh.scale.set(breathScale, breathScale, breathScale);
    }

    animateHead() {
      if (!this.mesh) return;

      // Animar cabe√ßa para parecer que est√° olhando ao redor
      this.headRotation = Math.sin(this.animationTime * 0.5) * 0.3;

      // Encontrar a cabe√ßa no grupo (assumindo que √© o segundo filho)
      if (this.mesh.children.length > 1) {
        const head = this.mesh.children[1];
        head.rotation.y = this.headRotation;
      }
    }

    remove() {
      if (this.mesh) {
        // Limpar todos os filhos do mesh
        this.mesh.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => mat.dispose());
            } else {
              child.material.dispose();
            }
          }
        });

        scene.remove(this.mesh);
        const index = animalMeshes.indexOf(this.mesh);
        if (index > -1) animalMeshes.splice(index, 1);
      }
    }

    damage(amount) {
      this.health -= amount;

      // Efeito visual de dano (piscar vermelho)
      if (this.mesh) {
        this.mesh.traverse(child => {
          if (child.material) {
            const originalColor = child.material.color.clone();
            child.material.color.set(0xFF0000);

            setTimeout(() => {
              if (child.material) {
                child.material.color.copy(originalColor);
              }
            }, 100);
          }
        });
      }

      if (this.health <= 0) {
        this.dropItems();
        this.remove();
        const animalIndex = animals.indexOf(this);
        if (animalIndex > -1) animals.splice(animalIndex, 1);
        return true;
      }
      return false;
    }

    dropItems() {
      const animalType = animalTypes[this.type];
      animalType.drops.forEach(drop => {
        const count = Math.floor(Math.random() *
                (animalType.dropCount.max - animalType.dropCount.min + 1)) + animalType.dropCount.min;
        addToInventory(drop, count);
      });
    }
  }

  function updateAnimals() {
    animals.forEach(animal => {
      if (animal.update) {
        animal.update();
      }
    });
    document.getElementById('animals-count').textContent = animals.length;
  }

  function spawnAnimals(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;

    // Gerar animais com base na biome
    const biome = hash(chunkX * 0.1, chunkZ * 0.1);
    let animalCount = 0;

    if (biome > 0.7) {
      animalCount = Math.floor(Math.random() * 2) + 1; // Menos animais em biomas extremos
    } else {
      animalCount = Math.floor(Math.random() * 4) + 2; // Mais animais em biomas normais
    }

    for (let i = 0; i < animalCount; i++) {
      const x = sx + Math.random() * CHUNK_SIZE;
      const z = sz + Math.random() * CHUNK_SIZE;
      const y = getHeight(x, z) + 1;

      // Verificar se o bloco abaixo √© grama ou terra
      const blockBelow = getBlock(Math.floor(x), Math.floor(y - 1), Math.floor(z));
      if (blockBelow && (blockBelow.type === 'grass' || blockBelow.type === 'dirt')) {
        let type;

        // Escolher tipo de animal baseado no biome
        if (biome > 0.85) {
          type = Math.random() > 0.5 ? 'sheep' : 'cow'; // Mais ovelhas em biomas frios
        } else if (biome > 0.7) {
          type = 'pig'; // Apenas porcos em biomas quentes
        } else {
          const rand = Math.random();
          type = rand < 0.4 ? 'cow' : rand < 0.7 ? 'pig' : 'sheep';
        }

        const animal = new Animal(type, x, y, z);
        animals.push(animal);
      }
    }
  }


  // Adicionar estas constantes no in√≠cio
  const PLAYER_WIDTH = 0.6;
  const PLAYER_HEIGHT = 1.8;
  const PLAYER_EYE_HEIGHT = 1.6;
  const COLLISION_TOLERANCE = 0.01;

  // Atualizar a fun√ß√£o updatePlayer para incluir colis√£o completa
  function updatePlayer() {
    const dir = new THREE.Vector3();
    const right = new THREE.Vector3();

    camera.getWorldDirection(dir);
    dir.y = 0;
    dir.normalize();
    // CORRE√á√ÉO: Vetor right calculado corretamente para controles padr√£o
    right.crossVectors(dir, camera.up).normalize();

    const speed = keys['ShiftLeft'] ? SPRINT_SPEED : (player.flying ? FLY_SPEED : MOVE_SPEED);

    // Calcular movimento desejado - CORRE√á√ÉO DOS CONTROLES
    const move = new THREE.Vector3();
    if (keys['KeyW']) move.add(dir);
    if (keys['KeyS']) move.add(dir.clone().negate());
    if (keys['KeyA']) move.add(right.clone().negate()); // CORRE√á√ÉO: Movimento para esquerda
    if (keys['KeyD']) move.add(right); // CORRE√á√ÉO: Movimento para direita

    if (move.length() > 0) {
      move.normalize().multiplyScalar(speed);
    }

    // Aplicar gravidade se n√£o estiver voando
    if (!player.flying) {
      player.velocity.y += GRAVITY;
      move.y = player.velocity.y;
    } else {
      if (keys['Space']) move.y = FLY_SPEED;
      if (keys['ShiftLeft']) move.y = -FLY_SPEED;
      player.velocity.y = 0;
    }

    // Detectar colis√µes e ajustar movimento
    const newPos = camera.position.clone().add(move);
    const collision = checkCollision(newPos);

    // Colis√£o lateral
    if (collision.sides) {
      // Projetar movimento no plano XZ para evitar paredes
      const lateralMove = new THREE.Vector3(move.x, 0, move.z);

      // Testar movimento apenas em X
      const testX = new THREE.Vector3(camera.position.x + move.x, camera.position.y, camera.position.z);
      if (!checkCollision(testX).sides) {
        camera.position.x = testX.x;
        move.x = 0;
      }

      // Testar movimento apenas em Z
      const testZ = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z + move.z);
      if (!checkCollision(testZ).sides) {
        camera.position.z = testZ.z;
        move.z = 0;
      }

      // Se ainda houver colis√£o, tentar deslizar
      if (move.x !== 0 || move.z !== 0) {
        const slideMove = new THREE.Vector3(move.x, 0, move.z);
        slideMove.normalize().multiplyScalar(speed * 0.5);

        const testSlide = new THREE.Vector3(
                camera.position.x + slideMove.x,
                camera.position.y,
                camera.position.z + slideMove.z
        );

        if (!checkCollision(testSlide).sides) {
          camera.position.x = testSlide.x;
          camera.position.z = testSlide.z;
        }
      }
    } else {
      // Sem colis√£o lateral, mover normalmente
      camera.position.x += move.x;
      camera.position.z += move.z;
    }

    // Colis√£o vertical
    if (collision.ground) {
      // No ch√£o
      player.velocity.y = 0;
      player.canJump = true;

      // Ajustar posi√ß√£o para ficar exatamente em cima do bloco
      const groundY = Math.floor(newPos.y - PLAYER_HEIGHT/2) + 1 + PLAYER_HEIGHT/2;
      camera.position.y = groundY;

      // Pular
      if (keys['Space'] && player.canJump) {
        player.velocity.y = JUMP_SPEED;
        player.canJump = false;
      }
    } else if (collision.ceiling) {
      // Batendo no teto
      player.velocity.y = Math.min(player.velocity.y, 0);
      const ceilingY = Math.floor(newPos.y + PLAYER_HEIGHT/2) - COLLISION_TOLERANCE - PLAYER_HEIGHT/2;
      camera.position.y = ceilingY;
    } else {
      // No ar
      camera.position.y += move.y;
      player.canJump = false;
    }

    // Dano por queda
    if (player.velocity.y < -2.5 && !player.flying && collision.ground) {
      const fallDamage = Math.floor(Math.abs(player.velocity.y) - 2);
      if (fallDamage > 0) {
        damagePlayer(fallDamage);
      }
    }

    // Atualizar rota√ß√£o da c√¢mera
    camera.rotation.order = 'YXZ';
    camera.rotation.y = mouse.x;
    camera.rotation.x = mouse.y;

    // Atualizar chunks
    const chunk = worldToChunk(camera.position.x, camera.position.z);
    if (chunk.x !== player.lastChunk.x || chunk.z !== player.lastChunk.z) {
      player.lastChunk = chunk;
      updateVisibleChunks();
    }
  }

  // Fun√ß√£o de verifica√ß√£o de colis√£o melhorada
  function checkCollision(position) {
    const result = {
      sides: false,
      ground: false,
      ceiling: false
    };

    // Definir pontos de teste para o jogador
    const playerMinY = position.y - PLAYER_HEIGHT/2;
    const playerMaxY = position.y + PLAYER_HEIGHT/2;
    const playerRadius = PLAYER_WIDTH/2;

    // Testar colis√£o com o ch√£o
    const groundTestPoints = [
      new THREE.Vector3(position.x, playerMinY - COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x + playerRadius, playerMinY - COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x - playerRadius, playerMinY - COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x, playerMinY - COLLISION_TOLERANCE, position.z + playerRadius),
      new THREE.Vector3(position.x, playerMinY - COLLISION_TOLERANCE, position.z - playerRadius)
    ];

    for (const point of groundTestPoints) {
      const block = getBlock(
              Math.floor(point.x),
              Math.floor(point.y),
              Math.floor(point.z)
      );
      if (block && block.type !== 'leaves' && block.type !== 'glass') {
        result.ground = true;
        break;
      }
    }

    // Testar colis√£o com o teto
    const ceilingTestPoints = [
      new THREE.Vector3(position.x, playerMaxY + COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x + playerRadius, playerMaxY + COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x - playerRadius, playerMaxY + COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x, playerMaxY + COLLISION_TOLERANCE, position.z + playerRadius),
      new THREE.Vector3(position.x, playerMaxY + COLLISION_TOLERANCE, position.z - playerRadius)
    ];

    for (const point of ceilingTestPoints) {
      const block = getBlock(
              Math.floor(point.x),
              Math.floor(point.y),
              Math.floor(point.z)
      );
      if (block && block.type !== 'leaves' && block.type !== 'glass') {
        result.ceiling = true;
        break;
      }
    }

    // Testar colis√£o lateral
    const sideTestPoints = [];
    const angles = [0, 45, 90, 135, 180, 225, 270, 315];

    for (const angle of angles) {
      const rad = angle * Math.PI / 180;
      const testPoint = new THREE.Vector3(
              position.x + Math.cos(rad) * playerRadius,
              position.y,
              position.z + Math.sin(rad) * playerRadius
      );
      sideTestPoints.push(testPoint);

      // Testar tamb√©m em diferentes alturas
      sideTestPoints.push(testPoint.clone().setY(position.y + PLAYER_HEIGHT/3));
      sideTestPoints.push(testPoint.clone().setY(position.y - PLAYER_HEIGHT/3));
    }

    for (const point of sideTestPoints) {
      const block = getBlock(
              Math.floor(point.x),
              Math.floor(point.y),
              Math.floor(point.z)
      );
      if (block && block.type !== 'leaves' && block.type !== 'glass') {
        result.sides = true;
        break;
      }
    }

    return result;
  }

  // Atualizar a fun√ß√£o de placeBlock para verificar colis√£o adequadamente
  function placeBlock(x, y, z, type) {
    if (getBlock(x, y, z)) return;

    // Verificar se o bloco est√° dentro do jogador
    const playerBox = new THREE.Box3(
            new THREE.Vector3(
                    camera.position.x - PLAYER_WIDTH/2,
                    camera.position.y - PLAYER_HEIGHT/2,
                    camera.position.z - PLAYER_WIDTH/2
            ),
            new THREE.Vector3(
                    camera.position.x + PLAYER_WIDTH/2,
                    camera.position.y + PLAYER_HEIGHT/2,
                    camera.position.z + PLAYER_WIDTH/2
            )
    );

    const blockBox = new THREE.Box3(
            new THREE.Vector3(x - 0.5, y - 0.5, z - 0.5),
            new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5)
    );

    if (playerBox.intersectsBox(blockBox)) return;

    // Verificar se tem o item no invent√°rio
    const selectedItem = getSelectedItem();
    if (selectedItem === type && removeFromInventory(player.selectedSlot, 1)) {
      setBlock(x, y, z, type);

      // Reconstruir chunks afetados
      const chunk = worldToChunk(x, z);
      const chunksToUpdate = new Set();
      chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

      const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
      const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

      if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
      if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
      if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
      if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

      chunksToUpdate.forEach(key => {
        const [cx, cz] = key.split(',').map(Number);
        if (chunkMeshes[key]) {
          buildChunkMesh(cx, cz);
        }
      });

      updateFaceCount();
    }
  }

  // Atualizar fun√ß√£o removeBlock para lidar com f√≠sica
  function removeBlock(x, y, z) {
    const block = getBlock(x, y, z);
    if (!block || block.type === 'bedrock') return;

    // Verificar se remover este bloco causaria queda do jogador
    const playerFeetY = Math.floor(camera.position.y - PLAYER_HEIGHT/2);
    const playerBlockX = Math.floor(camera.position.x);
    const playerBlockZ = Math.floor(camera.position.z);

    // Se o jogador est√° em cima deste bloco e n√£o h√° outro bloco abaixo
    if (playerBlockX === x && playerBlockZ === z && playerFeetY === y) {
      let hasSupport = false;
      for (let dy = 1; dy <= 3; dy++) {
        const belowBlock = getBlock(x, y - dy, z);
        if (belowBlock && belowBlock.type !== 'leaves' && belowBlock.type !== 'glass') {
          hasSupport = true;
          break;
        }
      }

      if (!hasSupport) {
        // O jogador cair√°, n√£o remover o bloco
        return;
      }
    }

    createBreakAnimation(block);
    addToInventory(block.type, 1);
    removeBlockData(x, y, z);

    // Reconstruir chunks
    const chunk = worldToChunk(x, z);
    const chunksToUpdate = new Set();
    chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

    const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

    if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
    if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
    if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
    if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

    chunksToUpdate.forEach(key => {
      const [cx, cz] = key.split(',').map(Number);
      if (chunkMeshes[key]) {
        buildChunkMesh(cx, cz);
      }
    });

    updateFaceCount();
  }










  // Fun√ß√£o auxiliar para gerar vegeta√ß√£o
  function generateVegetation(x, height, z, biome, specialFeature) {
    switch(specialFeature) {
      case 'spruce_trees':
        // √Årvores de taiga (pinheiros)
        const spruceHeight = Math.floor(Math.random() * 4) + 6;
        for (let i = 1; i <= spruceHeight; i++) {
          setBlock(x, height + i, z, 'wood');
        }

        // Copa c√¥nica
        for (let dy = 0; dy < 4; dy++) {
          const radius = 3 - dy;
          for (let dx = -radius; dx <= radius; dx++) {
            for (let dz = -radius; dz <= radius; dz++) {
              if (Math.abs(dx) + Math.abs(dz) <= radius * 1.5) {
                setBlock(x + dx, height + spruceHeight - dy, z + dz, 'leaves');
              }
            }
          }
        }
        break;

      case 'acacia_trees':
        // √Årvores de savana (ac√°cias)
        const acaciaHeight = Math.floor(Math.random() * 3) + 4;
        for (let i = 1; i <= acaciaHeight; i++) {
          setBlock(x, height + i, z, 'wood');
        }

        // Copa plana e larga
        const canopySize = 2;
        for (let dx = -canopySize; dx <= canopySize; dx++) {
          for (let dz = -canopySize; dz <= canopySize; dz++) {
            if (Math.abs(dx) + Math.abs(dz) <= canopySize * 1.5 || Math.random() > 0.3) {
              setBlock(x + dx, height + acaciaHeight + 1, z + dz, 'leaves');
            }
          }
        }
        break;

      case 'jungle_trees':
        // √Årvores da selva (altas com videiras)
        const jungleHeight = Math.floor(Math.random() * 6) + 8;
        for (let i = 1; i <= jungleHeight; i++) {
          setBlock(x, height + i, z, 'wood');
        }

        // Copa grande e densa
        for (let dx = -3; dx <= 3; dx++) {
          for (let dz = -3; dz <= 3; dz++) {
            for (let dy = -2; dy <= 1; dy++) {
              const dist = Math.sqrt(dx*dx + dz*dz + dy*dy);
              if (dist <= 3 && Math.random() > 0.3) {
                setBlock(x + dx, height + jungleHeight + dy, z + dz, 'leaves');
              }
            }
          }
        }
        break;

      case 'cacti':
        // Cactos no deserto
        if (Math.random() > 0.7) {
          const cactusHeight = Math.floor(Math.random() * 3) + 1;
          for (let i = 1; i <= cactusHeight; i++) {
            setBlock(x, height + i, z, 'wood'); // Usando wood como cacto
          }
        }
        break;

      default:
        // √Årvores padr√£o (floresta/plan√≠cie)
        if (biome === 'forest' || biome === 'plains') {
          const treeHeight = Math.floor(Math.random() * 4) + 4;
          for (let i = 1; i <= treeHeight; i++) {
            setBlock(x, height + i, z, 'wood');
          }

          // Copa padr√£o
          for (let dx = -2; dx <= 2; dx++) {
            for (let dz = -2; dz <= 2; dz++) {
              for (let dy = -1; dy <= 1; dy++) {
                if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 3) {
                  setBlock(x + dx, height + treeHeight + dy, z + dz, 'leaves');
                }
              }
            }
          }
        }
        break;
    }
  }

  // Fun√ß√£o auxiliar para gerar caracter√≠sticas do bioma
  function generateBiomeFeatures(x, height, z, biome, specialFeature) {
    switch(biome) {
      case 'swamp':
        // Cogumelos no p√¢ntano
        if (Math.random() > 0.98) {
          setBlock(x, height + 1, z, 'brick'); // Representando cogumelo
        }
        break;

      case 'desert':
        // Templos ou po√ßos no deserto (simplificado)
        if (Math.random() > 0.995) {
          // Po√ßo de √°gua
          for (let dx = -1; dx <= 1; dx++) {
            for (let dz = -1; dz <= 1; dz++) {
              setBlock(x + dx, height - 1, z + dz, 'sandstone' || 'sand');
            }
          }
          setBlock(x, height, z, 'glass'); // √Ågua
        }
        break;

      case 'mountains':
        // Neve no topo das montanhas
        if (height > 40 && Math.random() > 0.5) {
          setBlock(x, height + 1, z, 'snow');
        }
        break;

      case 'tundra':
        // Neve na tundra
        if (Math.random() > 0.7) {
          setBlock(x, height + 1, z, 'snow');
        }
        break;
    }
  }

  // Fun√ß√£o auxiliar para gerar subsolo
  function generateUnderground(x, z, height, stoneHeight) {
    // Cavernas
    const caveNoise = noise(x * 0.1, z * 0.1);
    if (caveNoise > 0.7 && stoneHeight > 5) {
      const caveHeight = Math.floor(caveNoise * stoneHeight);
      if (caveHeight > 5 && caveHeight < stoneHeight - 5) {
        const caveSize = Math.floor(noise(x * 0.5, z * 0.5) * 3) + 1;
        for (let dy = 0; dy < caveSize; dy++) {
          removeBlockData(x, caveHeight + dy, z);
        }
      }
    }

    // Min√©rios
    for (let y = 1; y < stoneHeight; y++) {
      if (getBlock(x, y, z) && getBlock(x, y, z).type === 'stone') {
        const oreRand = Math.random();
        let ore = null;

        // Diamante e esmeralda no fundo
        if (y < 5 && oreRand > 0.98) {
          ore = 'diamond_ore';
        } else if (y < 10 && oreRand > 0.98) {
          ore = 'emerald_ore';
        }
        // Ouro no m√©dio-fundo
        else if (y < 15 && oreRand > 0.96) {
          ore = 'gold_ore';
        }
        // Ferro no m√©dio
        else if (y < 25 && oreRand > 0.94) {
          ore = 'iron_ore';
        }
        // Redstone
        else if (y < 30 && oreRand > 0.92) {
          ore = 'redstone_ore';
        }
        // Carv√£o em todas as camadas
        else if (oreRand > 0.90) {
          ore = 'coal_ore';
        }
        // Pedregulho em veios
        else if (oreRand > 0.88 && y < 20) {
          ore = 'cobblestone';
        }

        if (ore) {
          setBlock(x, y, z, ore);
        }
      }
    }
  }

  // Fun√ß√µes de ru√≠do e hash originais (mantidas para compatibilidade)
  function noise(x, z) {
    const X = Math.floor(x);
    const Z = Math.floor(z);
    const xf = x - X;
    const zf = z - Z;

    const a = hash(X, Z);
    const b = hash(X + 1, Z);
    const c = hash(X, Z + 1);
    const d = hash(X + 1, Z + 1);

    const u = xf * xf * (3.0 - 2.0 * xf);
    const v = zf * zf * (3.0 - 2.0 * zf);

    return a * (1 - u) * (1 - v) + b * u * (1 - v) + c * (1 - u) * v + d * u * v;
  }

  function hash(x, y) {
    let h = x * 374761393 + y * 668265263;
    h = (h ^ (h >> 13)) * 1274126177;
    return Math.abs((h ^ (h >> 16)) / 2147483648.0);
  }




  function generateChunk(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);
    if (chunks[chunkKey]) return;

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    for (let x = sx; x < sx + CHUNK_SIZE; x++) {
      for (let z = sz; z < sz + CHUNK_SIZE; z++) {
        // Determinando biomas com m√∫ltiplos fatores de ru√≠do
        const temp = noise(x * 0.001, z * 0.001);
        const humidity = noise(x * 0.001 + 1000, z * 0.001 + 1000);
        const terrain = noise(x * 0.002, z * 0.002);

        // Altura base com ru√≠do fractal
        let height = 0;
        let amplitude = 15;
        let frequency = 0.01;

        // 4 camadas de ru√≠do para terreno mais natural
        for (let i = 0; i < 4; i++) {
          height += noise(x * frequency, z * frequency) * amplitude;
          amplitude *= 0.5;
          frequency *= 2.0;
        }

        height = Math.floor(15 + height);

        // Bedrock na base
        setBlock(x, 0, z, 'bedrock');

        // Camadas subterr√¢neas
        const stoneHeight = height - 4;
        for (let y = 1; y < stoneHeight; y++) {
          setBlock(x, y, z, 'stone');
        }

        for (let y = stoneHeight; y < height - 1; y++) {
          setBlock(x, y, z, 'dirt');
        }

        // Determinar bioma com base em temperatura e umidade
        let surfaceBlock = 'grass';
        let biome = 'plains';

        if (temp > 0.7) {
          // Biomas quentes
          if (humidity < 0.3) {
            biome = 'desert';
            surfaceBlock = 'sand';
          } else if (humidity < 0.6) {
            biome = 'savanna';
            surfaceBlock = 'dirt';
          } else {
            biome = 'jungle';
            surfaceBlock = 'grass';
          }
        } else if (temp < 0.3) {
          // Biomas frios
          if (humidity < 0.4) {
            biome = 'tundra';
            surfaceBlock = 'gravel';
          } else {
            biome = 'taiga';
            surfaceBlock = 'grass';
          }
        } else {
          // Biomas temperados
          if (humidity < 0.4) {
            biome = 'plains';
            surfaceBlock = 'grass';
          } else if (humidity < 0.7) {
            biome = 'forest';
            surfaceBlock = 'grass';
          } else {
            biome = 'swamp';
            surfaceBlock = 'dirt';
          }
        }

        // Ajustar altura baseado no bioma
        if (terrain > 0.7) {
          biome = 'mountains';
          height += Math.floor(terrain * 20);
        } else if (terrain > 0.6) {
          biome = 'hills';
          height += Math.floor(terrain * 10);
        }

        // Colocar superf√≠cie
        setBlock(x, height, z, surfaceBlock);

        // Adicionar vegeta√ß√£o baseada no bioma
        generateBiomeVegetation(x, height, z, biome);

        // Min√©rios com base na profundidade
        generateOres(x, height, z, stoneHeight);

        // √Ågua em biomas √∫midos
        if ((biome === 'swamp' || biome === 'jungle') && humidity > 0.8) {
          for (let y = height + 1; y < 20; y++) {
            setBlock(x, y, z, 'glass'); // Usando glass como √°gua temporariamente
          }
        }

        // Neve em biomas frios
        if ((biome === 'tundra' || biome === 'taiga') && temp < 0.3) {
          if (Math.random() > 0.5) {
            setBlock(x, height + 1, z, 'snow');
          }
        }
      }
    }

    chunks[chunkKey] = true;
  }

  function generateBiomeVegetation(x, height, z, biome) {
    switch(biome) {
      case 'forest':
        if (Math.random() > 0.95 && height < 40) {
          generateTree(x, height + 1, z, 'normal');
        }
        break;

      case 'jungle':
        if (Math.random() > 0.9 && height < 40) {
          generateTree(x, height + 1, z, 'jungle');
        }
        if (Math.random() > 0.8) {
          setBlock(x, height + 1, z, 'leaves');
        }
        break;

      case 'taiga':
        if (Math.random() > 0.97 && height < 40) {
          generateTree(x, height + 1, z, 'spruce');
        }
        break;

      case 'desert':
        if (Math.random() > 0.99 && height < 40) {
          // Cacto
          const cactusHeight = Math.floor(Math.random() * 3) + 1;
          for (let i = 1; i <= cactusHeight; i++) {
            setBlock(x, height + i, z, 'wood');
          }
        }
        break;

      case 'plains':
        if (Math.random() > 0.98 && height < 40) {
          generateTree(x, height + 1, z, 'normal');
        }
        if (Math.random() > 0.9) {
          setBlock(x, height + 1, z, 'leaves'); // Flores/grama alta
        }
        break;

      case 'savanna':
        if (Math.random() > 0.98 && height < 40) {
          generateTree(x, height + 1, z, 'acacia');
        }
        break;
    }
  }

  function generateTree(x, y, z, type) {
    const treeHeight = type === 'jungle' ?
            Math.floor(Math.random() * 6) + 8 :
            type === 'spruce' ?
                    Math.floor(Math.random() * 4) + 6 :
                    Math.floor(Math.random() * 4) + 4;

    // Tronco
    for (let i = 0; i < treeHeight; i++) {
      setBlock(x, y + i, z, 'wood');
    }

    // Copa
    const topY = y + treeHeight - 1;

    if (type === 'spruce') {
      // Copa de pinheiro (c√¥nica)
      for (let dy = 0; dy < 4; dy++) {
        const radius = 3 - dy;
        for (let dx = -radius; dx <= radius; dx++) {
          for (let dz = -radius; dz <= radius; dz++) {
            if (Math.abs(dx) + Math.abs(dz) <= radius * 1.5) {
              setBlock(x + dx, topY - dy, z + dz, 'leaves');
            }
          }
        }
      }
    } else if (type === 'jungle') {
      // Copa densa de selva
      for (let dx = -3; dx <= 3; dx++) {
        for (let dz = -3; dz <= 3; dz++) {
          for (let dy = -2; dy <= 1; dy++) {
            const dist = Math.sqrt(dx*dx + dz*dz + dy*dy);
            if (dist <= 3 && Math.random() > 0.3) {
              setBlock(x + dx, topY + dy, z + dz, 'leaves');
            }
          }
        }
      }
    } else if (type === 'acacia') {
      // Copa plana de ac√°cia
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          if (Math.abs(dx) + Math.abs(dz) <= 3 && Math.random() > 0.2) {
            setBlock(x + dx, topY + 1, z + dz, 'leaves');
          }
        }
      }
    } else {
      // Copa normal (carvalho)
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          for (let dy = -1; dy <= 1; dy++) {
            if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 3) {
              setBlock(x + dx, topY + dy, z + dz, 'leaves');
            }
          }
        }
      }
    }
  }

  function generateOres(x, height, z, stoneHeight) {
    for (let y = 1; y < stoneHeight; y++) {
      if (getBlock(x, y, z) && getBlock(x, y, z).type === 'stone') {
        const oreRand = Math.random();
        let ore = null;

        // Diamante e esmeralda no fundo
        if (y < 5 && oreRand > 0.98) {
          ore = 'diamond_ore';
        } else if (y < 10 && oreRand > 0.98) {
          ore = 'emerald_ore';
        }
        // Ouro no m√©dio-fundo
        else if (y < 15 && oreRand > 0.96) {
          ore = 'gold_ore';
        }
        // Ferro no m√©dio
        else if (y < 25 && oreRand > 0.94) {
          ore = 'iron_ore';
        }
        // Redstone
        else if (y < 30 && oreRand > 0.92) {
          ore = 'redstone_ore';
        }
        // Carv√£o em todas as camadas
        else if (oreRand > 0.90) {
          ore = 'coal_ore';
        }

        if (ore) {
          setBlock(x, y, z, ore);
        }

        // Cavernas ocasionais
        if (oreRand < 0.05 && y > 10 && y < stoneHeight - 10) {
          removeBlockData(x, y, z);
          if (Math.random() > 0.7) {
            removeBlockData(x, y + 1, z);
          }
        }
      }
    }
  }




  // ============================================
  // SISTEMA DE INIMIGOS (MOBS HOSTIS)
  // ============================================

  const enemyTypes = {
    zombie: {
      name: 'Zumbi',
      health: 20,
      damage: 3,
      speed: 0.03,
      size: { width: 0.6, height: 1.8, depth: 0.6 },
      color: 0x228B22,
      attackRange: 2,
      detectionRange: 16,
      drops: ['dirt', 'stone'],
      dropCount: { min: 0, max: 2 }
    },
    skeleton: {
      name: 'Esqueleto',
      health: 15,
      damage: 2,
      speed: 0.035,
      size: { width: 0.6, height: 1.8, depth: 0.6 },
      color: 0xE8E8E8,
      attackRange: 10,
      detectionRange: 20,
      drops: ['wood'],
      dropCount: { min: 0, max: 2 }
    },
    creeper: {
      name: 'Creeper',
      health: 20,
      damage: 25,
      speed: 0.04,
      size: { width: 0.6, height: 1.6, depth: 0.6 },
      color: 0x00FF00,
      attackRange: 3,
      detectionRange: 16,
      explodeTime: 1500,
      drops: ['coal_ore'],
      dropCount: { min: 0, max: 1 }
    },
    spider: {
      name: 'Aranha',
      health: 16,
      damage: 2,
      speed: 0.05,
      size: { width: 1.4, height: 0.9, depth: 1.4 },
      color: 0x8B0000,
      attackRange: 2,
      detectionRange: 16,
      drops: ['leaves'],
      dropCount: { min: 0, max: 2 }
    }
  };

  let enemies = [];
  let enemyMeshes = [];

  class Enemy {
    constructor(type, x, y, z) {
      this.type = type;
      this.x = x;
      this.y = y;
      this.z = z;
      this.health = enemyTypes[type].health;
      this.speed = enemyTypes[type].speed;
      this.damage = enemyTypes[type].damage;
      this.attackRange = enemyTypes[type].attackRange;
      this.detectionRange = enemyTypes[type].detectionRange;
      this.velocity = new THREE.Vector3();
      this.targetPlayer = false;
      this.attackCooldown = 0;
      this.animationTime = 0;
      this.mesh = null;
      this.boundingBox = null;

      // Creeper espec√≠fico
      this.exploding = false;
      this.explodeTimer = 0;

      this.createMesh();
    }

    createZombieMesh() {
      const group = new THREE.Group();
      const color = enemyTypes[this.type].color;

      // Corpo
      const bodyGeo = new THREE.BoxGeometry(0.6, 0.9, 0.3);
      const bodyMat = new THREE.MeshLambertMaterial({ color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 1;
      group.add(body);

      // Cabe√ßa
      const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      const headMat = new THREE.MeshLambertMaterial({ color });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.7;
      head.userData.isHead = true;
      group.add(head);

      // Bra√ßos
      const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
      const armMat = new THREE.MeshLambertMaterial({ color });

      const leftArm = new THREE.Mesh(armGeo, armMat);
      leftArm.position.set(-0.4, 0.9, 0);
      leftArm.userData.isArm = true;
      leftArm.userData.side = 'left';
      group.add(leftArm);

      const rightArm = new THREE.Mesh(armGeo, armMat);
      rightArm.position.set(0.4, 0.9, 0);
      rightArm.userData.isArm = true;
      rightArm.userData.side = 'right';
      group.add(rightArm);

      // Pernas
      const legGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
      const legMat = new THREE.MeshLambertMaterial({ color });

      const leftLeg = new THREE.Mesh(legGeo, legMat);
      leftLeg.position.set(-0.15, 0.45, 0);
      leftLeg.userData.isLeg = true;
      leftLeg.userData.side = 'left';
      group.add(leftLeg);

      const rightLeg = new THREE.Mesh(legGeo, legMat);
      rightLeg.position.set(0.15, 0.45, 0);
      rightLeg.userData.isLeg = true;
      rightLeg.userData.side = 'right';
      group.add(rightLeg);

      return group;
    }

    createCreeperMesh() {
      const group = new THREE.Group();
      const color = enemyTypes[this.type].color;

      // Corpo
      const bodyGeo = new THREE.BoxGeometry(0.6, 1.2, 0.6);
      const bodyMat = new THREE.MeshLambertMaterial({ color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 1;
      group.add(body);

      // Cabe√ßa
      const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
      const headMat = new THREE.MeshLambertMaterial({ color });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.9;
      group.add(head);

      // Pernas (4 pernas curtas)
      const legGeo = new THREE.BoxGeometry(0.2, 0.5, 0.2);
      const legMat = new THREE.MeshLambertMaterial({ color });

      const legPositions = [
        { x: -0.2, z: -0.2 },
        { x: 0.2, z: -0.2 },
        { x: -0.2, z: 0.2 },
        { x: 0.2, z: 0.2 }
      ];

      legPositions.forEach((pos, i) => {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(pos.x, 0.25, pos.z);
        leg.userData.isLeg = true;
        leg.userData.index = i;
        group.add(leg);
      });

      return group;
    }

    createSpiderMesh() {
      const group = new THREE.Group();
      const color = enemyTypes[this.type].color;

      // Corpo (2 partes)
      const bodyGeo = new THREE.BoxGeometry(0.8, 0.5, 0.5);
      const bodyMat = new THREE.MeshLambertMaterial({ color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.6;
      group.add(body);

      const headGeo = new THREE.BoxGeometry(0.6, 0.4, 0.4);
      const headMat = new THREE.MeshLambertMaterial({ color });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.set(0, 0.6, 0.5);
      group.add(head);

      // Olhos vermelhos
      const eyeGeo = new THREE.SphereGeometry(0.08, 6, 6);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });

      [-0.15, 0.15].forEach(x => {
        const eye = new THREE.Mesh(eyeGeo, eyeMat);
        eye.position.set(x, 0.7, 0.7);
        group.add(eye);
      });

      // 8 pernas
      const legGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 6);
      const legMat = new THREE.MeshLambertMaterial({ color });

      for (let i = 0; i < 8; i++) {
        const side = i < 4 ? -1 : 1;
        const angle = (i % 4) * Math.PI / 2;

        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(
                Math.cos(angle) * 0.7 * side,
                0.3,
                Math.sin(angle) * 0.4
        );
        leg.rotation.z = angle + (side > 0 ? Math.PI / 4 : -Math.PI / 4);
        leg.userData.isLeg = true;
        leg.userData.index = i;
        group.add(leg);
      } // ‚úÖ CORRIGIDO: Era });  agora √© apenas }

      return group;
    }
    createMesh() {
      switch(this.type) {
        case 'zombie':
        case 'skeleton':
          this.mesh = this.createZombieMesh();
          break;
        case 'creeper':
          this.mesh = this.createCreeperMesh();
          break;
        case 'spider':
          this.mesh = this.createSpiderMesh();
          break;
        default:
          const enemyType = enemyTypes[this.type];
          const geometry = new THREE.BoxGeometry(
                  enemyType.size.width,
                  enemyType.size.height,
                  enemyType.size.depth
          );
          const material = new THREE.MeshLambertMaterial({ color: enemyType.color });
          this.mesh = new THREE.Mesh(geometry, material);
      }

      this.mesh.position.set(this.x, this.y, this.z);
      this.mesh.userData.isEnemy = true;
      this.mesh.userData.enemyRef = this;
      scene.add(this.mesh);
      enemyMeshes.push(this.mesh);
      this.boundingBox = new THREE.Box3().setFromObject(this.mesh);
    }

    update() {
      this.animationTime += 0.1;
      this.attackCooldown = Math.max(0, this.attackCooldown - 1);

      // Dist√¢ncia at√© o jogador
      const dx = camera.position.x - this.x;
      const dz = camera.position.z - this.z;
      const distToPlayer = Math.sqrt(dx * dx + dz * dz);

      // Detectar jogador
      if (distToPlayer < this.detectionRange) {
        this.targetPlayer = true;
      }

      // Comportamento de persegui√ß√£o
      if (this.targetPlayer && distToPlayer > 1) {
        const dirX = dx / distToPlayer;
        const dirZ = dz / distToPlayer;

        this.x += dirX * this.speed;
        this.z += dirZ * this.speed;

        // Verificar colis√£o com blocos
        const blockBelow = getBlock(Math.floor(this.x), Math.floor(this.y - 1), Math.floor(this.z));
        if (!blockBelow) {
          this.y -= 0.5;
        }

        // Rota√ß√£o na dire√ß√£o do jogador
        if (this.mesh) {
          this.mesh.rotation.y = Math.atan2(-dx, -dz);
        }

        this.animateWalking();
      }

      // Ataque espec√≠fico do tipo
      if (distToPlayer < this.attackRange && this.attackCooldown === 0) {
        this.attack();
      }

      // Atualizar posi√ß√£o do mesh
      if (this.mesh) {
        this.mesh.position.set(this.x, this.y, this.z);
        this.boundingBox.setFromObject(this.mesh);
      }
    }

    animateWalking() {
      if (!this.mesh) return;

      this.mesh.traverse(child => {
        if (child.userData.isLeg) {
          if (this.type === 'spider') {
            const legMove = Math.sin(this.animationTime * 8 + child.userData.index) * 0.2;
            child.rotation.z += legMove * 0.1;
          } else {
            const legMove = Math.sin(this.animationTime * 8) * 0.5;
            if (child.userData.side === 'left') {
              child.rotation.x = legMove;
            } else {
              child.rotation.x = -legMove;
            }
          }
        }

        if (child.userData.isArm && (this.type === 'zombie' || this.type === 'skeleton')) {
          const armMove = Math.sin(this.animationTime * 8) * 0.5;
          if (child.userData.side === 'left') {
            child.rotation.x = -armMove;
          } else {
            child.rotation.x = armMove;
          }
        }
      });
    }

    attack() {
      if (this.type === 'creeper') {
        // Creeper explode
        if (!this.exploding) {
          this.exploding = true;
          this.explodeTimer = Date.now();
        }

        const elapsed = Date.now() - this.explodeTimer;

        // Piscar vermelho
        if (this.mesh && Math.floor(elapsed / 100) % 2 === 0) {
          this.mesh.traverse(child => {
            if (child.material) {
              child.material.color.set(0xFFFFFF);
            }
          });
        } else if (this.mesh) {
          this.mesh.traverse(child => {
            if (child.material) {
              child.material.color.set(enemyTypes.creeper.color);
            }
          });
        }

        if (elapsed > enemyTypes.creeper.explodeTime) {
          this.explode();
        }
      } else {
        // Ataque direto
        damagePlayer(this.damage);
        this.attackCooldown = 60;
      }
    }

    explode() {
      // Dano ao jogador
      const dx = camera.position.x - this.x;
      const dz = camera.position.z - this.z;
      const dist = Math.sqrt(dx * dx + dz * dz);

      if (dist < 5) {
        const damage = Math.floor(this.damage * (1 - dist / 5));
        damagePlayer(damage);
      }

      // Destruir blocos ao redor
      for (let x = -2; x <= 2; x++) {
        for (let y = -1; y <= 1; y++) {
          for (let z = -2; z <= 2; z++) {
            const bx = Math.floor(this.x) + x;
            const by = Math.floor(this.y) + y;
            const bz = Math.floor(this.z) + z;

            const block = getBlock(bx, by, bz);
            if (block && block.type !== 'bedrock' && Math.random() > 0.3) {
              removeBlockData(bx, by, bz);
            }
          }
        }
      }

      // Reconstruir chunks afetados
      const chunk = worldToChunk(this.x, this.z);
      for (let cx = -1; cx <= 1; cx++) {
        for (let cz = -1; cz <= 1; cz++) {
          const key = getChunkKey(chunk.x + cx, chunk.z + cz);
          if (chunkMeshes[key]) {
            buildChunkMesh(chunk.x + cx, chunk.z + cz);
          }
        }
      }

      this.remove();
      const index = enemies.indexOf(this);
      if (index > -1) enemies.splice(index, 1);
    }

    damage(amount) {
      this.health -= amount;

      if (this.mesh) {
        this.mesh.traverse(child => {
          if (child.material) {
            const originalColor = child.material.color.clone();
            child.material.color.set(0xFF0000);
            setTimeout(() => {
              if (child.material) {
                child.material.color.copy(originalColor);
              }
            }, 100);
          }
        });
      }

      if (this.health <= 0) {
        this.dropItems();
        this.remove();
        const index = enemies.indexOf(this);
        if (index > -1) enemies.splice(index, 1);
        return true;
      }
      return false;
    }

    dropItems() {
      const enemyType = enemyTypes[this.type];
      if (enemyType.drops) {
        enemyType.drops.forEach(drop => {
          const count = Math.floor(Math.random() *
                  (enemyType.dropCount.max - enemyType.dropCount.min + 1)) + enemyType.dropCount.min;
          if (count > 0) addToInventory(drop, count);
        });
      }
    }

    remove() {
      if (this.mesh) {
        this.mesh.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => mat.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
        scene.remove(this.mesh);
        const index = enemyMeshes.indexOf(this.mesh);
        if (index > -1) enemyMeshes.splice(index, 1);
      }
    }
  }

  function spawnEnemies(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;

    // ‚úÖ REDUZIDO: 0 a 2 inimigos por chunk (antes era 2-5)
    const spawnCount = Math.floor(Math.random() * 3); // 0, 1 ou 2 inimigos

    for (let i = 0; i < spawnCount; i++) {
      const x = sx + Math.random() * CHUNK_SIZE;
      const z = sz + Math.random() * CHUNK_SIZE;
      const y = getHeight(x, z) + 1;

      const blockBelow = getBlock(Math.floor(x), Math.floor(y - 1), Math.floor(z));

      // ‚úÖ REDUZIDO: 20% de chance (antes era 50%)
      if (blockBelow && Math.random() > 0.8) {
        const types = Object.keys(enemyTypes);
        const type = types[Math.floor(Math.random() * types.length)];

        const enemy = new Enemy(type, x, y, z);
        enemies.push(enemy);
      }
    }
  }

  function updateEnemies() {
    enemies.forEach(enemy => {
      if (enemy.update) {
        enemy.update();
      }
    });
  }


  let villagers = [];
  let villagerMeshes = [];
  let villages = [];

  class Villager {
    constructor(x, y, z, profession) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.profession = profession || 'farmer';
      this.health = 20;
      this.homeX = x;
      this.homeZ = z;
      this.wanderRadius = 10;
      this.targetX = x;
      this.targetZ = z;
      this.speed = 0.015;
      this.moveTimer = 0;
      this.animationTime = 0;
      this.mesh = null;
      this.boundingBox = null;

      this.createMesh();
    }

    createMesh() {
      const group = new THREE.Group();

      // Cor baseada na profiss√£o
      const professionColors = {
        farmer: 0x8B4513,
        librarian: 0xFFFFFF,
        blacksmith: 0x696969,
        priest: 0x800080,
        butcher: 0xFFEBCD
      };

      const color = professionColors[this.profession] || 0x8B4513;

      // Corpo
      const bodyGeo = new THREE.BoxGeometry(0.6, 1, 0.3);
      const bodyMat = new THREE.MeshLambertMaterial({ color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 1.1;
      group.add(body);

      // Cabe√ßa (maior que zumbis)
      const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
      const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.8;
      group.add(head);

      // Nariz grande (caracter√≠stico)
      const noseGeo = new THREE.BoxGeometry(0.2, 0.3, 0.2);
      const noseMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const nose = new THREE.Mesh(noseGeo, noseMat);
      nose.position.set(0, 1.8, 0.4);
      group.add(nose);

      // Bra√ßos
      const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
      const armMat = new THREE.MeshLambertMaterial({ color });

      const leftArm = new THREE.Mesh(armGeo, armMat);
      leftArm.position.set(-0.4, 1, 0);
      leftArm.userData.isArm = true;
      leftArm.userData.side = 'left';
      group.add(leftArm);

      const rightArm = new THREE.Mesh(armGeo, armMat);
      rightArm.position.set(0.4, 1, 0);
      rightArm.userData.isArm = true;
      rightArm.userData.side = 'right';
      group.add(rightArm);

      // Pernas
      const legGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
      const legMat = new THREE.MeshLambertMaterial({ color: 0x654321 });

      const leftLeg = new THREE.Mesh(legGeo, legMat);
      leftLeg.position.set(-0.15, 0.5, 0);
      leftLeg.userData.isLeg = true;
      leftLeg.userData.side = 'left';
      group.add(leftLeg);

      const rightLeg = new THREE.Mesh(legGeo, legMat);
      rightLeg.position.set(0.15, 0.5, 0);
      rightLeg.userData.isLeg = true;
      rightLeg.userData.side = 'right';
      group.add(rightLeg);

      this.mesh = group;
      this.mesh.position.set(this.x, this.y, this.z);
      this.mesh.userData.isVillager = true;
      scene.add(this.mesh);
      villagerMeshes.push(this.mesh);
      this.boundingBox = new THREE.Box3().setFromObject(this.mesh);
    }

    update() {
      this.moveTimer++;
      this.animationTime += 0.1;

      // Movimento aleat√≥rio dentro do raio
      if (this.moveTimer > 180 && Math.random() < 0.02) {
        this.targetX = this.homeX + (Math.random() - 0.5) * this.wanderRadius;
        this.targetZ = this.homeZ + (Math.random() - 0.5) * this.wanderRadius;
        this.moveTimer = 0;
      }

      const dx = this.targetX - this.x;
      const dz = this.targetZ - this.z;
      const dist = Math.sqrt(dx * dx + dz * dz);

      if (dist > 0.5) {
        this.x += (dx / dist) * this.speed;
        this.z += (dz / dist) * this.speed;

        const blockBelow = getBlock(Math.floor(this.x), Math.floor(this.y - 1), Math.floor(this.z));
        if (!blockBelow) {
          this.y -= 0.5;
        }

        this.animateWalking();

        if (this.mesh) {
          this.mesh.rotation.y = Math.atan2(-dx, -dz);
        }
      }

      if (this.mesh) {
        this.mesh.position.set(this.x, this.y, this.z);
        this.boundingBox.setFromObject(this.mesh);
      }
    }

    animateWalking() {
      if (!this.mesh) return;

      this.mesh.traverse(child => {
        if (child.userData.isLeg) {
          const legMove = Math.sin(this.animationTime * 6) * 0.4;
          if (child.userData.side === 'left') {
            child.rotation.x = legMove;
          } else {
            child.rotation.x = -legMove;
          }
        }

        if (child.userData.isArm) {
          const armMove = Math.sin(this.animationTime * 6) * 0.3;
          if (child.userData.side === 'left') {
            child.rotation.x = -armMove;
          } else {
            child.rotation.x = armMove;
          }
        }
      });
    }

    remove() {
      if (this.mesh) {
        this.mesh.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        scene.remove(this.mesh);
        const index = villagerMeshes.indexOf(this.mesh);
        if (index > -1) villagerMeshes.splice(index, 1);
      }
    }
  }

  // SUBSTITUIR a classe PlayerCharacter completa
  class PlayerCharacter {
    constructor() {
      this.group = new THREE.Group();
      this.animations = {
        idle: { time: 0, speed: 0.5 },
        walk: { time: 0, speed: 2 },
        jump: { time: 0, speed: 1.5 },
        run: { time: 0, speed: 3 }
      };
      this.currentAnimation = 'idle';
      this.createRealisticModel();
    }

    createRealisticModel() {
      // Cabe√ßa com mais detalhes
      const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      const headMaterial = new THREE.MeshLambertMaterial({
        color: 0xFFDBAC,
        flatShading: false
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 1.75;
      head.castShadow = true;
      head.receiveShadow = true;
      this.head = head;
      this.group.add(head);

      // Cabelo/Chap√©u
      const hairGeometry = new THREE.BoxGeometry(0.52, 0.15, 0.52);
      const hairMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
      const hair = new THREE.Mesh(hairGeometry, hairMaterial);
      hair.position.y = 2.05;
      hair.castShadow = true;
      this.group.add(hair);

      // Pesco√ßo
      const neckGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.2, 8);
      const neckMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
      const neck = new THREE.Mesh(neckGeometry, neckMaterial);
      neck.position.y = 1.4;
      neck.castShadow = true;
      this.group.add(neck);

      // Corpo com mais forma
      const torsoGeometry = new THREE.BoxGeometry(0.7, 0.9, 0.35);
      const torsoMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
      const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
      torso.position.y = 0.95;
      torso.castShadow = true;
      torso.receiveShadow = true;
      this.group.add(torso);

      // Cintura
      const waistGeometry = new THREE.BoxGeometry(0.65, 0.15, 0.33);
      const waistMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
      const waist = new THREE.Mesh(waistGeometry, waistMaterial);
      waist.position.y = 0.48;
      waist.castShadow = true;
      this.group.add(waist);

      // Bra√ßo esquerdo (ombro + antebra√ßo)
      const shoulderGeometry = new THREE.CylinderGeometry(0.12, 0.11, 0.4, 8);
      const armMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });

      this.leftShoulder = new THREE.Mesh(shoulderGeometry, armMaterial);
      this.leftShoulder.position.set(-0.45, 1.15, 0);
      this.leftShoulder.castShadow = true;
      this.group.add(this.leftShoulder);

      const forearmGeometry = new THREE.CylinderGeometry(0.1, 0.09, 0.45, 8);
      const skinMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });

      this.leftForearm = new THREE.Mesh(forearmGeometry, skinMaterial);
      this.leftForearm.position.set(-0.45, 0.65, 0);
      this.leftForearm.castShadow = true;
      this.group.add(this.leftForearm);

      // M√£o esquerda
      const handGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
      this.leftHand = new THREE.Mesh(handGeometry, skinMaterial);
      this.leftHand.position.set(-0.45, 0.35, 0);
      this.leftHand.castShadow = true;
      this.group.add(this.leftHand);

      // Bra√ßo direito (ombro + antebra√ßo)
      this.rightShoulder = new THREE.Mesh(shoulderGeometry, armMaterial);
      this.rightShoulder.position.set(0.45, 1.15, 0);
      this.rightShoulder.castShadow = true;
      this.group.add(this.rightShoulder);

      this.rightForearm = new THREE.Mesh(forearmGeometry, skinMaterial);
      this.rightForearm.position.set(0.45, 0.65, 0);
      this.rightForearm.castShadow = true;
      this.group.add(this.rightForearm);

      // M√£o direita
      this.rightHand = new THREE.Mesh(handGeometry, skinMaterial);
      this.rightHand.position.set(0.45, 0.35, 0);
      this.rightHand.castShadow = true;
      this.group.add(this.rightHand);

      // Pernas (coxa + canela)
      const thighGeometry = new THREE.CylinderGeometry(0.14, 0.13, 0.5, 8);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });

      this.leftThigh = new THREE.Mesh(thighGeometry, legMaterial);
      this.leftThigh.position.set(-0.18, 0.15, 0);
      this.leftThigh.castShadow = true;
      this.group.add(this.leftThigh);

      const calfGeometry = new THREE.CylinderGeometry(0.12, 0.11, 0.5, 8);

      this.leftCalf = new THREE.Mesh(calfGeometry, legMaterial);
      this.leftCalf.position.set(-0.18, -0.35, 0);
      this.leftCalf.castShadow = true;
      this.group.add(this.leftCalf);

      // P√© esquerdo
      const footGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.3);
      const shoeMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
      this.leftFoot = new THREE.Mesh(footGeometry, shoeMaterial);
      this.leftFoot.position.set(-0.18, -0.65, 0.05);
      this.leftFoot.castShadow = true;
      this.group.add(this.leftFoot);

      // Perna direita
      this.rightThigh = new THREE.Mesh(thighGeometry, legMaterial);
      this.rightThigh.position.set(0.18, 0.15, 0);
      this.rightThigh.castShadow = true;
      this.group.add(this.rightThigh);

      this.rightCalf = new THREE.Mesh(calfGeometry, legMaterial);
      this.rightCalf.position.set(0.18, -0.35, 0);
      this.rightCalf.castShadow = true;
      this.group.add(this.rightCalf);

      // P√© direito
      this.rightFoot = new THREE.Mesh(footGeometry, shoeMaterial);
      this.rightFoot.position.set(0.18, -0.65, 0.05);
      this.rightFoot.castShadow = true;
      this.group.add(this.rightFoot);

      // Olhos com brilho
      const eyeGeometry = new THREE.SphereGeometry(0.04, 8, 8);
      const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x1E90FF });

      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.12, 1.8, 0.25);
      this.group.add(leftEye);

      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.12, 1.8, 0.25);
      this.group.add(rightEye);

      // Pupilas
      const pupilGeometry = new THREE.SphereGeometry(0.02, 6, 6);
      const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

      const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
      leftPupil.position.set(-0.12, 1.8, 0.27);
      this.group.add(leftPupil);

      const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
      rightPupil.position.set(0.12, 1.8, 0.27);
      this.group.add(rightPupil);

      // Sombra circular embaixo
      const shadowGeometry = new THREE.CircleGeometry(0.4, 16);
      const shadowMaterial = new THREE.MeshBasicMaterial({
        color: 0x000000,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      const shadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
      shadow.rotation.x = -Math.PI / 2;
      shadow.position.y = -0.69;
      this.group.add(shadow);
    }

    updateAnimation(deltaTime, isMoving, isJumping, isRunning) {
      const animType = isJumping ? 'jump' : isRunning ? 'run' : isMoving ? 'walk' : 'idle';
      const anim = this.animations[animType];
      anim.time += deltaTime * anim.speed;

      if (isJumping) {
        this.updateJumpAnimation(anim.time);
      } else if (isRunning) {
        this.updateRunAnimation(anim.time);
      } else if (isMoving) {
        this.updateWalkAnimation(anim.time);
      } else {
        this.updateIdleAnimation(anim.time);
      }
    }

    updateIdleAnimation(time) {
      const breath = Math.sin(time) * 0.015;
      this.group.position.y = breath;

      // Respira√ß√£o sutil
      this.group.scale.y = 1 + Math.sin(time * 1.5) * 0.01;

      // Movimento sutil dos bra√ßos
      this.leftShoulder.rotation.x = Math.sin(time * 0.5) * 0.05;
      this.rightShoulder.rotation.x = Math.sin(time * 0.5 + Math.PI) * 0.05;

      // Cabe√ßa olhando levemente
      this.head.rotation.y = Math.sin(time * 0.3) * 0.1;
    }

    updateWalkAnimation(time) {
      const legSwing = Math.sin(time) * 0.6;
      const armSwing = Math.sin(time + Math.PI) * 0.4;
      const bob = Math.sin(time * 2) * 0.04;

      this.group.position.y = bob;

      // Balan√ßo natural das pernas
      this.leftThigh.rotation.x = legSwing;
      this.rightThigh.rotation.x = -legSwing;

      // Canelas seguem as coxas com delay
      this.leftCalf.rotation.x = Math.max(0, legSwing * 0.5);
      this.rightCalf.rotation.x = Math.max(0, -legSwing * 0.5);

      // P√©s com movimento natural
      this.leftFoot.rotation.x = legSwing * 0.3;
      this.rightFoot.rotation.x = -legSwing * 0.3;

      // Bra√ßos balan√ßando oposto √†s pernas
      this.leftShoulder.rotation.x = armSwing;
      this.rightShoulder.rotation.x = -armSwing;

      this.leftForearm.rotation.x = armSwing * 0.5;
      this.rightForearm.rotation.x = -armSwing * 0.5;

      // Rota√ß√£o sutil do tronco
      this.group.rotation.z = Math.sin(time) * 0.03;

      // Cabe√ßa balan√ßa levemente
      this.head.rotation.x = bob * 0.5;
    }

    updateRunAnimation(time) {
      const legSwing = Math.sin(time) * 0.9;
      const armSwing = Math.sin(time + Math.PI) * 0.7;
      const bob = Math.sin(time * 2) * 0.08;

      this.group.position.y = bob;

      // Inclina√ß√£o do corpo para frente ao correr
      this.group.rotation.x = -0.1;

      // Movimento exagerado das pernas
      this.leftThigh.rotation.x = legSwing;
      this.rightThigh.rotation.x = -legSwing;

      this.leftCalf.rotation.x = Math.max(0, legSwing * 0.8);
      this.rightCalf.rotation.x = Math.max(0, -legSwing * 0.8);

      // Bra√ßos mais din√¢micos
      this.leftShoulder.rotation.x = armSwing;
      this.rightShoulder.rotation.x = -armSwing;

      this.leftForearm.rotation.x = armSwing * 0.6;
      this.rightForearm.rotation.x = -armSwing * 0.6;

      // Rota√ß√£o do tronco mais pronunciada
      this.group.rotation.z = Math.sin(time) * 0.05;
    }

    updateJumpAnimation(time) {
      const jumpPhase = Math.min(time, Math.PI);
      const jumpHeight = Math.sin(jumpPhase) * 0.3;

      this.group.position.y = jumpHeight;

      // Bra√ßos para cima
      this.leftShoulder.rotation.x = -0.8 - jumpHeight;
      this.rightShoulder.rotation.x = -0.8 - jumpHeight;

      this.leftForearm.rotation.x = -0.3;
      this.rightForearm.rotation.x = -0.3;

      // Pernas dobradas
      this.leftThigh.rotation.x = 0.6 + jumpHeight * 0.5;
      this.rightThigh.rotation.x = 0.6 + jumpHeight * 0.5;

      this.leftCalf.rotation.x = -0.8 - jumpHeight;
      this.rightCalf.rotation.x = -0.8 - jumpHeight;

      // Cabe√ßa para tr√°s
      this.head.rotation.x = -0.2;
    }

    setPosition(x, y, z) {
      this.group.position.set(x, y, z);
    }

    setRotation(y) {
      this.group.rotation.y = y;
    }
  }

  function buildHouse(x, y, z) {
    // Base (5x5)
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'planks');
      }
    }

    // Paredes
    for (let dy = 0; dy < 4; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          if (Math.abs(dx) === 2 || Math.abs(dz) === 2) {
            if (dy === 1 && dx === 0 && dz === 2) {
              // Porta
              removeBlockData(x + dx, y + dy, z + dz);
            } else {
              setBlock(x + dx, y + dy, z + dz, 'planks');
            }
          }
        }
      }
    }

    // Telhado
    for (let dy = 0; dy < 3; dy++) {
      const size = 2 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -size; dz <= size; dz++) {
          setBlock(x + dx, y + 4 + dy, z + dz, 'brick');
        }
      }
    }

    // Janelas
    setBlock(x - 2, y + 2, z, 'glass');
    setBlock(x + 2, y + 2, z, 'glass');
  }

  function buildWell(x, y, z) {
    // Base do po√ßo
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
          setBlock(x + dx, y, z + dz, 'cobblestone');
          setBlock(x + dx, y + 1, z + dz, 'cobblestone');
          setBlock(x + dx, y + 2, z + dz, 'cobblestone');
        } else {
          // √Ågua no centro
          setBlock(x, y - 3, z, 'glass');
          setBlock(x, y - 2, z, 'glass');
          setBlock(x, y - 1, z, 'glass');
        }
      }
    }

    // Teto
    setBlock(x, y + 4, z, 'wood');
  }


  function createVillagePaths(centerX, villageY, centerZ) {
    // Caminhos em cruz
    for (let i = -20; i <= 20; i++) {
      // Horizontal
      setBlock(centerX + i, villageY, centerZ, 'cobblestone');
      setBlock(centerX + i, villageY, centerZ + 1, 'cobblestone');
      setBlock(centerX + i, villageY, centerZ - 1, 'cobblestone');

      // Vertical
      setBlock(centerX, villageY, centerZ + i, 'cobblestone');
      setBlock(centerX + 1, villageY, centerZ + i, 'cobblestone');
      setBlock(centerX - 1, villageY, centerZ + i, 'cobblestone');
    }

    // Lanternas ao longo dos caminhos
    for (let i = -20; i <= 20; i += 5) {
      setBlock(centerX + i, villageY + 1, centerZ + 3, 'lantern');
      setBlock(centerX + i, villageY + 1, centerZ - 3, 'lantern');
      setBlock(centerX + 3, villageY + 1, centerZ + i, 'lantern');
      setBlock(centerX - 3, villageY + 1, centerZ + i, 'lantern');
    }
  }

  function buildChurch(x, y, z) {
    // Base maior (7x10)
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -5; dz <= 5; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'cobblestone');
      }
    }

    // Paredes
    for (let dy = 0; dy < 6; dy++) {
      for (let dx = -3; dx <= 3; dx++) {
        for (let dz = -5; dz <= 5; dz++) {
          if (Math.abs(dx) === 3 || Math.abs(dz) === 5) {
            if (dy === 1 && dx === 0 && dz === 5) {
              continue; // Porta
            }
            setBlock(x + dx, y + dy, z + dz, 'quartz');
          }
        }
      }
    }

    // Torre do sino
    for (let dy = 0; dy < 10; dy++) {
      setBlock(x, y + 6 + dy, z, 'quartz');
    }

    // Topo da torre com glowstone
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + dx, y + 16, z + dz, 'glowstone');
      }
    }

    // Telhado principal
    for (let dy = 0; dy < 4; dy++) {
      const size = 3 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -5 + dy; dz <= 5 - dy; dz++) {
          setBlock(x + dx, y + 6 + dy, z + dz, 'brick');
        }
      }
    }

    // Janelas com vidro
    setBlock(x - 3, y + 3, z - 2, 'glass');
    setBlock(x - 3, y + 3, z + 2, 'glass');
    setBlock(x + 3, y + 3, z - 2, 'glass');
    setBlock(x + 3, y + 3, z + 2, 'glass');

    // Lanternas internas
    setBlock(x - 2, y + 4, z - 3, 'lantern');
    setBlock(x + 2, y + 4, z - 3, 'lantern');
    setBlock(x - 2, y + 4, z + 3, 'lantern');
    setBlock(x + 2, y + 4, z + 3, 'lantern');
  }

  function buildFarm(x, y, z) {
    // Cercado (8x8)
    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -4; dz <= 4; dz++) {
        if (Math.abs(dx) === 4 || Math.abs(dz) === 4) {
          setBlock(x + dx, y, z + dz, 'planks');
          setBlock(x + dx, y + 1, z + dz, 'planks');
        }
      }
    }

    // √Årea cultivada
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        if ((dx + dz) % 2 === 0) {
          setBlock(x + dx, y, z + dz, 'dirt');
          // Plantas decorativas
          if (Math.random() > 0.5) {
            setBlock(x + dx, y + 1, z + dz, 'leaves');
          }
        } else {
          setBlock(x + dx, y, z + dz, 'water');
        }
      }
    }

    // Port√£o
    removeBlockData(x, y, z + 4);
    removeBlockData(x, y + 1, z + 4);

    // Celeiro pequeno
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 0; dz++) {
        if (Math.abs(dx) === 2 || dz === -2) {
          setBlock(x + dx + 6, y, z + dz, 'wood');
          setBlock(x + dx + 6, y + 1, z + dz, 'wood');
          setBlock(x + dx + 6, y + 2, z + dz, 'wood');
        }
      }
    }

    // Telhado do celeiro
    for (let dx = -2; dx <= 2; dx++) {
      setBlock(x + dx + 6, y + 3, z - 1, 'brick');
    }
  }

  function buildTower(x, y, z) {
    // Torre de vigia (3x3, altura 12)
    for (let dy = 0; dy < 12; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
            setBlock(x + dx, y + dy, z + dz, 'cobblestone');
          } else if (dy > 0 && dy < 11) {
            removeBlockData(x + dx, y + dy, z + dz); // Interior vazio
          }
        }
      }
    }

    // Escadas internas (simplificadas)
    for (let dy = 0; dy < 11; dy++) {
      const pos = dy % 4;
      switch(pos) {
        case 0: setBlock(x + 1, y + dy, z, 'planks'); break;
        case 1: setBlock(x, y + dy, z + 1, 'planks'); break;
        case 2: setBlock(x - 1, y + dy, z, 'planks'); break;
        case 3: setBlock(x, y + dy, z - 1, 'planks'); break;
      }
    }

    // Topo com ameias
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        if (Math.abs(dx) === 2 || Math.abs(dz) === 2) {
          if ((dx + dz) % 2 === 0) {
            setBlock(x + dx, y + 12, z + dz, 'cobblestone');
            setBlock(x + dx, y + 13, z + dz, 'cobblestone');
          }
        }
      }
    }

    // Tocha no topo
    setBlock(x, y + 14, z, 'torch');

    // Porta
    removeBlockData(x + 1, y, z);
    removeBlockData(x + 1, y + 1, z);
  }

  function buildLibrary(x, y, z) {
    // Base (6x6)
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'planks');
      }
    }

    // Paredes
    for (let dy = 0; dy < 5; dy++) {
      for (let dx = -3; dx <= 3; dx++) {
        for (let dz = -3; dz <= 3; dz++) {
          if (Math.abs(dx) === 3 || Math.abs(dz) === 3) {
            if (dy === 1 && dx === 0 && dz === 3) {
              continue; // Porta
            }
            setBlock(x + dx, y + dy, z + dz, 'planks');
          }
        }
      }
    }

    // Estantes nas paredes internas
    const shelfPositions = [
      { dx: -2, dz: -2 }, { dx: 0, dz: -2 }, { dx: 2, dz: -2 },
      { dx: -2, dz: 2 }, { dx: 2, dz: 2 },
      { dx: -2, dz: 0 }, { dx: 2, dz: 0 }
    ];

    shelfPositions.forEach(pos => {
      setBlock(x + pos.dx, y + 1, z + pos.dz, 'bookshelf');
      setBlock(x + pos.dx, y + 2, z + pos.dz, 'bookshelf');
    });

    // Mesa de trabalho e ba√∫ no centro
    setBlock(x, y + 1, z, 'crafting_table');
    setBlock(x + 1, y + 1, z, 'chest');

    // Telhado
    for (let dy = 0; dy < 3; dy++) {
      const size = 3 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -size; dz <= size; dz++) {
          setBlock(x + dx, y + 5 + dy, z + dz, 'brick');
        }
      }
    }

    // Lanternas
    setBlock(x - 2, y + 3, z - 2, 'lantern');
    setBlock(x + 2, y + 3, z - 2, 'lantern');
    setBlock(x - 2, y + 3, z + 2, 'lantern');
    setBlock(x + 2, y + 3, z + 2, 'lantern');

    // Janelas
    setBlock(x - 3, y + 2, z, 'glass');
    setBlock(x + 3, y + 2, z, 'glass');
  }

  function updateVillagers() {
    villagers.forEach(villager => {
      if (villager.update) {
        villager.update();
      }
    });
  }

  let playerModel = null;

  function createPlayerModel() {
    const group = new THREE.Group();

    // Corpo
    const bodyGeo = new THREE.BoxGeometry(0.6, 0.9, 0.3);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = -0.8;
    group.add(body);

    // Cabe√ßa
    const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = -0.1;
    head.userData.isHead = true;
    group.add(head);

    // Bra√ßos
    const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
    const armMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });

    const leftArm = new THREE.Mesh(armGeo, armMat);
    leftArm.position.set(-0.4, -0.7, 0);
    leftArm.userData.isArm = true;
    leftArm.userData.side = 'left';
    group.add(leftArm);

    const rightArm = new THREE.Mesh(armGeo, armMat);
    rightArm.position.set(0.4, -0.7, 0);
    rightArm.userData.isArm = true;
    rightArm.userData.side = 'right';
    group.add(rightArm);

    // Pernas
    const legGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
    const legMat = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });

    const leftLeg = new THREE.Mesh(legGeo, legMat);
    leftLeg.position.set(-0.15, -1.4, 0);
    leftLeg.userData.isLeg = true;
    leftLeg.userData.side = 'left';
    group.add(leftLeg);

    const rightLeg = new THREE.Mesh(legGeo, legMat);
    rightLeg.position.set(0.15, -1.4, 0);
    rightLeg.userData.isLeg = true;
    rightLeg.userData.side = 'right';
    group.add(rightLeg);

    playerModel = group;
    camera.add(playerModel);
  }

  let walkAnimTime = 0;
  function updatePlayerModel() {
    if (!playerModel) return;

    // Animar baseado no movimento
    const isMoving = keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'];

    if (isMoving && !player.flying) {
      walkAnimTime += 0.15;

      playerModel.traverse(child => {
        if (child.userData.isLeg) {
          const legMove = Math.sin(walkAnimTime) * 0.6;
          if (child.userData.side === 'left') {
            child.rotation.x = legMove;
          } else {
            child.rotation.x = -legMove;
          }
        }

        if (child.userData.isArm) {
          const armMove = Math.sin(walkAnimTime) * 0.5;
          if (child.userData.side === 'left') {
            child.rotation.x = -armMove;
          } else {
            child.rotation.x = armMove;
          }
        }
      });
    } else {
      // Resetar posi√ß√µes quando parado
      playerModel.traverse(child => {
        if (child.userData.isLeg || child.userData.isArm) {
          child.rotation.x *= 0.9;
        }
      });
    }

    // Balan√ßo de cabe√ßa baseado na rota√ß√£o da c√¢mera
    playerModel.traverse(child => {
      if (child.userData.isHead) {
        child.rotation.y = mouse.x * 0.1;
        child.rotation.x = mouse.y * 0.1;
      }
    });
  }

  const originalHandleMouseDown = handleMouseDown;
  handleMouseDown = function(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;

    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

    // Verificar inimigos primeiro
    if (e.button === 0) {
      const enemyIntersects = raycaster.intersectObjects(enemyMeshes);
      if (enemyIntersects.length > 0) {
        const enemyMesh = enemyIntersects[0].object;
        let enemy = null;

        // Encontrar o grupo pai que cont√©m a refer√™ncia ao inimigo
        let current = enemyMesh;
        while (current && !enemy) {
          if (current.userData && current.userData.enemyRef) {
            enemy = current.userData.enemyRef;
          }
          current = current.parent;
        }

        if (enemy) {
          enemy.damage(5);
          return;
        }
      }
    }

    // Chamar fun√ß√£o original para blocos e animais
    originalHandleMouseDown.call(this, e);
  };

  // Modificar a fun√ß√£o startGame
  const originalStartGame = startGame;
  startGame = function() {
    originalStartGame.call(this);

    // Criar modelo do jogador
    createPlayerModel();

    // Gerar uma vila pr√≥xima ao spawn
    generateVillage(30, 30);

    // Spawnar alguns inimigos
    const chunk = worldToChunk(0, 0);
    for (let cx = chunk.x - 2; cx <= chunk.x + 2; cx++) {
      for (let cz = chunk.z - 2; cz <= chunk.z + 2; cz++) {
        if (Math.random() > 0.7) {
          spawnEnemies(cx, cz);
        }
      }
    }

    initMobileControls();
    animate();
  };

  // Atualizar UI para mostrar contagem de entidades
  document.getElementById('animals-count').parentElement.querySelector('strong').textContent = 'Entidades:';





































  // ============================================
  // VARI√ÅVEIS GLOBAIS ADICIONAIS
  // ============================================

  let sky, waterMeshes = [], particles = [], clouds = [];
  let dayNightCycle = 0;
  const DAY_LENGTH = 120000; // 2 minutos para ciclo completo

  // ============================================
  // PERSONAGEM MELHORADO
  // ============================================


  let playerCharacter = null;

  // ============================================
  // SISTEMA DE √ÅGUA
  // ============================================

  class WaterSystem {
    constructor() {
      this.meshes = [];
      this.waterLevels = new Map();
    }

    createWaterBlock(x, y, z) {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshLambertMaterial({
        color: 0x1E90FF,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide
      });

      const water = new THREE.Mesh(geometry, material);
      water.position.set(x, y, z);
      water.userData.isWater = true;
      water.userData.waveOffset = Math.random() * Math.PI * 2;
      water.userData.baseY = y;

      scene.add(water);
      this.meshes.push(water);
      waterMeshes.push(water);

      return water;
    }

    updateWaves(time) {
      for (const water of this.meshes) {
        if (water.userData.isWater) {
          const waveHeight = Math.sin(time * 2 + water.userData.waveOffset) * 0.05;
          water.position.y = water.userData.baseY + waveHeight;

          // Efeito de transpar√™ncia pulsante
          water.material.opacity = 0.6 + Math.sin(time * 3 + water.userData.waveOffset) * 0.1;
        }
      }
    }

    removeWater(x, y, z) {
      for (let i = this.meshes.length - 1; i >= 0; i--) {
        const water = this.meshes[i];
        if (Math.floor(water.position.x) === x &&
                Math.floor(water.position.y) === y &&
                Math.floor(water.position.z) === z) {
          scene.remove(water);
          water.geometry.dispose();
          water.material.dispose();
          this.meshes.splice(i, 1);

          const waterIndex = waterMeshes.indexOf(water);
          if (waterIndex > -1) waterMeshes.splice(waterIndex, 1);
          break;
        }
      }
    }
  }

  let waterSystem = null;

  // ============================================
  // SISTEMA DE PART√çCULAS OTIMIZADO
  // ============================================

  class ParticleSystem {
    constructor() {
      this.particles = [];
      this.maxParticles = 1000;
      this.pool = [];
      this.initPool();
    }

    initPool() {
      for (let i = 0; i < this.maxParticles; i++) {
        const geometry = new THREE.SphereGeometry(0.05, 3, 3);
        const material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const particle = new THREE.Mesh(geometry, material);
        particle.visible = false;
        scene.add(particle);
        this.pool.push(particle);
      }
    }

    emit(position, color, count = 10, velocity = 0.1) {
      for (let i = 0; i < Math.min(count, this.pool.length); i++) {
        const particle = this.pool.pop();
        if (!particle) break;

        particle.position.copy(position);
        particle.position.add(new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2
        ));

        particle.material.color.set(color);
        particle.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * velocity,
                Math.random() * velocity * 0.5,
                (Math.random() - 0.5) * velocity
        );
        particle.userData.life = 1.0;
        particle.userData.decay = 0.02 + Math.random() * 0.02;
        particle.visible = true;

        this.particles.push(particle);
      }
    }

    update() {
      for (let i = this.particles.length - 1; i >= 0; i--) {
        const particle = this.particles[i];

        particle.userData.life -= particle.userData.decay;
        particle.position.add(particle.userData.velocity);
        particle.userData.velocity.y -= 0.01;

        particle.material.opacity = particle.userData.life;
        particle.scale.setScalar(particle.userData.life);

        if (particle.userData.life <= 0) {
          particle.visible = false;
          this.pool.push(particle);
          this.particles.splice(i, 1);
        }
      }
    }
  }

  let particleSystem = null;

  // ============================================
  // C√âU DIN√ÇMICO E ILUMINA√á√ÉO
  // ============================================

  function createSky() {
    // C√©u gradient
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const context = canvas.getContext('2d');

    const gradient = context.createLinearGradient(0, 0, 0, 256);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(0.5, '#98D8F0');
    gradient.addColorStop(1, '#B0E0E6');

    context.fillStyle = gradient;
    context.fillRect(0, 0, 256, 256);

    const texture = new THREE.CanvasTexture(canvas);
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.BackSide,
      fog: false
    });

    sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);
  }

  function createClouds() {
    const cloudCount = 30;
    for (let i = 0; i < cloudCount; i++) {
      const cloudGroup = new THREE.Group();

      // Criar nuvem com m√∫ltiplas esferas
      const cloudPieces = 3 + Math.floor(Math.random() * 3);
      for (let j = 0; j < cloudPieces; j++) {
        const size = 3 + Math.random() * 2;
        const geometry = new THREE.SphereGeometry(size, 8, 8);
        const material = new THREE.MeshLambertMaterial({
          color: 0xFFFFFF,
          transparent: true,
          opacity: 0.8
        });

        const piece = new THREE.Mesh(geometry, material);
        piece.position.set(
                (Math.random() - 0.5) * 8,
                (Math.random() - 0.5) * 3,
                (Math.random() - 0.5) * 8
        );
        cloudGroup.add(piece);
      }

      // Posicionar nuvem no c√©u
      cloudGroup.position.set(
              (Math.random() - 0.5) * 400,
              80 + Math.random() * 40,
              (Math.random() - 0.5) * 400
      );

      cloudGroup.userData.speed = 0.01 + Math.random() * 0.02;
      cloudGroup.userData.direction = new THREE.Vector3(
              Math.random() - 0.5,
              0,
              Math.random() - 0.5
      ).normalize();

      scene.add(cloudGroup);
      clouds.push(cloudGroup);
    }
  }

  function updateDayNightCycle(deltaTime) {
    dayNightCycle = (dayNightCycle + deltaTime * 0.001) % 1;

    const timeOfDay = Math.sin(dayNightCycle * Math.PI * 2);
    const brightness = Math.max(0.3, timeOfDay * 0.5 + 0.5);

    // Atualizar luz ambiente
    scene.traverse(object => {
      if (object.isLight && object.type !== 'AmbientLight') {
        object.intensity = brightness;
      }
    });

    // Atualizar cor do c√©u
    if (sky && sky.material.map) {
      const canvas = sky.material.map.image;
      const context = canvas.getContext('2d');

      const dayColor = `rgb(${135 * brightness}, ${206 * brightness}, ${235 * brightness})`;
      const nightColor = `rgb(${10 * brightness}, ${10 * brightness}, ${40 * brightness})`;

      const gradient = context.createLinearGradient(0, 0, 0, 256);
      gradient.addColorStop(0, timeOfDay > 0 ? dayColor : nightColor);
      gradient.addColorStop(1, timeOfDay > 0 ?
              `rgb(${152 * brightness}, ${216 * brightness}, ${240 * brightness})` :
              `rgb(${5 * brightness}, ${5 * brightness}, ${20 * brightness})`);

      context.fillStyle = gradient;
      context.fillRect(0, 0, 256, 256);

      sky.material.map.needsUpdate = true;
    }

    // Mover nuvens
    clouds.forEach(cloud => {
      cloud.position.add(cloud.userData.direction.clone().multiplyScalar(cloud.userData.speed));

      // Reposicionar nuvens que sa√≠ram do mapa
      if (cloud.position.length() > 500) {
        cloud.position.set(
                (Math.random() - 0.5) * 400,
                80 + Math.random() * 40,
                (Math.random() - 0.5) * 400
        );
      }
    });
  }

  // ============================================
  // SISTEMA DE TEXTURAS PROCEDURAIS
  // ============================================

  const textureCache = {};

  function createTexture(type, size = 64) {
    if (textureCache[type]) return textureCache[type];

    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    switch(type) {
      case 'grass':
        createGrassTexture(ctx, size);
        break;

      case 'dirt':
        createDirtTexture(ctx, size);
        break;

      case 'stone':
        createStoneTexture(ctx, size);
        break;

      case 'wood':
        createWoodTexture(ctx, size);
        break;

      case 'leaves':
        createLeavesTexture(ctx, size);
        break;

      case 'sand':
        createSandTexture(ctx, size);
        break;

      case 'cobblestone':
        createCobblestoneTexture(ctx, size);
        break;

      case 'planks':
        createPlanksTexture(ctx, size);
        break;

      case 'brick':
        createBrickTexture(ctx, size);
        break;

      case 'obsidian':
        createObsidianTexture(ctx, size);
        break;

      case 'glowstone':
        createGlowstoneTexture(ctx, size);
        break;

      case 'quartz':
        createQuartzTexture(ctx, size);
        break;

      case 'bookshelf':
        createBookshelfTexture(ctx, size);
        break;

      case 'coal_ore':
        createStoneTexture(ctx, size);
        // Veios de carv√£o
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(52, 52, 52, 0.8)';
          ctx.fillRect(x, y, 6, 6);
        }
        break;

      case 'iron_ore':
        createStoneTexture(ctx, size);
        // Manchas de ferro
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(216, 175, 147, 0.7)';
          ctx.fillRect(x, y, 8, 8);
        }
        break;

      case 'diamond_ore':
        createStoneTexture(ctx, size);
        // Cristais de diamante
        for (let i = 0; i < 12; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(0, 206, 209, 0.9)';
          ctx.fillRect(x, y, 6, 6);
          // Brilho
          ctx.fillStyle = 'rgba(100, 255, 255, 0.5)';
          ctx.fillRect(x + 2, y + 2, 2, 2);
        }
        break;

      case 'gold_ore':
        createStoneTexture(ctx, size);
        // Veios de ouro
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
          ctx.fillRect(x, y, 7, 7);
          // Brilho dourado
          ctx.fillStyle = 'rgba(255, 235, 100, 0.4)';
          ctx.fillRect(x + 1, y + 1, 3, 3);
        }
        break;

      case 'emerald_ore':
        createStoneTexture(ctx, size);
        // Cristais de esmeralda
        for (let i = 0; i < 12; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(80, 200, 120, 0.9)';
          ctx.fillRect(x, y, 6, 6);
          // Brilho verde
          ctx.fillStyle = 'rgba(100, 255, 150, 0.4)';
          ctx.fillRect(x + 2, y + 2, 2, 2);
        }
        break;

      case 'redstone_ore':
        createStoneTexture(ctx, size);
        // Veios de redstone
        for (let i = 0; i < 18; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
          ctx.fillRect(x, y, 5, 5);
          // Brilho vermelho
          ctx.fillStyle = 'rgba(255, 50, 50, 0.5)';
          ctx.fillRect(x + 1, y + 1, 2, 2);
        }
        break;

      case 'lapis_ore':
        createStoneTexture(ctx, size);
        // Manchas de l√°pis-laz√∫li
        for (let i = 0; i < 16; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(0, 0, 255, 0.8)';
          ctx.fillRect(x, y, 6, 6);
        }
        break;

      case 'gravel':
        // Base cinza
        ctx.fillStyle = '#8B8680';
        ctx.fillRect(0, 0, size, size);
        // Pedrinhas
        for (let i = 0; i < size * 10; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgb(${139 + shade}, ${134 + shade}, ${128 + shade})`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'clay':
        // Base cinza claro
        ctx.fillStyle = '#A0A0A0';
        ctx.fillRect(0, 0, size, size);
        // Textura de argila
        for (let i = 0; i < size * 8; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 30 - 15;
          ctx.fillStyle = `rgb(${160 + shade}, ${160 + shade}, ${160 + shade})`;
          ctx.fillRect(x, y, 3, 3);
        }
        break;

      case 'ice':
        // Base azul claro
        ctx.fillStyle = '#B0E0E6';
        ctx.fillRect(0, 0, size, size);
        // Cristais de gelo
        for (let i = 0; i < 30; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(200, 230, 240, 0.5)';
          ctx.fillRect(x, y, 4, 4);
        }
        // Brilhos
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'snow':
        // Base branca
        ctx.fillStyle = '#FFFAFA';
        ctx.fillRect(0, 0, size, size);
        // Cristais de neve
        for (let i = 0; i < size * 6; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(240, 248, 255, 0.8)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'glass':
        // Base transparente azulada
        ctx.fillStyle = '#ADD8E6';
        ctx.fillRect(0, 0, size, size);
        // Reflexos
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.fillRect(x, y, 6, 2);
        }
        break;

      case 'lantern':
        // Base met√°lica
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(0, 0, size, size);
        // Grades
        ctx.strokeStyle = '#8B7500';
        ctx.lineWidth = 2;
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.moveTo(i * size/4, 0);
          ctx.lineTo(i * size/4, size);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, i * size/4);
          ctx.lineTo(size, i * size/4);
          ctx.stroke();
        }
        // Luz central
        const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/3);
        gradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
        gradient.addColorStop(1, 'rgba(255, 215, 0, 0.3)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        break;

      case 'torch':
        // Base escura
        ctx.fillStyle = '#654321';
        ctx.fillRect(0, 0, size, size);
        // Cabo da tocha
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(size/2 - 4, size/2, 8, size/2);
        // Fogo
        const torchGradient = ctx.createRadialGradient(size/2, size/3, 0, size/2, size/3, size/3);
        torchGradient.addColorStop(0, 'rgba(255, 255, 100, 1)');
        torchGradient.addColorStop(0.5, 'rgba(255, 140, 0, 0.8)');
        torchGradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
        ctx.fillStyle = torchGradient;
        ctx.beginPath();
        ctx.arc(size/2, size/3, size/3, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'prismarine':
        // Base turquesa
        ctx.fillStyle = '#4ECDC4';
        ctx.fillRect(0, 0, size, size);
        // Padr√£o oce√¢nico
        for (let i = 0; i < size * 8; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 60 - 30;
          ctx.fillStyle = `rgba(${78 + shade}, ${205 + shade}, ${196 + shade}, 0.7)`;
          ctx.fillRect(x, y, 4, 4);
        }
        break;

      case 'purpur':
        // Base roxa
        ctx.fillStyle = '#A569BD';
        ctx.fillRect(0, 0, size, size);
        // Padr√£o de purpur
        for (let i = 0; i < size * 6; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgba(${165 + shade}, ${105 + shade}, ${189 + shade}, 0.8)`;
          ctx.fillRect(x, y, 5, 5);
        }
        break;

      case 'endstone':
        // Base amarelada
        ctx.fillStyle = '#E4E096';
        ctx.fillRect(0, 0, size, size);
        // Textura porosa
        for (let i = 0; i < size * 10; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgba(${228 + shade}, ${224 + shade}, ${150 + shade}, 0.8)`;
          ctx.fillRect(x, y, 3, 3);
        }
        break;

      case 'netherite':
        // Base roxa escura
        ctx.fillStyle = '#8B008B';
        ctx.fillRect(0, 0, size, size);
        // Padr√£o met√°lico
        for (let i = 0; i < 40; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(139, 0, 139, 0.6)';
          ctx.fillRect(x, y, 6, 6);
        }
        // Brilhos met√°licos
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(200, 100, 200, 0.4)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_white':
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, size, size);
        // Textura lisa
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(240, 240, 240, 0.3)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_red':
        ctx.fillStyle = '#DC143C';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 20 - 10;
          ctx.fillStyle = `rgba(${220 + shade}, ${20 + shade}, ${60 + shade}, 0.3)`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_blue':
        ctx.fillStyle = '#1E90FF';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 20 - 10;
          ctx.fillStyle = `rgba(${30 + shade}, ${144 + shade}, ${255 + shade}, 0.3)`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_green':
        ctx.fillStyle = '#32CD32';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 20 - 10;
          ctx.fillStyle = `rgba(${50 + shade}, ${205 + shade}, ${50 + shade}, 0.3)`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_yellow':
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 20 - 10;
          ctx.fillStyle = `rgba(${255 + shade}, ${215 + shade}, ${0 + shade}, 0.3)`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_black':
        ctx.fillStyle = '#2F4F4F';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(40, 60, 60, 0.3)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'crafting_table':
        // Base madeira
        createPlanksTexture(ctx, size);
        // Grade de ferramentas no topo
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 2;
        ctx.strokeRect(size/4, size/4, size/2, size/2);
        ctx.beginPath();
        ctx.moveTo(size/2, size/4);
        ctx.lineTo(size/2, 3*size/4);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(size/4, size/2);
        ctx.lineTo(3*size/4, size/2);
        ctx.stroke();
        break;

      case 'furnace':
        createStoneTexture(ctx, size);
        // Abertura da fornalha
        ctx.fillStyle = '#1C1C1C';
        ctx.fillRect(size/4, size/3, size/2, size/3);
        // Borda
        ctx.strokeStyle = '#4A4A4A';
        ctx.lineWidth = 3;
        ctx.strokeRect(size/4, size/3, size/2, size/3);
        break;

      case 'chest':
        createPlanksTexture(ctx, size);
        // Tranca
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(size/2 - 6, size/2 - 4, 12, 8);
        // Detalhes met√°licos
        ctx.strokeStyle = '#8B7500';
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, size, size);
        ctx.beginPath();
        ctx.moveTo(0, size/2);
        ctx.lineTo(size, size/2);
        ctx.stroke();
        break;

      case 'mushroom_red':
        // Base vermelha
        ctx.fillStyle = '#FF0000';
        ctx.fillRect(0, 0, size, size);
        // Pintas brancas
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const r = 2 + Math.random() * 4;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }
        break;

      case 'mushroom_brown':
        // Base marrom
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(0, 0, size, size);
        // Textura de cogumelo
        for (let i = 0; i < size * 5; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgba(${139 + shade}, ${69 + shade}, ${19 + shade}, 0.6)`;
          ctx.fillRect(x, y, 3, 3);
        }
        break;

      case 'pumpkin':
        // Base laranja
        ctx.fillStyle = '#FF8C00';
        ctx.fillRect(0, 0, size, size);
        // Gomos verticais
        ctx.strokeStyle = '#CC7000';
        ctx.lineWidth = 3;
        for (let i = 1; i < 4; i++) {
          ctx.beginPath();
          ctx.moveTo(i * size/4, 0);
          ctx.lineTo(i * size/4, size);
          ctx.stroke();
        }
        // Rosto (opcional)
        ctx.fillStyle = '#000000';
        ctx.fillRect(size/4, size/3, 8, 8);
        ctx.fillRect(3*size/4 - 8, size/3, 8, 8);
        ctx.fillRect(size/3, 2*size/3, size/3, 6);
        break;

      case 'melon':
        // Base verde clara
        ctx.fillStyle = '#90EE90';
        ctx.fillRect(0, 0, size, size);
        // Listras verdes escuras
        ctx.strokeStyle = '#228B22';
        ctx.lineWidth = 4;
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.moveTo(0, i * size/4);
          ctx.lineTo(size, i * size/4);
          ctx.stroke();
        }
        break;

      case 'water':
        // Base azul
        ctx.fillStyle = '#1E90FF';
        ctx.fillRect(0, 0, size, size);
        // Ondas
        for (let i = 0; i < 10; i++) {
          const y = i * size/10;
          ctx.strokeStyle = 'rgba(100, 149, 237, 0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let x = 0; x < size; x += 4) {
            const wave = Math.sin(x * 0.1 + i) * 3;
            ctx.lineTo(x, y + wave);
          }
          ctx.stroke();
        }
        // Brilhos
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(173, 216, 230, 0.4)';
          ctx.fillRect(x, y, 3, 3);
        }
        break;

      case 'bedrock':
        // Base muito escura
        ctx.fillStyle = '#2F2F2F';
        ctx.fillRect(0, 0, size, size);
        // Padr√£o irregular
        for (let i = 0; i < size * 12; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 30 - 15;
          ctx.fillStyle = `rgb(${47 + shade}, ${47 + shade}, ${47 + shade})`;
          ctx.fillRect(x, y, 4, 4);
        }
        // Manchas pretas
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(x, y, 6, 6);
        }
        break;

      default:
        createDefaultTexture(ctx, size, blockTypes[type]?.color || 0x808080);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    textureCache[type] = texture;
    return texture;
  }

  function createGrassTexture(ctx, size) {
    // Base verde vibrante
    const gradient = ctx.createLinearGradient(0, 0, 0, size);
    gradient.addColorStop(0, '#7CFC00');
    gradient.addColorStop(0.5, '#6BCD00');
    gradient.addColorStop(1, '#5AB000');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Camadas de grama
    for (let layer = 0; layer < 3; layer++) {
      for (let i = 0; i < size * 10; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const shade = Math.random() * 50 - 25;
        const opacity = 0.3 + Math.random() * 0.4;
        ctx.fillStyle = `rgba(${100 + shade}, ${200 + shade}, ${0}, ${opacity})`;
        ctx.fillRect(x, y, 2, 2);
      }
    }

    // Manchas escuras (sombras)
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 3;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(0, 80, 0, 0.3)');
      grd.addColorStop(1, 'rgba(0, 80, 0, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Brilhos
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(150, 255, 100, 0.4)';
      ctx.fillRect(x, y, 1, 1);
    }
  }
  function createDirtTexture(ctx, size) {
    // Base marrom
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(0, 0, size, size);

    // Textura de terra
    for (let i = 0; i < size * 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60 - 30;
      ctx.fillStyle = `rgb(${139 + shade}, ${69 + shade}, ${19 + shade})`;
      ctx.fillRect(x, y, Math.random() * 3, Math.random() * 3);
    }

    // Pedrinhas
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
      ctx.fillRect(x, y, 2, 2);
    }
  }

  function createStoneTexture(ctx, size) {
    // Base cinza
    ctx.fillStyle = '#808080';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de pedra
    for (let i = 0; i < size * 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 80 - 40;
      ctx.fillStyle = `rgb(${128 + shade}, ${128 + shade}, ${128 + shade})`;
      ctx.fillRect(x, y, Math.random() * 4, Math.random() * 4);
    }

    // Rachaduras
    ctx.strokeStyle = 'rgba(50, 50, 50, 0.3)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 8; i++) {
      ctx.beginPath();
      ctx.moveTo(Math.random() * size, Math.random() * size);
      ctx.lineTo(Math.random() * size, Math.random() * size);
      ctx.stroke();
    }
  }

  function createWoodTexture(ctx, size) {
    // Base madeira
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, size, size);

    // An√©is de crescimento
    const centerX = size / 2;
    const centerY = size / 2;

    for (let r = 5; r < size; r += 4) {
      ctx.strokeStyle = `rgba(${80 + Math.random() * 40}, ${50 + Math.random() * 30}, ${20 + Math.random() * 20}, ${0.3 + Math.random() * 0.3})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Veios de madeira
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(80, 50, 20, 0.2)';
      ctx.fillRect(x, y, 1, size);
    }
  }

  function createLeavesTexture(ctx, size) {
    // Base verde escuro
    ctx.fillStyle = '#228B22';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de folhas
    for (let i = 0; i < size * 6; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60 - 30;
      ctx.fillStyle = `rgba(${34 + shade}, ${139 + shade}, ${34 + shade}, 0.8)`;
      ctx.fillRect(x, y, 3, 3);
    }

    // Folhas individuais
    for (let i = 0; i < 40; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = `rgba(50, 200, 50, ${0.3 + Math.random() * 0.3})`;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function createSandTexture(ctx, size) {
    // Base areia
    ctx.fillStyle = '#F4A460';
    ctx.fillRect(0, 0, size, size);

    // Gr√£os de areia
    for (let i = 0; i < size * 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgb(${244 + shade}, ${164 + shade}, ${96 + shade})`;
      ctx.fillRect(x, y, 1, 1);
    }
  }

  function createCobblestoneTexture(ctx, size) {
    // Base cinza escuro
    ctx.fillStyle = '#6B6B6B';
    ctx.fillRect(0, 0, size, size);

    // Pedras individuais
    const stones = 16;
    const stoneSize = size / 4;

    for (let i = 0; i < stones; i++) {
      const x = (i % 4) * stoneSize + Math.random() * 8;
      const y = Math.floor(i / 4) * stoneSize + Math.random() * 8;
      const w = stoneSize - Math.random() * 4;
      const h = stoneSize - Math.random() * 4;

      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgb(${107 + shade}, ${107 + shade}, ${107 + shade})`;
      ctx.fillRect(x, y, w, h);

      // Contorno
      ctx.strokeStyle = 'rgba(40, 40, 40, 0.5)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, w, h);
    }
  }

  function createPlanksTexture(ctx, size) {
    // Base madeira clara
    ctx.fillStyle = '#C19A6B';
    ctx.fillRect(0, 0, size, size);

    // T√°buas horizontais
    const plankHeight = size / 4;
    for (let i = 0; i < 4; i++) {
      const y = i * plankHeight;
      const shade = Math.random() * 30 - 15;
      ctx.fillStyle = `rgb(${193 + shade}, ${154 + shade}, ${107 + shade})`;
      ctx.fillRect(0, y, size, plankHeight - 2);

      // Veios
      for (let j = 0; j < 20; j++) {
        const x = Math.random() * size;
        ctx.fillStyle = 'rgba(140, 100, 60, 0.2)';
        ctx.fillRect(x, y, 1, plankHeight);
      }

      // Linha entre t√°buas
      ctx.fillStyle = 'rgba(80, 60, 40, 0.5)';
      ctx.fillRect(0, y + plankHeight - 2, size, 2);
    }
  }

  function createBrickTexture(ctx, size) {
    // Base tijolo
    ctx.fillStyle = '#B22222';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de tijolos
    const brickW = size / 4;
    const brickH = size / 8;

    for (let row = 0; row < 8; row++) {
      const offset = (row % 2) * (brickW / 2);
      for (let col = 0; col < 5; col++) {
        const x = col * brickW + offset;
        const y = row * brickH;

        if (x < size && y < size) {
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgb(${178 + shade}, ${34 + shade}, ${34 + shade})`;
          ctx.fillRect(x, y, brickW - 2, brickH - 2);

          // Argamassa
          ctx.fillStyle = '#CCCCCC';
          ctx.fillRect(x, y + brickH - 2, brickW, 2);
          ctx.fillRect(x + brickW - 2, y, 2, brickH);
        }
      }
    }
  }

  function createObsidianTexture(ctx, size) {
    // Base preta
    ctx.fillStyle = '#1C1C2E';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o v√≠treo
    for (let i = 0; i < size * 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60;
      ctx.fillStyle = `rgba(${28 + shade}, ${28 + shade}, ${46 + shade}, 0.6)`;
      ctx.fillRect(x, y, 2, 2);
    }

    // Brilhos
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(100, 100, 150, 0.3)';
      ctx.fillRect(x, y, 3, 3);
    }
  }

  function createGlowstoneTexture(ctx, size) {
    // Base luminosa
    ctx.fillStyle = '#FFFF99';
    ctx.fillRect(0, 0, size, size);

    // Cristais brilhantes
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 50;
      ctx.fillStyle = `rgb(${255}, ${255 - shade}, ${153 + shade})`;
      ctx.fillRect(x, y, 4, 4);
    }

    // Pontos de luz
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, 6);
      gradient.addColorStop(0, 'rgba(255, 255, 200, 0.8)');
      gradient.addColorStop(1, 'rgba(255, 255, 150, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(x - 6, y - 6, 12, 12);
    }
  }

  function createQuartzTexture(ctx, size) {
    // Base branca
    ctx.fillStyle = '#F5F5F5';
    ctx.fillRect(0, 0, size, size);

    // Veios de quartzo
    ctx.strokeStyle = 'rgba(230, 230, 230, 0.5)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 15; i++) {
      ctx.beginPath();
      ctx.moveTo(Math.random() * size, Math.random() * size);
      ctx.lineTo(Math.random() * size, Math.random() * size);
      ctx.stroke();
    }

    // Cristais pequenos
    for (let i = 0; i < size * 5; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.fillRect(x, y, 2, 2);
    }
  }

  function createBookshelfTexture(ctx, size) {
    // Base madeira
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, size, size);

    // Livros
    const bookWidth = size / 8;
    const bookHeight = size / 2;
    const colors = ['#8B0000', '#00008B', '#006400', '#8B4513', '#4B0082', '#FF8C00'];

    for (let i = 0; i < 8; i++) {
      const x = i * bookWidth;
      const y = size / 4;
      const color = colors[Math.floor(Math.random() * colors.length)];

      ctx.fillStyle = color;
      ctx.fillRect(x, y, bookWidth - 2, bookHeight);

      // Lombada do livro
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(x + 2, y + 5, bookWidth - 6, 2);
    }

    // Prateleiras
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(0, 0, size, 4);
    ctx.fillRect(0, size - 4, size, 4);
  }

  function createDefaultTexture(ctx, size, color) {
    const r = (color >> 16) & 255;
    const g = (color >> 8) & 255;
    const b = color & 255;

    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    ctx.fillRect(0, 0, size, size);

    // Ru√≠do b√°sico
    for (let i = 0; i < size * 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgb(${r + shade}, ${g + shade}, ${b + shade})`;
      ctx.fillRect(x, y, 2, 2);
    }
  }
  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 60, 120);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 25, 0);

    renderer = new THREE.WebGLRenderer({
      antialias: true,
      powerPreference: "high-performance",
      alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    raycaster = new THREE.Raycaster();
    raycaster.far = REACH;

    // Ilumina√ß√£o aprimorada
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(100, 100, 50);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 500;
    sun.shadow.camera.left = -100;
    sun.shadow.camera.right = 100;
    sun.shadow.camera.top = 100;
    sun.shadow.camera.bottom = -100;
    scene.add(sun);

    const ambient = new THREE.AmbientLight(0x404040, 0.9);
    scene.add(ambient);

    // Criar sistemas
    createSky();
    createClouds();
    waterSystem = new WaterSystem();
    particleSystem = new ParticleSystem();

    createMaterialsWithEmissive();
    // Inicializar invent√°rio
    initializeInventory();
    createHealthUI();
    createInventoryUI();
    createFullInventoryUI();
    setupEventListeners();
  }


  function buildWatchTower(x, y, z) {
    // Base da torre (5x5)
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'cobblestone');
      }
    }

    // Paredes da torre (3x3 interna)
    for (let dy = 0; dy < 12; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          if (Math.abs(dx) === 2 || Math.abs(dz) === 2) {
            // Abertura para entrada
            if (dy === 0 && dx === 2 && dz === 0) {
              continue;
            }
            // Aberturas para janelas/amiras
            if (dy > 5 && dy < 10 && (dx === 2 || dz === 2)) {
              if (Math.random() > 0.7) {
                continue;
              }
            }
            setBlock(x + dx, y + dy, z + dz, 'cobblestone');
          }
        }
      }
    }

    // Escada interna em espiral
    const stairBlocks = [
      { x: 1, z: 1, yOffset: 0 },
      { x: 1, z: 0, yOffset: 1 },
      { x: 1, z: -1, yOffset: 2 },
      { x: 0, z: -1, yOffset: 3 },
      { x: -1, z: -1, yOffset: 4 },
      { x: -1, z: 0, yOffset: 5 },
      { x: -1, z: 1, yOffset: 6 },
      { x: 0, z: 1, yOffset: 7 }
    ];

    for (let level = 0; level < 10; level++) {
      const stair = stairBlocks[level % stairBlocks.length];
      setBlock(x + stair.x, y + level, z + stair.z, 'planks');

      // Remover bloco acima para passagem
      removeBlockData(x + stair.x, y + level + 1, z + stair.z);
    }

    // Topo da torre com ameias
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        if (Math.abs(dx) === 2 || Math.abs(dz) === 2) {
          setBlock(x + dx, y + 12, z + dz, 'cobblestone');
          // Ameias alternadas
          if ((dx + dz) % 2 === 0) {
            setBlock(x + dx, y + 13, z + dz, 'cobblestone');
          }
        }
      }
    }

    // Laje superior
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + dx, y + 12, z + dz, 'planks');
      }
    }

    // Tocha no topo
    setBlock(x, y + 14, z, 'torch');

    // Poste com lanterna na entrada
    setBlock(x + 3, y, z, 'planks');
    setBlock(x + 3, y + 1, z, 'planks');
    setBlock(x + 3, y + 2, z, 'lantern');

    // Bandeira decorativa (usando madeira e l√£)
    for (let dy = 0; dy < 4; dy++) {
      setBlock(x - 2, y + 8 + dy, z - 2, 'wood');
    }

    // Bandeira (bloco de l√£ vermelha)
    setBlock(x - 2, y + 12, z - 2, 'concrete_red');
    setBlock(x - 2, y + 12, z - 3, 'concrete_red');
    setBlock(x - 3, y + 12, z - 2, 'concrete_red');

    // Pequeno arsenal dentro da torre
    setBlock(x, y + 1, z, 'chest');
    setBlock(x, y + 2, z, 'planks'); // Prateleira
  }

  function buildDetailedFarm(x, y, z) {
    // Cerca externa expandida (16x16)
    for (let dx = -8; dx <= 8; dx++) {
      setBlock(x + dx, y, z - 8, 'planks');
      setBlock(x + dx, y + 1, z - 8, 'planks');
      setBlock(x + dx, y, z + 8, 'planks');
      setBlock(x + dx, y + 1, z + 8, 'planks');
    }
    for (let dz = -7; dz <= 7; dz++) {
      setBlock(x - 8, y, z + dz, 'planks');
      setBlock(x - 8, y + 1, z + dz, 'planks');
      setBlock(x + 8, y, z + dz, 'planks');
      setBlock(x + 8, y + 1, z + dz, 'planks');
    }

    // Port√£o de entrada
    removeBlockData(x, y, z + 8);
    removeBlockData(x, y + 1, z + 8);
    removeBlockData(x + 1, y, z + 8);
    removeBlockData(x + 1, y + 1, z + 8);

    // Campos cultivados com canais de irriga√ß√£o
    for (let section = 0; section < 2; section++) {
      const baseZ = section === 0 ? -6 : 2;

      for (let dx = -6; dx <= -1; dx++) {
        for (let dz = 0; dz < 4; dz++) {
          if (dx === -3 || dx === -4) {
            // Canal de √°gua
            setBlock(x + dx, y, z + baseZ + dz, 'glass'); // √Ågua
          } else {
            // Terra cultivada
            setBlock(x + dx, y, z + baseZ + dz, 'dirt');

            // Plantas em diferentes est√°gios
            if (Math.random() > 0.3) {
              const plants = ['leaves', 'mushroom_brown', 'pumpkin'];
              setBlock(x + dx, y + 1, z + baseZ + dz,
                      plants[Math.floor(Math.random() * plants.length)]);
            }
          }
        }
      }
    }

    // Campo de mel√µes
    for (let dx = 1; dx <= 6; dx++) {
      for (let dz = -6; dz <= -2; dz++) {
        setBlock(x + dx, y, z + dz, 'dirt');
        if ((dx + dz) % 2 === 0) {
          setBlock(x + dx, y + 1, z + dz, 'melon');
        }
      }
    }

    // Pomar (√°rvores frut√≠feras)
    const treesPos = [
      { dx: 4, dz: 2 }, { dx: 6, dz: 4 }, { dx: 2, dz: 5 }
    ];

    treesPos.forEach(pos => {
      // Tronco
      for (let dy = 1; dy <= 3; dy++) {
        setBlock(x + pos.dx, y + dy, z + pos.dz, 'wood');
      }
      // Copa
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          setBlock(x + pos.dx + dx, y + 4, z + pos.dz + dz, 'leaves');
          if (Math.random() > 0.5) {
            setBlock(x + pos.dx + dx, y + 3, z + pos.dz + dz, 'leaves');
          }
        }
      }
      // "Frutas" (manchas vermelhas nas folhas)
      if (Math.random() > 0.5) {
        setBlock(x + pos.dx + 1, y + 4, z + pos.dz, 'mushroom_red');
      }
    });

    // Celeiro grande (8x6)
    const barnX = x - 10;
    const barnZ = z;

    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(barnX + dx, y - 1, barnZ + dz, 'planks');
      }
    }

    // Paredes do celeiro
    for (let dy = 0; dy < 5; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        for (let dz = -3; dz <= 3; dz++) {
          if (Math.abs(dx) === 4 || Math.abs(dz) === 3) {
            if (dy <= 2 && dx >= -1 && dx <= 1 && dz === 3) {
              continue; // Porta grande
            }
            setBlock(barnX + dx, y + dy, barnZ + dz, 'planks');
          }
        }
      }
    }

    // Telhado do celeiro
    for (let dy = 0; dy < 3; dy++) {
      const width = 4 - dy;
      for (let dx = -width; dx <= width; dx++) {
        for (let dz = -3; dz <= 3; dz++) {
          setBlock(barnX + dx, y + 5 + dy, barnZ + dz, 'brick');
        }
      }
    }

    // Janela do celeiro (s√≥t√£o)
    setBlock(barnX, y + 6, barnZ + 3, 'glass');

    // Interior do celeiro - Baias
    setBlock(barnX - 3, y + 1, barnZ - 2, 'planks');
    setBlock(barnX - 3, y + 1, barnZ, 'planks');
    setBlock(barnX - 3, y + 1, barnZ + 2, 'planks');

    // Armazenamento (ba√∫s e barris)
    setBlock(barnX + 3, y + 1, barnZ - 2, 'chest');
    setBlock(barnX + 3, y + 1, barnZ - 1, 'chest');
    setBlock(barnX + 3, y + 1, barnZ, 'chest');

    // Ferramentas na parede
    setBlock(barnX + 3, y + 2, barnZ + 2, 'planks');

    // Moinho de vento decorativo
    const millX = x + 12;
    const millZ = z;

    // Base do moinho (torre)
    for (let dy = 0; dy < 8; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
            setBlock(millX + dx, y + dy, millZ + dz, 'cobblestone');
          }
        }
      }
    }

    // Topo do moinho
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(millX + dx, y + 8, millZ + dz, 'brick');
      }
    }

    // P√°s do moinho (simplificadas)
    // Horizontal
    for (let dx = -3; dx <= 3; dx++) {
      setBlock(millX + dx, y + 5, millZ, 'planks');
    }
    // Vertical
    for (let dz = -3; dz <= 3; dz++) {
      setBlock(millX, y + 5 + dz - 3, millZ, 'planks');
    }

    // Janelas do moinho
    setBlock(millX + 1, y + 3, millZ + 1, 'glass');
    setBlock(millX - 1, y + 6, millZ - 1, 'glass');

    // Ilumina√ß√£o
    setBlock(x, y, z, 'planks');
    setBlock(x, y + 1, z, 'planks');
    setBlock(x, y + 2, z, 'lantern');

    setBlock(barnX, y, barnZ + 4, 'planks');
    setBlock(barnX, y + 1, barnZ + 4, 'planks');
    setBlock(barnX, y + 2, barnZ + 4, 'lantern');
  }

  // ADICIONAR esta fun√ß√£o tamb√©m
  function buildGrandLibrary(x, y, z) {
    // Base expandida (11x11)
    for (let dx = -5; dx <= 5; dx++) {
      for (let dz = -5; dz <= 5; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'planks');
      }
    }

    // Paredes principais
    for (let dy = 0; dy < 7; dy++) {
      for (let dx = -5; dx <= 5; dx++) {
        for (let dz = -5; dz <= 5; dz++) {
          if (Math.abs(dx) === 5 || Math.abs(dz) === 5) {
            // Porta dupla
            if (dy <= 2 && dx >= -1 && dx <= 1 && dz === 5) {
              continue;
            }
            setBlock(x + dx, y + dy, z + dz, 'planks');
          }
        }
      }
    }

    // Segundo andar
    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -4; dz <= 4; dz++) {
        setBlock(x + dx, y + 7, z + dz, 'planks');
      }
    }

    // Paredes segundo andar
    for (let dy = 8; dy < 14; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        for (let dz = -4; dz <= 4; dz++) {
          if (Math.abs(dx) === 4 || Math.abs(dz) === 4) {
            setBlock(x + dx, y + dy, z + dz, 'planks');
          }
        }
      }
    }

    // Janelas primeiro andar
    const firstFloorWindows = [
      { dx: -5, dz: -3 }, { dx: -5, dz: 0 }, { dx: -5, dz: 3 },
      { dx: 5, dz: -3 }, { dx: 5, dz: 0 }, { dx: 5, dz: 3 },
      { dx: -3, dz: -5 }, { dx: 0, dz: -5 }, { dx: 3, dz: -5 }
    ];

    firstFloorWindows.forEach(pos => {
      setBlock(x + pos.dx, y + 3, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 4, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 5, z + pos.dz, 'glass');
    });

    // Janelas segundo andar
    const secondFloorWindows = [
      { dx: -4, dz: -2 }, { dx: -4, dz: 2 },
      { dx: 4, dz: -2 }, { dx: 4, dz: 2 },
      { dx: -2, dz: -4 }, { dx: 2, dz: -4 }
    ];

    secondFloorWindows.forEach(pos => {
      setBlock(x + pos.dx, y + 10, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 11, z + pos.dz, 'glass');
    });

    // Estantes ao longo das paredes - Primeiro andar
    const shelfPositions1F = [];
    for (let dz = -4; dz <= 4; dz += 2) {
      shelfPositions1F.push({ dx: -4, dz: dz });
      shelfPositions1F.push({ dx: 4, dz: dz });
    }
    for (let dx = -4; dx <= 4; dx += 2) {
      if (Math.abs(dx) !== 4) {
        shelfPositions1F.push({ dx: dx, dz: -4 });
      }
    }

    shelfPositions1F.forEach(pos => {
      for (let dy = 1; dy <= 5; dy++) {
        setBlock(x + pos.dx, y + dy, z + pos.dz, 'bookshelf');
      }
    });

    // Estantes segundo andar
    const shelfPositions2F = [];
    for (let dz = -3; dz <= 3; dz += 2) {
      shelfPositions2F.push({ dx: -3, dz: dz });
      shelfPositions2F.push({ dx: 3, dz: dz });
    }
    for (let dx = -3; dx <= 3; dx += 2) {
      shelfPositions2F.push({ dx: dx, dz: -3 });
      shelfPositions2F.push({ dx: dx, dz: 3 });
    }

    shelfPositions2F.forEach(pos => {
      for (let dy = 8; dy <= 12; dy++) {
        setBlock(x + pos.dx, y + dy, z + pos.dz, 'bookshelf');
      }
    });

    // Mesa de leitura central - Primeiro andar
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + dx, y + 1, z + dz, 'planks');
      }
    }

    // Cadeiras ao redor da mesa
    setBlock(x - 2, y + 1, z, 'planks');
    setBlock(x + 2, y + 1, z, 'planks');
    setBlock(x, y + 1, z - 2, 'planks');
    setBlock(x, y + 1, z + 2, 'planks');

    // Mesa de trabalho e ba√∫
    setBlock(x + 3, y + 1, z + 3, 'crafting_table');
    setBlock(x + 3, y + 1, z + 4, 'chest');

    // Escada para o segundo andar
    for (let dy = 0; dy < 7; dy++) {
      setBlock(x + 4, y + dy, z - 4, 'planks');
      setBlock(x + 4, y + dy, z - 3, 'planks');
    }

    // Mesa de estudos segundo andar
    for (let dx = -1; dx <= 1; dx++) {
      setBlock(x + dx, y + 8, z, 'planks');
    }

    // Globo decorativo
    setBlock(x - 2, y + 8, z - 2, 'planks');
    setBlock(x - 2, y + 9, z - 2, 'gold_ore');

    // Telhado em camadas
    for (let dy = 0; dy < 4; dy++) {
      const size = 5 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -size; dz <= size; dz++) {
          setBlock(x + dx, y + 14 + dy, z + dz, 'brick');
        }
      }
    }

    // Torre de observa√ß√£o/estudo no topo
    for (let dy = 0; dy < 5; dy++) {
      setBlock(x, y + 18 + dy, z, 'planks');
      setBlock(x + 1, y + 18 + dy, z, 'planks');
      setBlock(x - 1, y + 18 + dy, z, 'planks');
      setBlock(x, y + 18 + dy, z + 1, 'planks');
      setBlock(x, y + 18 + dy, z - 1, 'planks');
    }

    // Janelas da torre
    setBlock(x + 1, y + 21, z, 'glass');
    setBlock(x - 1, y + 21, z, 'glass');
    setBlock(x, y + 21, z + 1, 'glass');
    setBlock(x, y + 21, z - 1, 'glass');

    // Topo da torre com lanterna
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + dx, y + 23, z + dz, 'brick');
      }
    }
    setBlock(x, y + 24, z, 'glowstone');

    // Ilumina√ß√£o interna - Candelabros
    const lightPos = [
      { dx: -3, dz: -3 }, { dx: 3, dz: -3 },
      { dx: -3, dz: 3 }, { dx: 3, dz: 3 }
    ];

    lightPos.forEach(pos => {
      // Primeiro andar
      setBlock(x + pos.dx, y + 1, z + pos.dz, 'planks');
      setBlock(x + pos.dx, y + 2, z + pos.dz, 'planks');
      setBlock(x + pos.dx, y + 3, z + pos.dz, 'lantern');

      // Segundo andar
      setBlock(x + pos.dx, y + 8, z + pos.dz, 'planks');
      setBlock(x + pos.dx, y + 9, z + pos.dz, 'planks');
      setBlock(x + pos.dx, y + 10, z + pos.dz, 'lantern');
    });

    // Entrada decorativa com colunas
    setBlock(x - 2, y, z + 6, 'quartz');
    setBlock(x - 2, y + 1, z + 6, 'quartz');
    setBlock(x - 2, y + 2, z + 6, 'quartz');
    setBlock(x - 2, y + 3, z + 6, 'lantern');

    setBlock(x + 2, y, z + 6, 'quartz');
    setBlock(x + 2, y + 1, z + 6, 'quartz');
    setBlock(x + 2, y + 2, z + 6, 'quartz');
    setBlock(x + 2, y + 3, z + 6, 'lantern');

    // Placa decorativa
    for (let dx = -3; dx <= 3; dx++) {
      setBlock(x + dx, y + 5, z + 5, 'planks');
    }

    // Jardim de leitura ao ar livre
    for (let dx = -7; dx <= -6; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        setBlock(x + dx, y, z + dz, 'grass');
        if (Math.random() > 0.6) {
          setBlock(x + dx, y + 1, z + dz, 'mushroom_red');
        }
      }
    }

    // Bancos no jardim
    setBlock(x - 6, y + 1, z - 1, 'planks');
    setBlock(x - 6, y + 1, z, 'planks');
    setBlock(x - 6, y + 1, z + 1, 'planks');
  }

  function generateChunk(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);
    if (chunks[chunkKey]) return;

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    for (let x = sx; x < sx + CHUNK_SIZE; x++) {
      for (let z = sz; z < sz + CHUNK_SIZE; z++) {
        const height = getHeight(x, z);

        // Bedrock na base
        setBlock(x, 0, z, 'bedrock');

        // Camadas subterr√¢neas
        const stoneHeight = height - 4;
        for (let y = 1; y < stoneHeight; y++) {
          setBlock(x, y, z, 'stone');
        }

        for (let y = stoneHeight; y < height - 1; y++) {
          setBlock(x, y, z, 'dirt');
        }

        setBlock(x, height - 1, z, 'dirt');
        setBlock(x, height, z, 'grass');

        // Adicionar √°rvores
        if (Math.random() > 0.98 && height < 40) {
          generateTree(x, height + 1, z);
        }

        // Adicionar √°gua em vales
        if (height < 10 && Math.random() > 0.7) {
          for (let y = height + 1; y <= 10; y++) {
            setBlock(x, y, z, 'water');
            waterSystem.createWaterBlock(x, y, z);
          }
        }

        // Flores e vegeta√ß√£o
        if (Math.random() > 0.95 && height < 40) {
          setBlock(x, height + 1, z, 'leaves');
        }
      }
    }

    chunks[chunkKey] = true;
  }

  function generateTree(x, y, z) {
    const treeHeight = Math.floor(Math.random() * 4) + 4;

    // Tronco
    for (let i = 0; i < treeHeight; i++) {
      setBlock(x, y + i, z, 'wood');
    }

    // Copa
    const topY = y + treeHeight - 1;
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 3) {
            setBlock(x + dx, topY + dy, z + dz, 'leaves');
          }
        }
      }
    }
  }

  function removeBlock(x, y, z) {
    const block = getBlock(x, y, z);
    if (!block || block.type === 'bedrock') return;

    // Criar part√≠culas do bloco quebrado
    if (particleSystem) {
      const color = blockTypes[block.type] ? blockTypes[block.type].color : 0xFFFFFF;
      particleSystem.emit(
              new THREE.Vector3(x, y, z),
              color,
              15,
              0.2
      );
    }

    // Remover √°gua se for bloco de √°gua
    if (block.type === 'water') {
      waterSystem.removeWater(x, y, z);
    }

    addToInventory(block.type, 1);
    removeBlockData(x, y, z);

    // Reconstruir chunks
    const chunk = worldToChunk(x, z);
    const chunksToUpdate = new Set();
    chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

    const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

    if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
    if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
    if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
    if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

    chunksToUpdate.forEach(key => {
      const [cx, cz] = key.split(',').map(Number);
      if (chunkMeshes[key]) {
        buildChunkMesh(cx, cz);
      }
    });

    updateFaceCount();
  }

  function placeBlock(x, y, z, type) {
    if (getBlock(x, y, z)) return;

    // Verificar se o bloco est√° dentro do jogador
    const playerBox = new THREE.Box3(
            new THREE.Vector3(
                    camera.position.x - PLAYER_WIDTH/2,
                    camera.position.y - PLAYER_HEIGHT/2,
                    camera.position.z - PLAYER_WIDTH/2
            ),
            new THREE.Vector3(
                    camera.position.x + PLAYER_WIDTH/2,
                    camera.position.y + PLAYER_HEIGHT/2,
                    camera.position.z + PLAYER_WIDTH/2
            )
    );

    const blockBox = new THREE.Box3(
            new THREE.Vector3(x - 0.5, y - 0.5, z - 0.5),
            new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5)
    );

    if (playerBox.intersectsBox(blockBox)) return;

    // Verificar se tem o item no invent√°rio
    const selectedItem = getSelectedItem();
    if (selectedItem === type && removeFromInventory(player.selectedSlot, 1)) {
      setBlock(x, y, z, type);

      // Se for √°gua, criar mesh especial
      if (type === 'water') {
        waterSystem.createWaterBlock(x, y, z);
      }

      // Reconstruir chunks afetados
      const chunk = worldToChunk(x, z);
      const chunksToUpdate = new Set();
      chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

      const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
      const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

      if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
      if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
      if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
      if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

      chunksToUpdate.forEach(key => {
        const [cx, cz] = key.split(',').map(Number);
        if (chunkMeshes[key]) {
          buildChunkMesh(cx, cz);
        }
      });

      updateFaceCount();
    }
  }
  // ADICIONAR esta fun√ß√£o
  function buildImprovedChurch(x, y, z) {
    // Base maior e mais elaborada (9x14)
    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -7; dz <= 7; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'cobblestone');
      }
    }

    // Escadaria na entrada
    for (let dx = -2; dx <= 2; dx++) {
      setBlock(x + dx, y, z + 8, 'cobblestone');
      setBlock(x + dx, y + 1, z + 9, 'cobblestone');
    }

    // Paredes principais
    for (let dy = 0; dy < 8; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        for (let dz = -7; dz <= 7; dz++) {
          if (Math.abs(dx) === 4 || Math.abs(dz) === 7) {
            // Porta principal (dupla e alta)
            if (dy <= 3 && dx >= -1 && dx <= 1 && dz === 7) {
              continue;
            }
            setBlock(x + dx, y + dy, z + dz, 'quartz');
          }
        }
      }
    }

    // Pilares decorativos nas laterais
    const pillarPositions = [
      { dx: -4, dz: -5 }, { dx: -4, dz: 0 }, { dx: -4, dz: 5 },
      { dx: 4, dz: -5 }, { dx: 4, dz: 0 }, { dx: 4, dz: 5 }
    ];

    pillarPositions.forEach(pos => {
      for (let dy = 0; dy < 8; dy++) {
        setBlock(x + pos.dx, y + dy, z + pos.dz, 'quartz');

        // Detalhe do pilar
        if (dy % 2 === 0) {
          if (pos.dx === -4) {
            setBlock(x + pos.dx - 1, y + dy, z + pos.dz, 'cobblestone');
          } else {
            setBlock(x + pos.dx + 1, y + dy, z + pos.dz, 'cobblestone');
          }
        }
      }
      // Topo do pilar
      setBlock(x + pos.dx, y + 8, z + pos.dz, 'cobblestone');
    });

    // Janelas laterais em arco (vitrais)
    const windowPositions = [
      { dx: -4, dz: -3 }, { dx: -4, dz: 3 },
      { dx: 4, dz: -3 }, { dx: 4, dz: 3 }
    ];

    windowPositions.forEach(pos => {
      // Janela em arco (3 blocos de altura)
      setBlock(x + pos.dx, y + 3, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 4, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 5, z + pos.dz, 'glass');

      // Moldura da janela
      setBlock(x + pos.dx, y + 2, z + pos.dz, 'cobblestone');
      setBlock(x + pos.dx, y + 6, z + pos.dz, 'cobblestone');
    });

    // Janela grande frontal (ros√°cea)
    for (let dx = -2; dx <= 2; dx++) {
      for (let dy = 5; dy <= 7; dy++) {
        if (Math.abs(dx) <= 2 && dy >= 5) {
          setBlock(x + dx, y + dy, z + 7, 'glass');
        }
      }
    }
    // Moldura da ros√°cea
    for (let dx = -3; dx <= 3; dx++) {
      setBlock(x + dx, y + 4, z + 7, 'cobblestone');
      setBlock(x + dx, y + 8, z + 7, 'cobblestone');
    }

    // Torre do sino (central, mais alta e detalhada)
    for (let dy = 0; dy < 15; dy++) {
      // Base da torre (3x3)
      if (dy < 8) {
        for (let dx = -1; dx <= 1; dx++) {
          for (let dz = -1; dz <= 1; dz++) {
            if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
              setBlock(x + dx, y + 8 + dy, z + dz, 'quartz');
            }
          }
        }
      } else {
        // Torre estreita no topo
        setBlock(x, y + 8 + dy, z, 'quartz');
        setBlock(x + 1, y + 8 + dy, z, 'quartz');
        setBlock(x - 1, y + 8 + dy, z, 'quartz');
        setBlock(x, y + 8 + dy, z + 1, 'quartz');
        setBlock(x, y + 8 + dy, z - 1, 'quartz');
      }
    }

    // Sino (vis√≠vel)
    setBlock(x, y + 18, z, 'gold_ore'); // Sino dourado

    // Aberturas da torre do sino
    setBlock(x + 1, y + 17, z, 'glass');
    setBlock(x - 1, y + 17, z, 'glass');
    setBlock(x, y + 17, z + 1, 'glass');
    setBlock(x, y + 17, z - 1, 'glass');

    // Cruz no topo da torre
    for (let dy = 0; dy < 3; dy++) {
      setBlock(x, y + 23 + dy, z, 'gold_ore');
    }
    setBlock(x - 1, y + 24, z, 'gold_ore');
    setBlock(x + 1, y + 24, z, 'gold_ore');

    // Topo da cruz brilhante
    setBlock(x, y + 26, z, 'glowstone');

    // Telhado principal (em V invertido)
    for (let dy = 0; dy < 5; dy++) {
      const width = 4 - dy;
      for (let dx = -width; dx <= width; dx++) {
        for (let dz = -7; dz <= 7; dz++) {
          setBlock(x + dx, y + 8 + dy, z + dz, 'brick');
        }
      }
    }

    // Detalhes do telhado (beirais)
    for (let dz = -7; dz <= 7; dz++) {
      setBlock(x - 5, y + 8, z + dz, 'cobblestone');
      setBlock(x + 5, y + 8, z + dz, 'cobblestone');
    }

    // Interior - Nave central
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -6; dz <= 6; dz++) {
        // Piso de pedra decorativo
        if ((dx + dz) % 2 === 0) {
          setBlock(x + dx, y, z + dz, 'quartz');
        } else {
          setBlock(x + dx, y, z + dz, 'cobblestone');
        }
      }
    }

    // Altar
    for (let dx = -2; dx <= 2; dx++) {
      setBlock(x + dx, y + 1, z - 6, 'quartz');
    }
    for (let dx = -1; dx <= 1; dx++) {
      setBlock(x + dx, y + 2, z - 6, 'quartz');
    }
    setBlock(x, y + 3, z - 6, 'gold_ore'); // Cruz dourada no altar

    // Bancos (fileiras)
    for (let row = -4; row <= 2; row += 2) {
      // Banco esquerdo
      for (let dz = 0; dz < 3; dz++) {
        setBlock(x - 2, y + 1, z + row + dz, 'planks');
      }
      // Banco direito
      for (let dz = 0; dz < 3; dz++) {
        setBlock(x + 2, y + 1, z + row + dz, 'planks');
      }
    }

    // Candelabros (lanternas suspensas)
    const chandPos = [
      { dz: -4 }, { dz: 0 }, { dz: 4 }
    ];

    chandPos.forEach(pos => {
      // Corrente
      for (let dy = 1; dy <= 4; dy++) {
        setBlock(x, y + dy + 3, z + pos.dz, 'planks');
      }
      // Lanterna
      setBlock(x, y + 3, z + pos.dz, 'lantern');
      setBlock(x + 1, y + 3, z + pos.dz, 'lantern');
      setBlock(x - 1, y + 3, z + pos.dz, 'lantern');
    });

    // Tochas nas paredes
    setBlock(x - 3, y + 3, z - 5, 'torch');
    setBlock(x + 3, y + 3, z - 5, 'torch');
    setBlock(x - 3, y + 3, z, 'torch');
    setBlock(x + 3, y + 3, z, 'torch');
    setBlock(x - 3, y + 3, z + 5, 'torch');
    setBlock(x + 3, y + 3, z + 5, 'torch');

    // √ìrg√£o de tubos (decorativo na parede dos fundos)
    for (let dx = -2; dx <= 2; dx++) {
      for (let dy = 2; dy <= 6; dy++) {
        if (Math.abs(dx) === 2 || dy >= 5) {
          setBlock(x + dx, y + dy, z - 7, 'planks');
        }
      }
    }

    // Jardim lateral direito
    for (let dx = 5; dx <= 7; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(x + dx, y, z + dz, 'grass');
        if (Math.random() > 0.7) {
          setBlock(x + dx, y + 1, z + dz, 'leaves');
        }
      }
    }

    // Jardim lateral esquerdo
    for (let dx = -7; dx <= -5; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(x + dx, y, z + dz, 'grass');
        if (Math.random() > 0.7) {
          setBlock(x + dx, y + 1, z + dz, 'leaves');
        }
      }
    }

    // √Årvores decorativas ao lado
    const treePosLeft = { dx: -6, dz: 0 };
    for (let dy = 1; dy <= 4; dy++) {
      setBlock(x + treePosLeft.dx, y + dy, z + treePosLeft.dz, 'wood');
    }
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + treePosLeft.dx + dx, y + 5, z + treePosLeft.dz + dz, 'leaves');
      }
    }

    const treePosRight = { dx: 6, dz: 0 };
    for (let dy = 1; dy <= 4; dy++) {
      setBlock(x + treePosRight.dx, y + dy, z + treePosRight.dz, 'wood');
    }
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + treePosRight.dx + dx, y + 5, z + treePosRight.dz + dz, 'leaves');
      }
    }

    // Cerca decorativa ao redor do jardim
    for (let dx = -8; dx <= 8; dx++) {
      if (Math.abs(dx) >= 5) {
        setBlock(x + dx, y, z - 4, 'planks');
        setBlock(x + dx, y, z + 4, 'planks');
      }
    }

    // Lanternas de ilumina√ß√£o externa
    setBlock(x - 5, y, z + 8, 'planks');
    setBlock(x - 5, y + 1, z + 8, 'planks');
    setBlock(x - 5, y + 2, z + 8, 'lantern');

    setBlock(x + 5, y, z + 8, 'planks');
    setBlock(x + 5, y + 1, z + 8, 'planks');
    setBlock(x + 5, y + 2, z + 8, 'lantern');

    // Lanternas na torre
    setBlock(x - 2, y + 15, z - 2, 'lantern');
    setBlock(x + 2, y + 15, z - 2, 'lantern');
    setBlock(x - 2, y + 15, z + 2, 'lantern');
    setBlock(x + 2, y + 15, z + 2, 'lantern');
  }

  function generateVillage(centerX, centerZ) {
    const villageY = getHeight(centerX, centerZ) + 1;

    // Limpar e nivelar √°rea maior
    for (let x = -35; x <= 35; x++) {
      for (let z = -35; z <= 35; z++) {
        const wx = centerX + x;
        const wz = centerZ + z;
        const wy = getHeight(wx, wz);

        for (let y = wy; y < villageY; y++) {
          setBlock(wx, y, wz, 'dirt');
        }
        setBlock(wx, villageY, wz, 'grass');

        for (let y = villageY + 1; y < villageY + 20; y++) {
          removeBlockData(wx, y, wz);
        }
      }
    }

    // Cerca ao redor da vila
    buildVillageFence(centerX, villageY, centerZ, 32);

    // Caminhos principais
    createDetailedPaths(centerX, villageY, centerZ);

    // Pra√ßa central com fonte
    buildCentralFountain(centerX, villageY + 1, centerZ);

    // Jardins ao redor da fonte
    buildGardens(centerX, villageY, centerZ);

    // Constru√ß√µes residenciais e comerciais
    const buildings = [
      // Casas grandes
      { x: 0, z: 18, type: 'large_house', profession: 'farmer' },
      { x: 18, z: 0, type: 'large_house', profession: 'librarian' },
      { x: -18, z: 0, type: 'large_house', profession: 'blacksmith' },
      { x: 0, z: -18, type: 'large_house', profession: 'priest' },

      // Casas m√©dias
      { x: 12, z: 12, type: 'house', profession: 'butcher' },
      { x: -12, z: -12, type: 'house', profession: 'fisherman' },
      { x: -12, z: 12, type: 'house', profession: 'shepherd' },
      { x: 12, z: -12, type: 'house', profession: 'fletcher' },

      // Constru√ß√µes especiais
      { x: -15, z: 15, type: 'church' },
      { x: 22, z: -12, type: 'farm' },
      { x: -22, z: -12, type: 'tower' },
      { x: 15, z: -20, type: 'library' },
      { x: -25, z: 5, type: 'market' },
      { x: 25, z: 5, type: 'inn' },
      { x: 5, z: 25, type: 'stable' }
    ];

    buildings.forEach(building => {
      const bx = centerX + building.x;
      const bz = centerZ + building.z;

      switch(building.type) {
        case 'large_house':
          buildLargeHouse(bx, villageY + 1, bz);
          if (building.profession) {
            const villager = new Villager(bx, villageY + 2, bz, building.profession);
            villagers.push(villager);
          }
          break;
        case 'house':
          buildDecoratedHouse(bx, villageY + 1, bz);
          if (building.profession) {
            const villager = new Villager(bx, villageY + 2, bz, building.profession);
            villagers.push(villager);
          }
          break;
        case 'church':
          buildImprovedChurch(bx, villageY + 1, bz);
          break;
        case 'farm':
          buildDetailedFarm(bx, villageY + 1, bz);
          break;
        case 'tower':
          buildWatchTower(bx, villageY + 1, bz);
          break;
        case 'library':
          buildGrandLibrary(bx, villageY + 1, bz);
          break;
        case 'market':
          buildMarketplace(bx, villageY + 1, bz);
          break;
        case 'inn':
          buildInn(bx, villageY + 1, bz);
          break;
        case 'stable':
          buildStable(bx, villageY + 1, bz);
          break;
      }
    });

    // Adicionar vegeta√ß√£o decorativa
    addVillageDecoration(centerX, villageY, centerZ);

    villages.push({ x: centerX, z: centerZ });
  }


  function buildVillageFence(x, y, z, radius) {
    for (let angle = 0; angle < 360; angle += 10) {
      const rad = angle * Math.PI / 180;
      const fx = Math.floor(x + Math.cos(rad) * radius);
      const fz = Math.floor(z + Math.sin(rad) * radius);

      setBlock(fx, y, fz, 'planks');
      setBlock(fx, y + 1, fz, 'planks');

      // Postes a cada 45 graus
      if (angle % 45 === 0) {
        setBlock(fx, y + 2, fz, 'planks');
        setBlock(fx, y + 3, fz, 'torch');
      }
    }
  }

  function createDetailedPaths(centerX, villageY, centerZ) {
    // Caminhos principais em cruz
    for (let i = -30; i <= 30; i++) {
      // Horizontal
      setBlock(centerX + i, villageY, centerZ, 'cobblestone');
      setBlock(centerX + i, villageY, centerZ + 1, 'cobblestone');
      setBlock(centerX + i, villageY, centerZ - 1, 'cobblestone');

      // Bordas decorativas
      if (Math.abs(i) % 3 === 0) {
        setBlock(centerX + i, villageY, centerZ + 2, 'stone');
        setBlock(centerX + i, villageY, centerZ - 2, 'stone');
      }

      // Vertical
      setBlock(centerX, villageY, centerZ + i, 'cobblestone');
      setBlock(centerX + 1, villageY, centerZ + i, 'cobblestone');
      setBlock(centerX - 1, villageY, centerZ + i, 'cobblestone');

      if (Math.abs(i) % 3 === 0) {
        setBlock(centerX + 2, villageY, centerZ + i, 'stone');
        setBlock(centerX - 2, villageY, centerZ + i, 'stone');
      }
    }

    // Lanternas ao longo dos caminhos
    for (let i = -28; i <= 28; i += 7) {
      setBlock(centerX + i, villageY + 1, centerZ + 4, 'planks');
      setBlock(centerX + i, villageY + 2, centerZ + 4, 'lantern');

      setBlock(centerX + i, villageY + 1, centerZ - 4, 'planks');
      setBlock(centerX + i, villageY + 2, centerZ - 4, 'lantern');

      setBlock(centerX + 4, villageY + 1, centerZ + i, 'planks');
      setBlock(centerX + 4, villageY + 2, centerZ + i, 'lantern');

      setBlock(centerX - 4, villageY + 1, centerZ + i, 'planks');
      setBlock(centerX - 4, villageY + 2, centerZ + i, 'lantern');
    }
  }

  function buildCentralFountain(x, y, z) {
    // Base da fonte (mais elaborada)
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist <= 3) {
          setBlock(x + dx, y - 1, z + dz, 'cobblestone');
        }
      }
    }

    // Borda externa
    for (let angle = 0; angle < 360; angle += 45) {
      const rad = angle * Math.PI / 180;
      const fx = Math.floor(x + Math.cos(rad) * 3);
      const fz = Math.floor(z + Math.sin(rad) * 3);
      setBlock(fx, y, fz, 'stone');
      setBlock(fx, y + 1, fz, 'stone');
    }

    // Borda interna com √°gua
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist <= 2 && (Math.abs(dx) === 2 || Math.abs(dz) === 2)) {
          setBlock(x + dx, y, z + dz, 'quartz');
          setBlock(x + dx, y + 1, z + dz, 'quartz');
        } else if (dist < 2) {
          setBlock(x + dx, y, z + dz, 'glass'); // √Ågua
        }
      }
    }

    // Coluna central
    for (let dy = 0; dy < 4; dy++) {
      setBlock(x, y + dy, z, 'quartz');
    }

    // Topo decorativo
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        if (dx !== 0 || dz !== 0) {
          setBlock(x + dx, y + 4, z + dz, 'glowstone');
        }
      }
    }
    setBlock(x, y + 5, z, 'glowstone');

    // Jatos de √°gua decorativos
    for (let angle = 0; angle < 360; angle += 90) {
      const rad = angle * Math.PI / 180;
      const wx = Math.floor(x + Math.cos(rad) * 1.5);
      const wz = Math.floor(z + Math.sin(rad) * 1.5);
      setBlock(wx, y + 2, wz, 'glass');
      setBlock(wx, y + 3, wz, 'glass');
    }
  }

  function buildGardens(centerX, villageY, centerZ) {
    const gardenPositions = [
      { x: 7, z: 7 }, { x: -7, z: 7 },
      { x: 7, z: -7 }, { x: -7, z: -7 }
    ];

    gardenPositions.forEach(pos => {
      const gx = centerX + pos.x;
      const gz = centerZ + pos.z;

      // Canteiro
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          setBlock(gx + dx, villageY, gz + dz, 'dirt');

          // Flores e plantas
          if (Math.random() > 0.6) {
            const plants = ['leaves', 'mushroom_red', 'mushroom_brown'];
            setBlock(gx + dx, villageY + 1, gz + dz, plants[Math.floor(Math.random() * plants.length)]);
          }
        }
      }

      // Cerca ao redor
      for (let dx = -3; dx <= 3; dx++) {
        setBlock(gx + dx, villageY, gz - 3, 'planks');
        setBlock(gx + dx, villageY, gz + 3, 'planks');
      }
      for (let dz = -2; dz <= 2; dz++) {
        setBlock(gx - 3, villageY, gz + dz, 'planks');
        setBlock(gx + 3, villageY, gz + dz, 'planks');
      }

      // √Årvore decorativa
      setBlock(gx, villageY, gz, 'dirt');
      for (let dy = 1; dy <= 3; dy++) {
        setBlock(gx, villageY + dy, gz, 'wood');
      }
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          setBlock(gx + dx, villageY + 4, gz + dz, 'leaves');
        }
      }
    });
  }

  function buildLargeHouse(x, y, z) {
    // Base maior (7x7)
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'planks');
      }
    }

    // Paredes
    for (let dy = 0; dy < 5; dy++) {
      for (let dx = -3; dx <= 3; dx++) {
        for (let dz = -3; dz <= 3; dz++) {
          if (Math.abs(dx) === 3 || Math.abs(dz) === 3) {
            if (dy === 1 && dx === 0 && dz === 3) {
              continue; // Porta
            }
            setBlock(x + dx, y + dy, z + dz, 'planks');
          }
        }
      }
    }

    // Segundo andar
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        setBlock(x + dx, y + 5, z + dz, 'planks');
      }
    }

    // Janelas do segundo andar
    setBlock(x - 2, y + 6, z, 'glass');
    setBlock(x + 2, y + 6, z, 'glass');
    setBlock(x, y + 6, z - 2, 'glass');

    // Telhado em camadas
    for (let dy = 0; dy < 4; dy++) {
      const size = 3 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -size; dz <= size; dz++) {
          setBlock(x + dx, y + 5 + dy, z + dz, 'brick');
        }
      }
    }

    // Chamin√©
    for (let dy = 0; dy < 6; dy++) {
      setBlock(x + 2, y + 5 + dy, z + 2, 'brick');
    }
    setBlock(x + 2, y + 11, z + 2, 'cobblestone');

    // Janelas t√©rreo
    setBlock(x - 3, y + 2, z - 1, 'glass');
    setBlock(x - 3, y + 2, z + 1, 'glass');
    setBlock(x + 3, y + 2, z - 1, 'glass');
    setBlock(x + 3, y + 2, z + 1, 'glass');

    // Jardim da frente
    for (let dx = -2; dx <= 2; dx++) {
      setBlock(x + dx, y, z + 4, 'grass');
      if (Math.random() > 0.7) {
        setBlock(x + dx, y + 1, z + 4, 'leaves');
      }
    }

    // Lanternas na entrada
    setBlock(x - 1, y, z + 3, 'planks');
    setBlock(x - 1, y + 1, z + 3, 'planks');
    setBlock(x - 1, y + 2, z + 3, 'lantern');

    setBlock(x + 1, y, z + 3, 'planks');
    setBlock(x + 1, y + 1, z + 3, 'planks');
    setBlock(x + 1, y + 2, z + 3, 'lantern');
  }

  function buildDecoratedHouse(x, y, z) {
    buildHouse(x, y, z); // Casa base original

    // Adicionar decora√ß√£o externa
    // Varanda
    for (let dx = -1; dx <= 1; dx++) {
      setBlock(x + dx, y, z + 3, 'planks');
    }

    // Colunas da varanda
    setBlock(x - 1, y + 1, z + 3, 'planks');
    setBlock(x + 1, y + 1, z + 3, 'planks');

    // Telhado da varanda
    setBlock(x - 1, y + 2, z + 3, 'brick');
    setBlock(x, y + 2, z + 3, 'brick');
    setBlock(x + 1, y + 2, z + 3, 'brick');

    // Jardim lateral
    setBlock(x + 3, y, z - 1, 'dirt');
    setBlock(x + 3, y, z, 'dirt');
    setBlock(x + 3, y, z + 1, 'dirt');

    setBlock(x + 3, y + 1, z - 1, 'leaves');
    setBlock(x + 3, y + 1, z + 1, 'leaves');

    // Cerca decorativa
    setBlock(x + 4, y, z - 2, 'planks');
    setBlock(x + 4, y, z, 'planks');
    setBlock(x + 4, y, z + 2, 'planks');
  }

  function buildMarketplace(x, y, z) {
    // Plataforma elevada (10x10)
    for (let dx = -5; dx <= 5; dx++) {
      for (let dz = -5; dz <= 5; dz++) {
        setBlock(x + dx, y, z + dz, 'planks');
      }
    }

    // Barracas (4 barracas ao redor)
    const stallPositions = [
      { dx: -3, dz: -3 }, { dx: 3, dz: -3 },
      { dx: -3, dz: 3 }, { dx: 3, dz: 3 }
    ];

    stallPositions.forEach(pos => {
      // Base da barraca
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
            setBlock(x + pos.dx + dx, y + 1, z + pos.dz + dz, 'planks');
          }
        }
      }

      // Pilares
      setBlock(x + pos.dx - 1, y + 2, z + pos.dz - 1, 'planks');
      setBlock(x + pos.dx + 1, y + 2, z + pos.dz - 1, 'planks');
      setBlock(x + pos.dx - 1, y + 2, z + pos.dz + 1, 'planks');
      setBlock(x + pos.dx + 1, y + 2, z + pos.dz + 1, 'planks');

      // Telhado
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          if (Math.abs(dx) <= 2 && Math.abs(dz) <= 2) {
            setBlock(x + pos.dx + dx, y + 3, z + pos.dz + dz, 'planks');
          }
        }
      }

      // Itens na barraca (ba√∫s)
      setBlock(x + pos.dx, y + 1, z + pos.dz, 'chest');
    });

    // Lanterna central
    setBlock(x, y + 1, z, 'planks');
    setBlock(x, y + 2, z, 'planks');
    setBlock(x, y + 3, z, 'planks');
    setBlock(x, y + 4, z, 'lantern');
  }

  function buildInn(x, y, z) {
    // Base grande (8x10)
    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -5; dz <= 5; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'planks');
      }
    }

    // Paredes
    for (let dy = 0; dy < 6; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        for (let dz = -5; dz <= 5; dz++) {
          if (Math.abs(dx) === 4 || Math.abs(dz) === 5) {
            if (dy === 1 && dx === 0 && dz === 5) {
              continue; // Porta principal
            }
            if (dy === 1 && dx === -4 && dz === 0) {
              continue; // Porta lateral
            }
            setBlock(x + dx, y + dy, z + dz, 'planks');
          }
        }
      }
    }

    // Segundo andar
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -4; dz <= 4; dz++) {
        setBlock(x + dx, y + 6, z + dz, 'planks');
      }
    }

    // Janelas - primeiro andar
    for (let dz = -3; dz <= 3; dz += 3) {
      setBlock(x - 4, y + 2, z + dz, 'glass');
      setBlock(x + 4, y + 2, z + dz, 'glass');
    }

    // Janelas - segundo andar
    for (let dx = -2; dx <= 2; dx += 2) {
      setBlock(x + dx, y + 7, z - 4, 'glass');
      setBlock(x + dx, y + 7, z + 4, 'glass');
    }

    // Telhado
    for (let dy = 0; dy < 4; dy++) {
      const size = 4 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -5; dz <= 5; dz++) {
          setBlock(x + dx, y + 6 + dy, z + dz, 'brick');
        }
      }
    }

    // Placa de madeira (simulando placa da pousada)
    setBlock(x - 2, y + 3, z + 5, 'planks');
    setBlock(x - 1, y + 3, z + 5, 'planks');
    setBlock(x, y + 3, z + 5, 'planks');
    setBlock(x + 1, y + 3, z + 5, 'planks');
    setBlock(x + 2, y + 3, z + 5, 'planks');

    // Lanternas na entrada
    setBlock(x - 2, y, z + 6, 'planks');
    setBlock(x - 2, y + 1, z + 6, 'planks');
    setBlock(x - 2, y + 2, z + 6, 'lantern');

    setBlock(x + 2, y, z + 6, 'planks');
    setBlock(x + 2, y + 1, z + 6, 'planks');
    setBlock(x + 2, y + 2, z + 6, 'lantern');

    // Mesa e cadeiras dentro (mob√≠lia b√°sica)
    setBlock(x - 2, y + 1, z - 2, 'planks'); // Mesa
    setBlock(x - 2, y + 1, z + 2, 'planks');
    setBlock(x + 2, y + 1, z - 2, 'planks');
    setBlock(x + 2, y + 1, z + 2, 'planks');
  }

  function buildStable(x, y, z) {
    // Base (12x8)
    for (let dx = -6; dx <= 6; dx++) {
      for (let dz = -4; dz <= 4; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'dirt');
      }
    }

    // Paredes laterais (abertas na frente e atr√°s)
    for (let dy = 0; dy < 4; dy++) {
      for (let dz = -4; dz <= 4; dz++) {
        setBlock(x - 6, y + dy, z + dz, 'planks');
        setBlock(x + 6, y + dy, z + dz, 'planks');
      }
    }

    // Paredes de tr√°s e frente parciais
    for (let dx = -5; dx <= 5; dx++) {
      setBlock(x + dx, y, z - 4, 'planks');
      setBlock(x + dx, y + 1, z - 4, 'planks');

      if (Math.abs(dx) > 2) {
        setBlock(x + dx, y, z + 4, 'planks');
        setBlock(x + dx, y + 1, z + 4, 'planks');
      }
    }

    // Pilares
    for (let dy = 0; dy < 4; dy++) {
      setBlock(x - 5, y + dy, z - 3, 'planks');
      setBlock(x - 5, y + dy, z + 3, 'planks');
      setBlock(x + 5, y + dy, z - 3, 'planks');
      setBlock(x + 5, y + dy, z + 3, 'planks');
    }

    // Telhado
    for (let dy = 0; dy < 3; dy++) {
      const width = 6 - dy;
      for (let dx = -width; dx <= width; dx++) {
        for (let dz = -4; dz <= 4; dz++) {
          setBlock(x + dx, y + 4 + dy, z + dz, 'planks');
        }
      }
    }

    // Baias (compartimentos)
    for (let i = -4; i <= 4; i += 4) {
      for (let dx = -1; dx <= 1; dx++) {
        setBlock(x + dx, y, z + i, 'planks');
      }
      // Comedouros
      setBlock(x - 5, y + 1, z + i, 'planks');
      setBlock(x + 5, y + 1, z + i, 'planks');
    }

    // Porta dupla
    removeBlockData(x - 1, y, z + 4);
    removeBlockData(x - 1, y + 1, z + 4);
    removeBlockData(x + 1, y, z + 4);
    removeBlockData(x + 1, y + 1, z + 4);

    // Lanternas
    setBlock(x - 5, y + 3, z, 'lantern');
    setBlock(x + 5, y + 3, z, 'lantern');
  }

  function addVillageDecoration(centerX, villageY, centerZ) {
    // √Årvores decorativas ao redor
    const treePositions = [
      { x: 20, z: 20 }, { x: -20, z: 20 },
      { x: 20, z: -20 }, { x: -20, z: -20 },
      { x: 25, z: 0 }, { x: -25, z: 0 },
      { x: 0, z: 25 }, { x: 0, z: -25 }
    ];

    treePositions.forEach(pos => {
      const tx = centerX + pos.x;
      const tz = centerZ + pos.z;

      // Tronco
      for (let dy = 0; dy < 5; dy++) {
        setBlock(tx, villageY + 1 + dy, tz, 'wood');
      }

      // Copa
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          for (let dy = 0; dy <= 2; dy++) {
            if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 3) {
              setBlock(tx + dx, villageY + 5 + dy, tz + dz, 'leaves');
            }
          }
        }
      }
    });

    // Bancos ao redor da fonte
    for (let angle = 0; angle < 360; angle += 90) {
      const rad = angle * Math.PI / 180;
      const bx = Math.floor(centerX + Math.cos(rad) * 6);
      const bz = Math.floor(centerZ + Math.sin(rad) * 6);

      setBlock(bx, villageY, bz, 'planks');
      setBlock(bx - 1, villageY, bz, 'planks');
      setBlock(bx + 1, villageY, bz, 'planks');
    }
  }

  function startGame() {
    document.getElementById('main-menu').style.display = 'none';

    const chunk = worldToChunk(0, 0);
    player.lastChunk = chunk;

    const chunksToLoad = [];
    for (let cx = chunk.x - RENDER_DISTANCE; cx <= chunk.x + RENDER_DISTANCE; cx++) {
      for (let cz = chunk.z - RENDER_DISTANCE; cz <= chunk.z + RENDER_DISTANCE; cz++) {
        chunksToLoad.push([cx, cz]);
      }
    }

    chunksToLoad.forEach(([cx, cz]) => {
      generateChunk(cx, cz);
      spawnAnimals(cx, cz);
    });

    chunksToLoad.forEach(([cx, cz]) => {
      buildChunkMesh(cx, cz);
    });

    // Criar personagem
    playerCharacter = new PlayerCharacter();
    playerCharacter.setPosition(0, 25, 0);
    scene.add(playerCharacter.group);

    // Spawnar inimigos
    chunksToLoad.forEach(([cx, cz]) => {
      spawnEnemies(cx, cz);
    });

    // Gerar vila
    generateVillage(30, 30);

    controls.locked = true;
    renderer.domElement.requestPointerLock();

    animate();
  }

  function animate() {
    requestAnimationFrame(animate);

    const deltaTime = 0.016; // Aproximadamente 60 FPS

    if (controls.locked && !document.getElementById('inventory-full').classList.contains('open')) {
      updatePlayer();
      updateBreaking();

      // Atualizar anima√ß√£o do personagem
      if (playerCharacter) {
        const isMoving = keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'];
        const isJumping = !player.canJump;
        playerCharacter.updateAnimation(deltaTime, isMoving, isJumping);

        // Sincronizar posi√ß√£o do personagem com a c√¢mera
        playerCharacter.setPosition(
                camera.position.x,
                camera.position.y - 1.6,
                camera.position.z
        );
        playerCharacter.setRotation(camera.rotation.y);
      }
    }

    // Atualizar sistemas
    if (waterSystem) waterSystem.updateWaves(performance.now() * 0.001);
    if (particleSystem) particleSystem.update();
    updateDayNightCycle(deltaTime);

    updateBreakAnimations();
    updateAnimals();
    updateEnemies();
    updateVillagers();

    renderer.render(scene, camera);

    frames++;
    const now = performance.now();

    if (now - lastFaceUpdate > 2000) {
      updateFaceCount();
      lastFaceUpdate = now;
    }

    if (now >= lastTime + 1000) {
      const fps = Math.round(frames * 1000 / (now - lastTime));
      document.getElementById('fps').textContent = fps;
      document.getElementById('fps').className = fps >= 50 ? 'performance-good' : fps >= 30 ? 'performance-ok' : 'performance-bad';

      document.getElementById('pos').textContent =
              `${Math.floor(camera.position.x)}, ${Math.floor(camera.position.y)}, ${Math.floor(camera.position.z)}`;
      document.getElementById('chunks').textContent = Object.keys(chunks).length;
      document.getElementById('total').textContent = Object.keys(worldData).length;
      document.getElementById('animals-count').textContent = `${animals.length} | I:${enemies.length} | A:${villagers.length}`;

      frames = 0;
      lastTime = now;
    }
  }

  // ============================================
  // ATUALIZAR BLOCKTYPES PARA INCLUIR √ÅGUA
  // ============================================

  // Adicionar √°gua aos blockTypes existentes
  blockTypes.water = { color: 0x1E90FF, name: '√Ågua', hardness: 0.5 };

  // ============================================
  // OTIMIZA√á√ÉO DE MEM√ìRIA
  // ============================================

  function cleanupUnusedResources() {
    // Limpar geometrias n√£o utilizadas
    for (let key in chunkMeshes) {
      const chunk = chunkMeshes[key];
      if (!scene.children.includes(chunk)) {
        chunk.children.forEach(child => {
          child.geometry.dispose();
          child.material.dispose();
        });
        delete chunkMeshes[key];
      }
    }

    // Limpar part√≠culas antigas
    if (particles.length > 1000) {
      particles.splice(0, particles.length - 1000).forEach(p => {
        scene.remove(p);
        p.geometry.dispose();
        p.material.dispose();
      });
    }

    // Limpar anima√ß√µes de quebra antigas
    if (breakingAnimations.length > 50) {
      breakingAnimations.splice(0, breakingAnimations.length - 50).forEach(anim => {
        anim.particles.forEach(p => {
          scene.remove(p);
          p.geometry.dispose();
          p.material.dispose();
        });
      });
    }
  }

  // Chamar cleanup periodicamente
  setInterval(cleanupUnusedResources, 30000);




  // Sistema de Controles Mobile
  const mobileControls = {
    enabled: false,
    joystick: { active: false, x: 0, y: 0 },
    look: { active: false, startX: 0, startY: 0 },
    buttons: {
      jump: false,
      fly: false,
      sprint: false,
      break: false,
      place: false
    }
  };

  function initMobileControls() {
    // Detectar dispositivo mobile
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
            || (window.matchMedia && window.matchMedia("(max-width: 768px)").matches);

    if (!isMobile) {
      document.querySelector('.mobile-controls').style.display = 'none';
      return;
    }

    mobileControls.enabled = true;

    // Joystick Virtual
    setupJoystick();

    // Look Around (toque na direita)
    setupLookControls();

    // Bot√µes de A√ß√£o
    setupActionButtons();

    // Auto-lock ao iniciar
    controls.locked = true;
  }

  function setupJoystick() {
    const joystick = document.getElementById('mobile-joystick');
    const stick = document.getElementById('joystick-stick');
    const rect = joystick.getBoundingClientRect();
    const centerX = rect.width / 2;
    const centerY = rect.height / 2;
    const maxDistance = 35;

    joystick.addEventListener('touchstart', (e) => {
      e.preventDefault();
      mobileControls.joystick.active = true;
    });

    joystick.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!mobileControls.joystick.active) return;

      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();

      let dx = touch.clientX - rect.left - centerX;
      let dy = touch.clientY - rect.top - centerY;

      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance > maxDistance) {
        const angle = Math.atan2(dy, dx);
        dx = Math.cos(angle) * maxDistance;
        dy = Math.sin(angle) * maxDistance;
      }

      stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

      // Normalizar valores (-1 a 1)
      mobileControls.joystick.x = dx / maxDistance;
      mobileControls.joystick.y = dy / maxDistance;

      // Simular teclas WASD
      keys['KeyW'] = mobileControls.joystick.y < -0.3;
      keys['KeyS'] = mobileControls.joystick.y > 0.3;
      keys['KeyA'] = mobileControls.joystick.x < -0.3;
      keys['KeyD'] = mobileControls.joystick.x > 0.3;
    });

    joystick.addEventListener('touchend', (e) => {
      e.preventDefault();
      mobileControls.joystick.active = false;
      mobileControls.joystick.x = 0;
      mobileControls.joystick.y = 0;

      stick.style.transform = 'translate(-50%, -50%)';

      keys['KeyW'] = false;
      keys['KeyS'] = false;
      keys['KeyA'] = false;
      keys['KeyD'] = false;
    });
  }

  function setupLookControls() {
    const lookArea = document.getElementById('mobile-look');
    let lastTouchX = 0;
    let lastTouchY = 0;

    lookArea.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      lastTouchX = touch.clientX;
      lastTouchY = touch.clientY;
      mobileControls.look.active = true;

      // Indicador visual
      showTouchIndicator(touch.clientX, touch.clientY);
    });

    lookArea.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!mobileControls.look.active) return;

      const touch = e.touches[0];
      const deltaX = touch.clientX - lastTouchX;
      const deltaY = touch.clientY - lastTouchY;

      // Sensibilidade ajustada para mobile
      const sensitivity = 0.003;
      mouse.x -= deltaX * sensitivity;
      mouse.y -= deltaY * sensitivity;
      mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));

      lastTouchX = touch.clientX;
      lastTouchY = touch.clientY;
    });

    lookArea.addEventListener('touchend', (e) => {
      e.preventDefault();
      mobileControls.look.active = false;
    });
  }

  function setupActionButtons() {
    // Pular
    const jumpBtn = document.getElementById('mobile-jump');
    jumpBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys['Space'] = true;
      jumpBtn.classList.add('active');
    });
    jumpBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      keys['Space'] = false;
      jumpBtn.classList.remove('active');
    });

    // Quebrar bloco
    const breakBtn = document.getElementById('mobile-break');
    breakBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      handleMouseDown({ button: 0 });
      breakBtn.classList.add('active');
    });
    breakBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      handleMouseUp({ button: 0 });
      breakBtn.classList.remove('active');
    });

    // Colocar bloco
    const placeBtn = document.getElementById('mobile-place');
    placeBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      handleMouseDown({ button: 2 });
      placeBtn.classList.add('active');
    });
    placeBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      handleMouseUp({ button: 2 });
      placeBtn.classList.remove('active');
    });

    // Modo voo
    const flyBtn = document.getElementById('mobile-fly');
    flyBtn.addEventListener('click', (e) => {
      e.preventDefault();
      player.flying = !player.flying;
      document.getElementById('mode').textContent = player.flying ? 'Voo' : 'Normal';
      flyBtn.classList.toggle('active', player.flying);
    });

    // Invent√°rio
    const invBtn = document.getElementById('mobile-inventory');
    invBtn.addEventListener('click', (e) => {
      e.preventDefault();
      toggleFullInventory();
    });

    // Sprint
    const sprintBtn = document.getElementById('mobile-sprint');
    sprintBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys['ShiftLeft'] = true;
      sprintBtn.classList.add('active');
    });
    sprintBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      keys['ShiftLeft'] = false;
      sprintBtn.classList.remove('active');
    });


    const prevSlotBtn = document.getElementById('mobile-prev-slot');
    if (prevSlotBtn) {
      prevSlotBtn.addEventListener('click', (e) => {
        e.preventDefault();
        const newSlot = (player.selectedSlot - 1 + player.hotbarSlots) % player.hotbarSlots;
        selectSlot(newSlot);
      });
    }

// Pr√≥ximo slot
    const nextSlotBtn = document.getElementById('mobile-next-slot');
    if (nextSlotBtn) {
      nextSlotBtn.addEventListener('click', (e) => {
        e.preventDefault();
        const newSlot = (player.selectedSlot + 1) % player.hotbarSlots;
        selectSlot(newSlot);
      });
    }


  }

  function showTouchIndicator(x, y) {
    const indicator = document.createElement('div');
    indicator.className = 'touch-indicator';
    indicator.style.left = x + 'px';
    indicator.style.top = y + 'px';
    document.body.appendChild(indicator);

    setTimeout(() => {
      indicator.remove();
    }, 300);
  }

  // Prevenir zoom indesejado em mobile
  document.addEventListener('touchmove', (e) => {
    if (e.scale !== 1) {
      e.preventDefault();
    }
  }, { passive: false });

  // Prevenir duplo toque para zoom
  let lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
      e.preventDefault();
    }
    lastTouchEnd = now;
  }, false);






  init();
</script>
</body>
</html>
