<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft Ultra Otimizado - Sistema Completo</title>
  <link rel="stylesheet" href="style.css">

</head>
<body>
<div id="main-menu">
  <div class="menu-container">
    <h1 class="menu-title">‚õèÔ∏è MINECRAFT ULTRA OTIMIZADO ‚õèÔ∏è</h1>

    <p class="menu-subtitle">
      Uma experi√™ncia completa de Minecraft com gr√°ficos otimizados, sistema de vida,
      animais e invent√°rio expandido. Tudo rodando diretamente no seu navegador!
    </p>

    <div class="controls-grid">
      <div class="control-item">
        <strong>W/A/S/D</strong>
        <span>Movimenta√ß√£o</span>
      </div>
      <div class="control-item">
        <strong>ESPA√áO</strong>
        <span>Pular</span>
      </div>
      <div class="control-item">
        <strong>SHIFT</strong>
        <span>Correr / Descer (Voo)</span>
      </div>
      <div class="control-item">
        <strong>MOUSE</strong>
        <span>Olhar ao redor</span>
      </div>
      <div class="control-item">
        <strong>CLIQUE ESQUERDO</strong>
        <span>Quebrar bloco</span>
      </div>
      <div class="control-item">
        <strong>CLIQUE DIREITO</strong>
        <span>Colocar bloco</span>
      </div>
      <div class="control-item">
        <strong>SCROLL / 1-9</strong>
        <span>Trocar bloco</span>
      </div>
      <div class="control-item">
        <strong>F</strong>
        <span>Alternar Modo Voo</span>
      </div>
      <div class="control-item">
        <strong>E</strong>
        <span>Abrir Invent√°rio</span>
      </div>
      <div class="control-item">
        <strong>Q</strong>
        <span>Jogar Item</span>
      </div>
    </div>

    <div class="features-grid">
      <div class="feature">
        <span class="feature-icon">‚ö°</span>
        <span class="feature-text">Alto Desempenho</span>
      </div>
      <div class="feature">
        <span class="feature-icon">‚ù§Ô∏è</span>
        <span class="feature-text">Sistema de Vida</span>
      </div>
      <div class="feature">
        <span class="feature-icon">üêÆ</span>
        <span class="feature-text">Animais Interativos</span>
      </div>
      <div class="feature">
        <span class="feature-icon">üéí</span>
        <span class="feature-text">36 Slots</span>
      </div>
      <div class="feature">
        <span class="feature-icon">üåç</span>
        <span class="feature-text">Mundo Gerado</span>
      </div>
    </div>

    <button class="start-button" onclick="startGame()">
      üéÆ INICIAR JOGO
    </button>

    <p class="menu-footer">
      Desenvolvido com Three.js ‚Ä¢ Otimizado para navegadores modernos
    </p>
  </div>
</div>

<div id="info">
  <div class="info-item"><strong>Posi√ß√£o:</strong> <span id="pos" class="highlight">0, 0, 0</span></div>
  <div class="info-item"><strong>FPS:</strong> <span id="fps" class="performance-good">60</span></div>
  <div class="info-item"><strong>Chunks:</strong> <span id="chunks" class="highlight">0</span></div>
  <div class="info-item"><strong>Faces:</strong> <span id="visible" class="highlight">0</span></div>
  <div class="info-item"><strong>Blocos:</strong> <span id="total" class="highlight">0</span></div>
  <div class="info-item"><strong>Animais:</strong> <span id="animals-count" class="highlight">0</span></div>
  <div class="info-item"><strong>Modo:</strong> <span id="mode" class="highlight">Normal</span></div>
  <div class="info-item"><strong>Bloco:</strong> <span id="selected-block" class="highlight">Grama</span></div>
</div>

<div id="health-container"></div>
<div id="crosshair"></div>
<div class="break-progress" id="break-progress">
  <div class="break-progress-fill"></div>
</div>
<div id="inventory-bar"></div>
<div id="inventory-full"></div>

<!-- Controles Mobile -->
<div class="mobile-controls">
  <!-- Joystick Virtual -->
  <div id="mobile-joystick">
    <div id="joystick-stick"></div>
  </div>

  <!-- √Årea de Look Around -->
  <div id="mobile-look"></div>

  <!-- Bot√µes de A√ß√£o -->
  <div class="mobile-buttons">
    <button class="mobile-btn" id="mobile-jump">‚Üë</button>
    <button class="mobile-btn" id="mobile-break">‚öí</button>
    <button class="mobile-btn" id="mobile-place">+</button>
  </div>

  <!-- Bot√µes Superiores -->
  <div class="mobile-top-buttons">
    <button class="mobile-top-btn" id="mobile-fly">‚úà</button>
    <button class="mobile-top-btn" id="mobile-inventory">üéí</button>
    <button class="mobile-top-btn" id="mobile-sprint">‚ö°</button>
  </div>
</div>

<button class="mobile-top-btn" id="mobile-prev-slot">‚óÄ</button>
<button class="mobile-top-btn" id="mobile-next-slot">‚ñ∂</button>

<div id="settings-menu">
  <div class="settings-container">
    <div class="settings-header">
      <h2>‚öôÔ∏è CONFIGURA√á√ïES</h2>
      <button class="close-settings" onclick="closeSettings()">√ó</button>
    </div>

    <!-- Tabs -->
    <div class="settings-tabs">
      <button class="settings-tab active" onclick="switchTab('graphics')">üé® Gr√°ficos</button>
      <button class="settings-tab" onclick="switchTab('gameplay')">üéÆ Gameplay</button>
      <button class="settings-tab" onclick="switchTab('controls')">‚å®Ô∏è Controles</button>
      <button class="settings-tab" onclick="switchTab('audio')">üîä √Åudio</button>
      <button class="settings-tab" onclick="switchTab('info')">‚ÑπÔ∏è Info</button>
    </div>

    <!-- Conte√∫do: Gr√°ficos -->
    <div id="tab-graphics" class="settings-content active">
      <div class="settings-group">
        <h3>Qualidade Visual</h3>

        <div class="setting-item">
          <div class="setting-label">
            <span>Dist√¢ncia de Renderiza√ß√£o</span>
            <span class="setting-description">Quantos chunks s√£o carregados ao redor do jogador</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="render-distance" min="1" max="12" value="1"
                     oninput="updateSetting('renderDistance', this.value)">
              <span class="slider-value" id="render-distance-value">1</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Antialiasing</span>
            <span class="setting-description">Suaviza bordas dos objetos</span>
          </div>
          <div class="setting-control">
            <div class="switch" id="antialiasing-switch" onclick="toggleSwitch('antialiasing')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Sombras</span>
            <span class="setting-description">Renderizar sombras din√¢micas</span>
          </div>
          <div class="setting-control">
            <div class="switch active" id="shadows-switch" onclick="toggleSwitch('shadows')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>N√©voa</span>
            <span class="setting-description">Efeito de n√©voa atmosf√©rica</span>
          </div>
          <div class="setting-control">
            <div class="switch active" id="fog-switch" onclick="toggleSwitch('fog')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Part√≠culas</span>
            <span class="setting-description">Intensidade de efeitos de part√≠culas</span>
          </div>
          <div class="setting-control">
            <select class="custom-select" id="particles-select" onchange="updateSetting('particles', this.value)">
              <option value="all">Todas</option>
              <option value="minimal">M√≠nimas</option>
              <option value="none">Desativadas</option>
            </select>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>FPS Alvo</span>
            <span class="setting-description">Limite de quadros por segundo</span>
          </div>
          <div class="setting-control">
            <select class="custom-select" id="fps-select" onchange="updateSetting('fpsLimit', this.value)">
              <option value="unlimited">Ilimitado</option>
              <option value="144">144 FPS</option>
              <option value="120">120 FPS</option>
              <option value="60">60 FPS</option>
              <option value="30">30 FPS</option>
            </select>
          </div>
        </div>
      </div>

      <div class="info-box">
        üí° Dica: Reduzir a dist√¢ncia de renderiza√ß√£o e desativar sombras pode melhorar significativamente a performance.
      </div>
    </div>

    <!-- Conte√∫do: Gameplay -->
    <div id="tab-gameplay" class="settings-content">
      <div class="settings-group">
        <h3>Mec√¢nicas de Jogo</h3>

        <div class="setting-item">
          <div class="setting-label">
            <span>Dificuldade</span>
            <span class="setting-description">Altera dano de inimigos e spawn</span>
          </div>
          <div class="setting-control">
            <select class="custom-select" id="difficulty-select" onchange="updateSetting('difficulty', this.value)">
              <option value="peaceful">Pac√≠fico</option>
              <option value="easy">F√°cil</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Dif√≠cil</option>
            </select>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Modo Criativo</span>
            <span class="setting-description">Recursos ilimitados e invencibilidade</span>
          </div>
          <div class="setting-control">
            <div class="switch" id="creative-switch" onclick="toggleSwitch('creative')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Auto-Jump</span>
            <span class="setting-description">Pular automaticamente ao encontrar obst√°culos</span>
          </div>
          <div class="setting-control">
            <div class="switch" id="autojump-switch" onclick="toggleSwitch('autoJump')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Spawn de Inimigos</span>
            <span class="setting-description">Frequ√™ncia de apari√ß√£o de mobs hostis</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="mob-spawn" min="0" max="100" value="50"
                     oninput="updateSetting('mobSpawn', this.value)">
              <span class="slider-value" id="mob-spawn-value">50%</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Regenera√ß√£o de Vida</span>
            <span class="setting-description">Velocidade de recupera√ß√£o de HP</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="health-regen" min="0" max="10" value="5"
                     oninput="updateSetting('healthRegen', this.value)">
              <span class="slider-value" id="health-regen-value">5</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Conte√∫do: Controles -->
    <div id="tab-controls" class="settings-content">
      <div class="settings-group">
        <h3>Sensibilidade</h3>

        <div class="setting-item">
          <div class="setting-label">
            <span>Sensibilidade do Mouse</span>
            <span class="setting-description">Velocidade de rota√ß√£o da c√¢mera</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="mouse-sensitivity" min="1" max="20" value="10"
                     oninput="updateSetting('mouseSensitivity', this.value)">
              <span class="slider-value" id="mouse-sensitivity-value">10</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Inverter Eixo Y</span>
            <span class="setting-description">Inverter dire√ß√£o vertical do mouse</span>
          </div>
          <div class="setting-control">
            <div class="switch" id="invert-y-switch" onclick="toggleSwitch('invertY')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Sensibilidade Touch (Mobile)</span>
            <span class="setting-description">Velocidade de rota√ß√£o no mobile</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="touch-sensitivity" min="1" max="20" value="10"
                     oninput="updateSetting('touchSensitivity', this.value)">
              <span class="slider-value" id="touch-sensitivity-value">10</span>
            </div>
          </div>
        </div>
      </div>

      <div class="settings-group">
        <h3>Atalhos de Teclado</h3>
        <div class="info-box">
          <strong>Controles Atuais:</strong><br>
          ‚Ä¢ WASD - Movimento<br>
          ‚Ä¢ Espa√ßo - Pular<br>
          ‚Ä¢ Shift - Correr/Descer<br>
          ‚Ä¢ F - Modo Voo<br>
          ‚Ä¢ E - Invent√°rio<br>
          ‚Ä¢ Q - Jogar Item<br>
          ‚Ä¢ 1-9 - Selecionar Slot<br>
          ‚Ä¢ Mouse - Olhar / Interagir
        </div>
        <button class="action-button">üîÑ Restaurar Padr√£o</button>
      </div>
    </div>

    <!-- Conte√∫do: √Åudio -->
    <div id="tab-audio" class="settings-content">
      <div class="settings-group">
        <h3>Volume</h3>

        <div class="setting-item">
          <div class="setting-label">
            <span>Volume Mestre</span>
            <span class="setting-description">Volume geral do jogo</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="master-volume" min="0" max="100" value="70"
                     oninput="updateSetting('masterVolume', this.value)">
              <span class="slider-value" id="master-volume-value">70%</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Efeitos Sonoros</span>
            <span class="setting-description">Volume de sons de a√ß√£o</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="sfx-volume" min="0" max="100" value="80"
                     oninput="updateSetting('sfxVolume', this.value)">
              <span class="slider-value" id="sfx-volume-value">80%</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>M√∫sica de Fundo</span>
            <span class="setting-description">Volume da m√∫sica ambiente</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="music-volume" min="0" max="100" value="50"
                     oninput="updateSetting('musicVolume', this.value)">
              <span class="slider-value" id="music-volume-value">50%</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Sons Ambiente</span>
            <span class="setting-description">Sons de natureza e clima</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="ambient-volume" min="0" max="100" value="60"
                     oninput="updateSetting('ambientVolume', this.value)">
              <span class="slider-value" id="ambient-volume-value">60%</span>
            </div>
          </div>
        </div>
      </div>

      <div class="warning-box">
        ‚ö†Ô∏è Nota: Sistema de √°udio ser√° implementado em vers√£o futura.
      </div>
    </div>

    <!-- Conte√∫do: Info -->
    <div id="tab-info" class="settings-content">
      <div class="settings-group">
        <h3>Informa√ß√µes do Sistema</h3>

        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value" id="stat-fps">60</div>
            <div class="stat-label">FPS Atual</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-chunks">0</div>
            <div class="stat-label">Chunks Carregados</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-entities">0</div>
            <div class="stat-label">Entidades</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-memory">--</div>
            <div class="stat-label">Mem√≥ria Usada</div>
          </div>
        </div>
      </div>

      <div class="settings-group">
        <h3>Sobre o Jogo</h3>
        <div class="info-box">
          <strong>Minecraft Ultra Otimizado</strong><br>
          Vers√£o: 1.0.0<br>
          Motor: Three.js r128<br>
          <br>
          Desenvolvido com foco em performance e jogabilidade.<br>
          <br>
          ¬© 2026 - Todos os direitos reservados
        </div>
      </div>

      <div class="settings-group">
        <h3>Dados do Jogo</h3>
        <button class="action-button" onclick="exportGameData()">üì• Exportar Mundo</button>
        <button class="action-button" onclick="importGameData()">üì§ Importar Mundo</button>
        <button class="action-button danger" onclick="resetGameData()">üóëÔ∏è Limpar Todos os Dados</button>
      </div>
    </div>

    <!-- Bot√µes de Controle -->
    <div class="control-buttons">
      <button class="action-button" onclick="saveSettings()">üíæ Salvar</button>
      <button class="action-button" onclick="resetSettings()">üîÑ Restaurar Padr√£o</button>
      <button class="action-button" onclick="closeSettings()">‚úñÔ∏è Fechar</button>
    </div>
  </div>
</div>

<div id="multiplayer-status" class="hidden">
  <div class="mp-status-line">
    <span>Status:</span>
    <span id="mp-status" class="mp-disconnected">Desconectado</span>
  </div>
  <div class="mp-status-line">
    <span>Jogadores:</span>
    <span id="mp-players-count">0</span>
  </div>
</div>

<div id="multiplayer-chat">
  <div id="chat-messages"></div>
  <div id="chat-input-container">
    <input type="text" id="chat-input" placeholder="Digite sua mensagem... (Enter para enviar)" maxlength="200">
    <button id="chat-send" onclick="sendChatMessage(document.getElementById('chat-input').value)">Enviar</button>
  </div>
</div>

<!-- Menu Multiplayer -->
<div id="multiplayer-menu">
  <h2 class="mp-menu-title">üåê MULTIPLAYER</h2>

  <div class="mp-menu-section">
    <h3>Conex√£o</h3>

    <div class="mp-input-group">
      <label>Servidor:</label>
      <input type="text" id="mp-server-url" value="ws://localhost:8765" placeholder="ws://localhost:8765">
    </div>

    <div class="mp-input-group">
      <label>Seu Nome:</label>
      <input type="text" id="mp-player-name" placeholder="Seu Nome" maxlength="20">
    </div>

    <div class="mp-info-box">
      <span class="mp-status-indicator" id="mp-indicator"></span>
      <span id="mp-connection-status">N√£o conectado</span>
    </div>
  </div>

  <div class="mp-menu-section">
    <h3>Controles</h3>
    <div style="color: white; font-size: 13px; line-height: 1.6;">
      ‚Ä¢ <strong>T</strong> - Abrir chat<br>
      ‚Ä¢ <strong>Enter</strong> - Enviar mensagem<br>
      ‚Ä¢ <strong>ESC</strong> - Fechar chat<br>
    </div>
  </div>

  <button class="mp-button" id="mp-connect-btn" onclick="toggleMultiplayerConnection()">
    Conectar
  </button>

  <button class="mp-button danger" onclick="closeMultiplayerMenu()">
    Fechar
  </button>
</div>




<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
<script src="Animals.js"></script>
<script src="PlayerCharacter.js"></script>
<script src="Enemy.js"></script>
<script src="Village.js"></script>
<script src="Villager.js"></script>

<script src="Multiplayer.js"></script>
<script src="Controls.js"></script>
<script src="Menu.js"></script>
<script src="Texture.js"></script>
<script src="Light.js"></script>
<script>
  let scene, camera, renderer, raycaster;
  let worldData = {};
  let chunks = {};
  let chunkMeshes = {};
  let materials = {};
  let breakingAnimations = [];
  let animals = [];
  let animalMeshes = [];
  let MAX_ANIMALS = 20; // Reduzido de ~50 para 25 (50% menos)

  const CHUNK_SIZE = 24;
  const RENDER_DISTANCE = 6;
  const MAX_HEALTH = 20;
  let playerHealth = MAX_HEALTH;

  const player = {
    velocity: new THREE.Vector3(),
    canJump: false,
    selectedSlot: 0,
    flying: false,
    breaking: null,
    breakProgress: 0,
    lastChunk: { x: 0, z: 0 },
    inventorySlots: 36,
    hotbarSlots: 9
  };

  // Sistema de invent√°rio
  player.inventory = Array(player.inventorySlots).fill().map(() => ({
    type: null,
    count: 0
  }));

  let keys = {};
  let mouse = { x: 0, y: 0 };
  let controls = { locked: false };

  const GRAVITY = -0.018;
  const JUMP_SPEED = 0.28;
  const MOVE_SPEED = 0.15;
  const SPRINT_SPEED = 0.28;
  const FLY_SPEED = 0.4;
  const REACH = 7;
  const BREAK_TIME = 500;
  let lastTime = performance.now();
  let frames = 0;
  let lastFaceUpdate = 0;

  const blockTypes = {
    grass: {
      topColor: 0x7CFC00,
      sideColor: 0x8B4513,
      bottomColor: 0x7A3C0F,
      name: 'Grama',
      hardness: 1,
      hasMultiTexture: true
    },
    dirt: {
      color: 0x8B4513,
      name: 'Terra',
      hardness: 1,
      hasMultiTexture: true
    },
    stone: {
      color: 0x808080,
      name: 'Pedra',
      hardness: 3,
      hasMultiTexture: true
    },
    wood: {
      color: 0x654321,
      name: 'Madeira',
      hardness: 2,
      hasMultiTexture: true,
      topColor: 0x8B5A2B,
      sideColor: 0x654321
    },
    leaves: {
      color: 0x228B22,
      name: 'Folhas',
      hardness: 0.5,
      hasMultiTexture: false
    },
    sand: {
      color: 0xF4A460,
      name: 'Areia',
      hardness: 1,
      hasMultiTexture: true
    },
    cobblestone: {
      color: 0x6B6B6B,
      name: 'Pedregulho',
      hardness: 3,
      hasMultiTexture: true
    },
    coal_ore: {
      color: 0x343434,
      name: 'Carv√£o',
      hardness: 4,
      hasMultiTexture: true
    },
    iron_ore: {
      color: 0xD8AF93,
      name: 'Ferro',
      hardness: 5,
      hasMultiTexture: true
    },
    gold_ore: {
      color: 0xFFD700,
      name: 'Ouro',
      hardness: 5,
      hasMultiTexture: true
    },
    diamond_ore: {
      color: 0x00CED1,
      name: 'Diamante',
      hardness: 6,
      hasMultiTexture: true
    },
    bedrock: {
      color: 0x2F2F2F,
      name: 'Bedrock',
      hardness: 999,
      hasMultiTexture: true
    },
    planks: {
      color: 0xC19A6B,
      name: 'T√°buas',
      hardness: 2,
      hasMultiTexture: true
    },
    brick: {
      color: 0xB22222,
      name: 'Tijolo',
      hardness: 3,
      hasMultiTexture: true
    },
    glass: {
      color: 0xADD8E6,
      name: 'Vidro',
      hardness: 0.3,
      hasMultiTexture: false
    },
    obsidian: {
      color: 0x1C1C2E,
      name: 'Obsidiana',
      hardness: 8,
      hasMultiTexture: true
    },
    ice: {
      color: 0xB0E0E6,
      name: 'Gelo',
      hardness: 0.5,
      hasMultiTexture: false
    },
    snow: {
      color: 0xFFFAFA,
      name: 'Neve',
      hardness: 0.2,
      hasMultiTexture: true
    },
    gravel: {
      color: 0x8B8680,
      name: 'Cascalho',
      hardness: 1,
      hasMultiTexture: true
    },
    clay: {
      color: 0xA0A0A0,
      name: 'Argila',
      hardness: 1,
      hasMultiTexture: true
    },
    emerald_ore: {
      color: 0x50C878,
      name: 'Esmeralda',
      hardness: 6,
      hasMultiTexture: true
    },
    redstone_ore: {
      color: 0xFF0000,
      name: 'Redstone',
      hardness: 5,
      hasMultiTexture: true
    },
    glowstone: {
      color: 0xFFFF99,
      name: 'Pedra Luminosa',
      hardness: 0.5,
      emissive: true,
      hasMultiTexture: true
    },
    lantern: {
      color: 0xFFD700,
      name: 'Lanterna',
      hardness: 0.5,
      emissive: true,
      hasMultiTexture: true
    },
    torch: {
      color: 0xFF8C00,
      name: 'Tocha',
      hardness: 0.1,
      emissive: true,
      hasMultiTexture: true
    },
    quartz: {
      color: 0xF5F5F5,
      name: 'Quartzo',
      hardness: 2,
      hasMultiTexture: true
    },
    prismarine: {
      color: 0x4ECDC4,
      name: 'Prismarinho',
      hardness: 3,
      hasMultiTexture: true
    },
    purpur: {
      color: 0xA569BD,
      name: 'Purpur',
      hardness: 3,
      hasMultiTexture: true
    },
    endstone: {
      color: 0xE4E096,
      name: 'Pedra do End',
      hardness: 4,
      hasMultiTexture: true
    },
    concrete_white: {
      color: 0xFFFFFF,
      name: 'Concreto Branco',
      hardness: 2,
      hasMultiTexture: true
    },
    concrete_red: {
      color: 0xDC143C,
      name: 'Concreto Vermelho',
      hardness: 2,
      hasMultiTexture: true
    },
    concrete_blue: {
      color: 0x1E90FF,
      name: 'Concreto Azul',
      hardness: 2,
      hasMultiTexture: true
    },
    concrete_green: {
      color: 0x32CD32,
      name: 'Concreto Verde',
      hardness: 2,
      hasMultiTexture: true
    },
    concrete_yellow: {
      color: 0xFFD700,
      name: 'Concreto Amarelo',
      hardness: 2,
      hasMultiTexture: true
    },
    concrete_black: {
      color: 0x2F4F4F,
      name: 'Concreto Preto',
      hardness: 2,
      hasMultiTexture: true
    },
    crafting_table: {
      color: 0x8B4513,
      name: 'Mesa de Trabalho',
      hardness: 2.5,
      hasMultiTexture: true
    },
    furnace: {
      color: 0x696969,
      name: 'Fornalha',
      hardness: 4,
      hasMultiTexture: true
    },
    chest: {
      color: 0xA0522D,
      name: 'Ba√∫',
      hardness: 2.5,
      hasMultiTexture: true
    },
    bookshelf: {
      color: 0x654321,
      name: 'Estante',
      hardness: 1.5,
      hasMultiTexture: true
    },
    mushroom_red: {
      color: 0xFF0000,
      name: 'Cogumelo Vermelho',
      hardness: 0.2,
      hasMultiTexture: true
    },
    mushroom_brown: {
      color: 0x8B4513,
      name: 'Cogumelo Marrom',
      hardness: 0.2,
      hasMultiTexture: true
    },
    pumpkin: {
      color: 0xFF8C00,
      name: 'Ab√≥bora',
      hardness: 1,
      hasMultiTexture: true
    },
    melon: {
      color: 0x90EE90,
      name: 'Melancia',
      hardness: 1,
      hasMultiTexture: true
    },
    lapis_ore: {
      color: 0x0000FF,
      name: 'L√°pis-laz√∫li',
      hardness: 4,
      hasMultiTexture: true
    },
    netherite: {
      color: 0x8B008B,
      name: 'Netherite',
      hardness: 10,
      hasMultiTexture: true
    },
    water: {
      color: 0x1E90FF,
      name: '√Ågua',
      hardness: 0.5,
      hasMultiTexture: false
    }
  };


  const animalTypes = {
    cow: {
      health: 10,
      drops: ['rawBeef', 'leather'],
      dropCount: { min: 1, max: 3 },
      size: { width: 1.2, height: 1.4, depth: 1.8 },
      color: 0x8B4513,
      speed: 0.02
    },
    pig: {
      health: 10,
      drops: ['rawPorkchop'],
      dropCount: { min: 1, max: 3 },
      size: { width: 1.0, height: 0.9, depth: 1.2 },
      color: 0xFFB6C1,
      speed: 0.025
    },
    sheep: {
      health: 8,
      drops: ['wool', 'rawMutton'],
      dropCount: { min: 1, max: 2 },
      size: { width: 1.2, height: 1.3, depth: 1.6 },
      color: 0xFFFFFF,
      speed: 0.02
    },
    chicken: {
      health: 4,
      drops: ['rawChicken', 'feather'],
      dropCount: { min: 0, max: 2 },
      size: { width: 0.6, height: 0.8, depth: 0.6 },
      color: 0xFFFFFF,
      speed: 0.03
    },
    horse: {
      health: 30,
      drops: ['leather'],
      dropCount: { min: 0, max: 2 },
      size: { width: 1.4, height: 1.8, depth: 1.8 },
      color: 0x8B4513,
      speed: 0.04
    },
    rabbit: {
      health: 3,
      drops: ['rawRabbit', 'rabbitHide'],
      dropCount: { min: 0, max: 1 },
      size: { width: 0.5, height: 0.5, depth: 0.7 },
      color: 0xD2B48C,
      speed: 0.045
    },
    wolf: {
      health: 8,
      drops: [],
      dropCount: { min: 0, max: 0 },
      size: { width: 0.8, height: 0.9, depth: 1.2 },
      color: 0x808080,
      speed: 0.035
    },
    cat: {
      health: 10,
      drops: ['string'],
      dropCount: { min: 0, max: 2 },
      size: { width: 0.6, height: 0.7, depth: 0.8 },
      color: 0xFF8C00,
      speed: 0.03
    }
  };

  const itemTypes = {
    ...blockTypes,
    leather: { color: 0x8B4513, name: 'Couro' },
    beef: { color: 0x8B0000, name: 'Carne Bovina' },
    pork: { color: 0xFFC0CB, name: 'Carne de Porco' },
    wool: { color: 0xFFFFFF, name: 'L√£' }
  };

  const PLAYER_WIDTH = 0.6;
  const PLAYER_HEIGHT = 1.8;
  const PLAYER_EYE_HEIGHT = 1.6;
  const COLLISION_TOLERANCE = 0.01;

  let enemies = [];
  let enemyMeshes = [];

  let villagers = [];
  let villagerMeshes = [];
  let villages = [];

  let playerModel = null;

  let walkAnimTime = 0;

  const multiplayer = {
    enabled: false,
    connected: false,
    ws: null,
    serverUrl: 'ws://localhost:8765',
    playerId: null,
    playerName: 'Jogador' + Math.floor(Math.random() * 1000),
    otherPlayers: new Map(),
    lastPositionSent: 0,
    positionUpdateInterval: 50 // ms
  };

  // Sistema de Controles Mobile
  const mobileControls = {
    enabled: false,
    joystick: { active: false, x: 0, y: 0 },
    look: { active: false, startX: 0, startY: 0 },
    buttons: {
      jump: false,
      fly: false,
      sprint: false,
      break: false,
      place: false
    }
  };



  const gameSettings = {
    graphics: {
      renderDistance: 6,
      antialiasing: false,
      shadows: true,
      fog: true,
      particles: 'all',
      fpsLimit: 'unlimited'
    },
    gameplay: {
      difficulty: 'normal',
      creative: false,
      autoJump: false,
      mobSpawn: 50,
      healthRegen: 5
    },
    controls: {
      mouseSensitivity: 10,
      invertY: false,
      touchSensitivity: 10
    },
    audio: {
      masterVolume: 70,
      sfxVolume: 80,
      musicVolume: 50,
      ambientVolume: 60
    }
  };




  // Adicionar os novos tipos ao enemyTypes (assumindo que este objeto existe)
  const enemyTypes = {
    zombie: {
      health: 20,
      speed: 0.03,
      damage: 3,
      attackRange: 2,
      detectionRange: 16,
      color: 0x00AA00,
      drops: ['rotten_flesh'],
      dropCount: { min: 0, max: 2 }
    },
    skeleton: {
      health: 20,
      speed: 0.04,
      damage: 2,
      attackRange: 12,
      detectionRange: 20,
      color: 0xC0C0C0,
      drops: ['bone', 'arrow'],
      dropCount: { min: 0, max: 2 }
    },
    creeper: {
      health: 20,
      speed: 0.035,
      damage: 25,
      attackRange: 3,
      detectionRange: 12,
      explodeTime: 1500,
      color: 0x00AA00,
      drops: ['gunpowder'],
      dropCount: { min: 0, max: 2 }
    },
    spider: {
      health: 16,
      speed: 0.05,
      damage: 2,
      attackRange: 2,
      detectionRange: 20,
      color: 0x4A4A4A,
      drops: ['string', 'spider_eye'],
      dropCount: { min: 0, max: 2 }
    },
    // NOVOS INIMIGOS
    enderman: {
      health: 40,
      speed: 0.07,
      damage: 7,
      attackRange: 3,
      detectionRange: 32,
      color: 0x161616,
      drops: ['ender_pearl'],
      dropCount: { min: 0, max: 1 }
    },
    ghast: {
      health: 10,
      speed: 0.02,
      damage: 6,
      attackRange: 30,
      detectionRange: 40,
      color: 0xF8F8FF,
      drops: ['ghast_tear', 'gunpowder'],
      dropCount: { min: 0, max: 1 }
    },
    slime: {
      health: 20,
      speed: 0.04,
      damage: 3,
      attackRange: 2,
      detectionRange: 12,
      color: 0x7CFC00,
      drops: ['slime_ball'],
      dropCount: { min: 0, max: 2 }
    },
    witch: {
      health: 26,
      speed: 0.03,
      damage: 4,
      attackRange: 15,
      detectionRange: 20,
      color: 0x800080,
      drops: ['glowstone_dust', 'redstone', 'sugar', 'glass_bottle'],
      dropCount: { min: 1, max: 3 }
    }
  };



  // Adicionar ap√≥s a declara√ß√£o das vari√°veis globais
  const LOD_SYSTEM = {
    enabled: true,
    distances: [20, 40, 60], // Dist√¢ncias para cada n√≠vel de LOD
    currentLOD: new Map(),
    chunkLODCache: new Map()
  };


  const lightingSystem = {
    lights: new Map(),
    maxLights: 50, // Limite para performance
    lightRange: 12,
    updateQueue: []
  };
  const shadowSystem = {
    quality: 'high', // 'low', 'medium', 'high', 'ultra'
    enabled: true,
    dynamicShadows: true,
    shadowDistance: 50,
    cascadeShadows: false
  };





  // Criar itemTypes baseado em blockTypes
  for (let type in blockTypes) {
    const block = blockTypes[type];
    // Determinar a cor principal do bloco
    let color;
    if (block.color) {
      color = block.color;
    } else if (block.topColor) {
      color = block.topColor;
    } else if (block.sideColor) {
      color = block.sideColor;
    } else {
      color = 0xFFFFFF; // Branco como padr√£o
    }
    itemTypes[type] = { color: color, name: block.name };
  }

  // Adicionar itens extras
  const extraItems = {
    leather: { color: 0x8B4513, name: 'Couro' },
    beef: { color: 0x8B0000, name: 'Carne Bovina' },
    pork: { color: 0xFFC0CB, name: 'Carne de Porco' },
    wool: { color: 0xFFFFFF, name: 'L√£' }
  };

  for (let type in extraItems) {
    itemTypes[type] = extraItems[type];
  }








  function getLODLevel(distance) {
    if (distance < LOD_SYSTEM.distances[0]) return 0; // Full detail
    if (distance < LOD_SYSTEM.distances[1]) return 1; // Medium detail
    if (distance < LOD_SYSTEM.distances[2]) return 2; // Low detail
    return 3; // Minimal detail
  }

  // Substituir a fun√ß√£o buildChunkMesh com suporte a LOD
  function buildChunkMeshWithLOD(cx, cz, lodLevel = 0) {
    const chunkKey = getChunkKey(cx, cz);
    const lodKey = `${chunkKey}_lod${lodLevel}`;

    // Cache de LOD
    if (LOD_SYSTEM.chunkLODCache.has(lodKey)) {
      return LOD_SYSTEM.chunkLODCache.get(lodKey);
    }

    if (chunkMeshes[chunkKey]) {
      scene.remove(chunkMeshes[chunkKey]);
      chunkMeshes[chunkKey].children.forEach(child => {
        child.geometry.dispose();
      });
      delete chunkMeshes[chunkKey];
    }

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;
    const geometriesByType = {};

    for (let type in blockTypes) {
      geometriesByType[type] = {
        positions: [],
        normals: [],
        indices: [],
        vertexCount: 0
      };
    }

    // Reduzir resolu√ß√£o baseado no LOD
    const step = lodLevel === 0 ? 1 : lodLevel === 1 ? 2 : lodLevel === 2 ? 4 : 8;

    let totalFaces = 0;

    for (let lx = 0; lx < CHUNK_SIZE; lx += step) {
      for (let lz = 0; lz < CHUNK_SIZE; lz += step) {
        for (let y = 0; y < 40; y += step) {
          const x = sx + lx;
          const z = sz + lz;
          const block = getBlock(x, y, z);

          if (!block) continue;

          const geo = geometriesByType[block.type];
          const blockSize = step; // Blocos maiores para LOD baixo

          const faces = [
            { dir: [1, 0, 0], corners: [[blockSize, 0, 0], [blockSize, blockSize, 0], [blockSize, blockSize, blockSize], [blockSize, 0, blockSize]] },
            { dir: [-1, 0, 0], corners: [[0, 0, blockSize], [0, blockSize, blockSize], [0, blockSize, 0], [0, 0, 0]] },
            { dir: [0, 1, 0], corners: [[0, blockSize, 0], [0, blockSize, blockSize], [blockSize, blockSize, blockSize], [blockSize, blockSize, 0]] },
            { dir: [0, -1, 0], corners: [[0, 0, 0], [blockSize, 0, 0], [blockSize, 0, blockSize], [0, 0, blockSize]] },
            { dir: [0, 0, 1], corners: [[0, 0, blockSize], [blockSize, 0, blockSize], [blockSize, blockSize, blockSize], [0, blockSize, blockSize]] },
            { dir: [0, 0, -1], corners: [[blockSize, 0, 0], [0, 0, 0], [0, blockSize, 0], [blockSize, blockSize, 0]] }
          ];

          for (let face of faces) {
            const [dx, dy, dz] = face.dir;
            const neighbor = getBlock(x + dx * step, y + dy * step, z + dz * step);

            if (!neighbor) {
              const baseIdx = geo.vertexCount;

              for (let corner of face.corners) {
                geo.positions.push(
                        x + corner[0] - blockSize/2,
                        y + corner[1] - blockSize/2,
                        z + corner[2] - blockSize/2
                );
                geo.normals.push(dx, dy, dz);
              }

              geo.indices.push(
                      baseIdx, baseIdx + 1, baseIdx + 2,
                      baseIdx, baseIdx + 2, baseIdx + 3
              );

              geo.vertexCount += 4;
              totalFaces++;
            }
          }
        }
      }
    }

    const group = new THREE.Group();

    for (let type in geometriesByType) {
      const geo = geometriesByType[type];
      if (geo.positions.length === 0) continue;

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(geo.positions, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(geo.normals, 3));
      geometry.setIndex(geo.indices);

      const mesh = new THREE.Mesh(geometry, materials[type]);
      mesh.userData.chunkKey = chunkKey;
      mesh.userData.type = type;
      mesh.userData.lodLevel = lodLevel;
      group.add(mesh);
    }

    if (group.children.length > 0) {
      scene.add(group);
      chunkMeshes[chunkKey] = group;
      chunkMeshes[chunkKey].userData.faceCount = totalFaces;
      chunkMeshes[chunkKey].userData.lodLevel = lodLevel;

      LOD_SYSTEM.chunkLODCache.set(lodKey, group);
      enableShadowsForChunk(chunkKey);
    }

    return totalFaces;
  }


  // Adicionar ap√≥s as vari√°veis globais
  const OCCLUSION_SYSTEM = {
    enabled: true,
    checkInterval: 100, // ms
    lastCheck: 0,
    occludedChunks: new Set(),
    raycaster: new THREE.Raycaster()
  };

  function checkChunkOcclusion(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);
    const chunkMesh = chunkMeshes[chunkKey];

    if (!chunkMesh) return false;

    // Centro do chunk
    const chunkCenterX = cx * CHUNK_SIZE + CHUNK_SIZE / 2;
    const chunkCenterZ = cz * CHUNK_SIZE + CHUNK_SIZE / 2;
    const chunkCenterY = 20; // Altura m√©dia

    // Dire√ß√£o da c√¢mera para o chunk
    const direction = new THREE.Vector3(
            chunkCenterX - camera.position.x,
            chunkCenterY - camera.position.y,
            chunkCenterZ - camera.position.z
    ).normalize();

    OCCLUSION_SYSTEM.raycaster.set(camera.position, direction);

    // Verificar se h√° chunks bloqueando a vis√£o
    const allMeshes = [];
    for (let key in chunkMeshes) {
      if (key !== chunkKey) {
        allMeshes.push(...chunkMeshes[key].children);
      }
    }

    const intersects = OCCLUSION_SYSTEM.raycaster.intersectObjects(allMeshes, false);

    // Se houver intersec√ß√£o antes do chunk alvo, est√° ocluso
    if (intersects.length > 0) {
      const distanceToChunk = camera.position.distanceTo(
              new THREE.Vector3(chunkCenterX, chunkCenterY, chunkCenterZ)
      );

      return intersects[0].distance < distanceToChunk - CHUNK_SIZE;
    }

    return false;
  }

  function updateOcclusionCulling() {
    const now = Date.now();

    if (!OCCLUSION_SYSTEM.enabled || now - OCCLUSION_SYSTEM.lastCheck < OCCLUSION_SYSTEM.checkInterval) {
      return;
    }

    OCCLUSION_SYSTEM.lastCheck = now;
    OCCLUSION_SYSTEM.occludedChunks.clear();

    for (let key in chunkMeshes) {
      const [cx, cz] = key.split(',').map(Number);

      if (checkChunkOcclusion(cx, cz)) {
        OCCLUSION_SYSTEM.occludedChunks.add(key);
        chunkMeshes[key].visible = false;
      } else if (chunkMeshes[key].visible === false) {
        chunkMeshes[key].visible = true;
      }
    }
  }



  // Sistema de instancing para performance
  const INSTANCING_SYSTEM = {
    enabled: true,
    instances: new Map(),
    maxInstancesPerType: 1000
  };

  function createInstancedChunk(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);
    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    // Agrupar blocos por tipo
    const blocksByType = {};

    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
      for (let lz = 0; lz < CHUNK_SIZE; lz++) {
        for (let y = 0; y < 40; y++) {
          const x = sx + lx;
          const z = sz + lz;
          const block = getBlock(x, y, z);

          if (!block) continue;

          if (!blocksByType[block.type]) {
            blocksByType[block.type] = [];
          }

          blocksByType[block.type].push({ x, y, z });
        }
      }
    }

    const group = new THREE.Group();

    for (let type in blocksByType) {
      const blocks = blocksByType[type];

      if (blocks.length > 50) { // Usar instancing apenas se houver muitos blocos
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const mesh = new THREE.InstancedMesh(
                geometry,
                materials[type],
                Math.min(blocks.length, INSTANCING_SYSTEM.maxInstancesPerType)
        );

        const matrix = new THREE.Matrix4();

        blocks.forEach((block, i) => {
          if (i >= INSTANCING_SYSTEM.maxInstancesPerType) return;

          matrix.setPosition(block.x, block.y, block.z);
          mesh.setMatrixAt(i, matrix);
        });

        mesh.instanceMatrix.needsUpdate = true;
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        group.add(mesh);
      }
    }

    if (group.children.length > 0) {
      scene.add(group);
      chunkMeshes[chunkKey] = group;
    }
  }



















































  function createHealthUI() {
    const container = document.getElementById('health-container');
    for (let i = 0; i < MAX_HEALTH / 2; i++) {
      const heart = document.createElement('div');
      heart.className = 'heart';
      container.appendChild(heart);
    }
    updateHealthUI();
  }

  function updateHealthUI() {
    const hearts = document.querySelectorAll('.heart');
    hearts.forEach((heart, index) => {
      const heartIndex = index * 2;
      if (playerHealth >= heartIndex + 2) {
        heart.className = 'heart';
      } else if (playerHealth >= heartIndex + 1) {
        heart.className = 'heart half';
      } else {
        heart.className = 'heart empty';
      }
    });
  }

  function damagePlayer(amount) {
    playerHealth = Math.max(0, playerHealth - amount);
    updateHealthUI();

    // Verificar morte
    if (playerHealth <= 0) {
      playerHealth = MAX_HEALTH;
      camera.position.set(0, 25, 0);
      player.velocity.set(0, 0, 0);
      updateHealthUI();
    }
  }

  function initializeInventory() {
    // Blocos b√°sicos
    addToInventory('grass', 64);
    addToInventory('dirt', 64);
    addToInventory('stone', 32);
    addToInventory('wood', 32);
    addToInventory('planks', 32);

    // Blocos decorativos
    addToInventory('concrete_white', 16);
    addToInventory('concrete_blue', 16);
    addToInventory('brick', 16);
    addToInventory('quartz', 16);

    // Blocos luminosos
    addToInventory('glowstone', 16);
    addToInventory('lantern', 16);
    addToInventory('torch', 32);

    // Blocos funcionais
    addToInventory('crafting_table', 4);
    addToInventory('chest', 4);
    addToInventory('furnace', 2);

    player.selectedSlot = 0;
  }

  function addToInventory(type, count) {
    // Encontrar slot existente com o mesmo tipo
    for (let i = 0; i < player.inventory.length; i++) {
      if (player.inventory[i].type === type && player.inventory[i].count < 64) {
        const availableSpace = 64 - player.inventory[i].count;
        const toAdd = Math.min(count, availableSpace);
        player.inventory[i].count += toAdd;
        count -= toAdd;
        if (count <= 0) break;
      }
    }

    // Se ainda h√° itens, encontrar slot vazio
    if (count > 0) {
      for (let i = 0; i < player.inventory.length; i++) {
        if (player.inventory[i].count === 0) {
          player.inventory[i].type = type;
          player.inventory[i].count = Math.min(count, 64);
          count -= player.inventory[i].count;
          if (count <= 0) break;
        }
      }
    }

    updateInventoryUI();
    updateFullInventoryUI();
  }

  function removeFromInventory(slotIndex, count = 1) {
    if (slotIndex < 0 || slotIndex >= player.inventory.length) return false;
    if (player.inventory[slotIndex].count >= count) {
      player.inventory[slotIndex].count -= count;
      if (player.inventory[slotIndex].count <= 0) {
        player.inventory[slotIndex].type = null;
        player.inventory[slotIndex].count = 0;
      }
      updateInventoryUI();
      updateFullInventoryUI();
      return true;
    }
    return false;
  }

  function getSelectedItem() {
    const slot = player.inventory[player.selectedSlot];
    return slot.count > 0 ? slot.type : null;
  }

  function createInventoryUI() {
    const invBar = document.getElementById('inventory-bar');
    invBar.innerHTML = '';

    for (let i = 0; i < player.hotbarSlots; i++) {
      const slot = document.createElement('div');
      slot.className = `inv-slot ${i === player.selectedSlot ? 'active' : ''}`;
      slot.dataset.index = i;

      const slotData = player.inventory[i];
      if (slotData.count > 0) {
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div class="block-icon" style="background: #${colorHex}"></div>
                    <div class="slot-count">${slotData.count}</div>
                `;
      }

      slot.onclick = () => selectSlot(i);
      invBar.appendChild(slot);
    }
  }

  function createFullInventoryUI() {
    const invFull = document.getElementById('inventory-full');
    invFull.innerHTML = '';

    for (let i = 0; i < player.inventorySlots; i++) {
      const slot = document.createElement('div');
      slot.className = 'inv-full-slot';
      slot.dataset.index = i;

      const slotData = player.inventory[i];
      if (slotData.count > 0) {
        slot.classList.add('has-item');
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div style="width: 35px; height: 35px; background: #${colorHex}; border-radius: 3px;"></div>
                    <div style="position: absolute; bottom: 2px; right: 5px; font-size: 10px; color: white;">${slotData.count}</div>
                `;
      }

      invFull.appendChild(slot);
    }
  }

  function updateInventoryUI() {
    const slots = document.querySelectorAll('#inventory-bar .inv-slot');
    slots.forEach((slot, i) => {
      const slotData = player.inventory[i];
      slot.classList.toggle('active', i === player.selectedSlot);

      if (slotData.count > 0) {
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div class="block-icon" style="background: #${colorHex}"></div>
                    <div class="slot-count">${slotData.count}</div>
                `;
      } else {
        slot.innerHTML = '';
      }
    });

    const selectedItem = getSelectedItem();
    document.getElementById('selected-block').textContent = selectedItem ? itemTypes[selectedItem].name : 'Vazio';
  }

  function updateFullInventoryUI() {
    const slots = document.querySelectorAll('#inventory-full .inv-full-slot');
    slots.forEach((slot, i) => {
      const slotData = player.inventory[i];
      slot.innerHTML = '';

      if (slotData.count > 0) {
        slot.classList.add('has-item');
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div style="width: 35px; height: 35px; background: #${colorHex}; border-radius: 3px;"></div>
                    <div style="position: absolute; bottom: 2px; right: 5px; font-size: 10px; color: white;">${slotData.count}</div>
                `;
      } else {
        slot.classList.remove('has-item');
      }
    });
  }

  function selectSlot(index) {
    if (index >= 0 && index < player.hotbarSlots) {
      player.selectedSlot = index;
      updateInventoryUI();
    }
  }

  function toggleFullInventory() {
    const invFull = document.getElementById('inventory-full');
    invFull.classList.toggle('open');
    controls.locked = !invFull.classList.contains('open');

    if (invFull.classList.contains('open')) {
      document.exitPointerLock();
      updateFullInventoryUI();
    } else {
      renderer.domElement.requestPointerLock();
    }
  }

  function getHeight(x, z) {
    const n1 = noise(x * 0.04, z * 0.04) * 10;
    const n2 = noise(x * 0.08, z * 0.08) * 5;
    const n3 = noise(x * 0.15, z * 0.15) * 2;
    return Math.floor(12 + n1 + n2 + n3);
  }

  function getBlockKey(x, y, z) {
    return `${x},${y},${z}`;
  }

  function getChunkKey(cx, cz) {
    return `${cx},${cz}`;
  }

  function worldToChunk(x, z) {
    return {
      x: Math.floor(x / CHUNK_SIZE),
      z: Math.floor(z / CHUNK_SIZE)
    };
  }

  function setBlock(x, y, z, type) {
    worldData[getBlockKey(x, y, z)] = { x, y, z, type };
  }

  function getBlock(x, y, z) {
    return worldData[getBlockKey(x, y, z)];
  }

  function removeBlockData(x, y, z) {
    delete worldData[getBlockKey(x, y, z)];
  }

  function removeAnimalsInChunk(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;
    const ex = sx + CHUNK_SIZE;
    const ez = sz + CHUNK_SIZE;

    for (let i = animals.length - 1; i >= 0; i--) {
      const animal = animals[i];
      if (animal.x >= sx && animal.x < ex && animal.z >= sz && animal.z < ez) {
        animal.remove();
        animals.splice(i, 1);
      }
    }
  }


  function removeEnemiesInChunk(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;
    const ex = sx + CHUNK_SIZE;
    const ez = sz + CHUNK_SIZE;

    for (let i = enemies.length - 1; i >= 0; i--) {
      const enemy = enemies[i];
      if (enemy.x >= sx && enemy.x < ex && enemy.z >= sz && enemy.z < ez) {
        enemy.remove();
        enemies.splice(i, 1);
      }
    }
  }

  function updateFaceCount() {
    let totalFaces = 0;
    for (let key in chunkMeshes) {
      if (chunkMeshes[key].userData.faceCount) {
        totalFaces += chunkMeshes[key].userData.faceCount;
      }
    }
    document.getElementById('visible').textContent = totalFaces;
  }

  function updateBreakAnimations() {
    const now = Date.now();
    breakingAnimations = breakingAnimations.filter(anim => {
      const age = now - anim.created;
      if (age > 400) {
        anim.particles.forEach(p => {
          scene.remove(p);
          p.geometry.dispose();
          p.material.dispose();
        });
        return false;
      }

      anim.particles.forEach(p => {
        p.velocity.y -= 0.01;
        p.position.add(p.velocity);
        p.material.opacity = 1 - (age / 400);
      });

      return true;
    });
  }

  function setupEventListeners() {
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;

      // Selecionar slots 1-9
      if (e.code >= 'Digit1' && e.code <= 'Digit9') {
        const idx = parseInt(e.code.slice(-1)) - 1;
        if (idx < player.hotbarSlots) selectSlot(idx);
      }

      // Modo voo
      if (e.code === 'KeyF') {
        player.flying = !player.flying;
        document.getElementById('mode').textContent = player.flying ? 'Voo' : 'Normal';
      }

      // Invent√°rio completo
      if (e.code === 'KeyE') {
        toggleFullInventory();
      }

      // Jogar item
      if (e.code === 'KeyQ' && !document.getElementById('inventory-full').classList.contains('open')) {
        const selectedItem = getSelectedItem();
        if (selectedItem && removeFromInventory(player.selectedSlot, 1)) {
          // Criar entidade do item jogado
          const itemMesh = new THREE.Mesh(
                  new THREE.BoxGeometry(0.3, 0.3, 0.3),
                  new THREE.MeshLambertMaterial({ color: itemTypes[selectedItem].color })
          );
          itemMesh.position.copy(camera.position);
          itemMesh.velocity = new THREE.Vector3(
                  camera.getWorldDirection(new THREE.Vector3()).x * 0.5,
                  0.3,
                  camera.getWorldDirection(new THREE.Vector3()).z * 0.5
          );
          scene.add(itemMesh);

          // Remover ap√≥s 5 segundos
          setTimeout(() => {
            if (itemMesh.parent) {
              scene.remove(itemMesh);
            }
          }, 5000);
        }
      }

      // Reproduzir animais (debug)
      if (e.code === 'KeyR') {
        const chunk = worldToChunk(camera.position.x, camera.position.z);
        spawnAnimals(chunk.x, chunk.z);
      }
    });

    document.addEventListener('keyup', (e) => keys[e.code] = false);

    document.addEventListener('mousemove', (e) => {
      if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;

      // Corre√ß√£o: Controles desinvertidos - movimento do mouse mais suave
      mouse.x -= e.movementX * 0.002; // Invertido o sinal para desinverter
      mouse.y -= e.movementY * 0.002; // Mantido para controle vertical normal

      mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
    });

    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('wheel', handleScroll);
    document.addEventListener('contextmenu', (e) => e.preventDefault());
    window.addEventListener('resize', onWindowResize);

    document.addEventListener('pointerlockchange', () => {
      controls.locked = document.pointerLockElement === renderer.domElement;
    });
  }

  function handleInventoryScroll(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;
    if (mobileControls.enabled) return; // Desabilitar scroll em mobile

    e.preventDefault();
    const dir = e.deltaY > 0 ? 1 : -1;
    const newSlot = (player.selectedSlot + dir + player.hotbarSlots) % player.hotbarSlots;
    selectSlot(newSlot);
  }

  document.addEventListener('wheel', handleInventoryScroll);

  function handleMouseDown(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;

    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

    // Verificar colis√£o com animais primeiro
    const animalIntersects = raycaster.intersectObjects(animalMeshes);
    if (animalIntersects.length > 0 && e.button === 0) {
      const animalMesh = animalIntersects[0].object;
      const animal = animals.find(a => a.mesh === animalMesh);
      if (animal) {
        if (animal.damage(1)) {
          // Animal morto
          damagePlayer(1); // Dano ao jogador por matar animal
        }
      }
      return;
    }

    // Verificar colis√£o com blocos
    const allMeshes = [];
    for (let key in chunkMeshes) {
      allMeshes.push(...chunkMeshes[key].children);
    }

    const intersects = raycaster.intersectObjects(allMeshes);
    if (intersects.length === 0) return;

    const hit = intersects[0];
    const hitPos = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(-0.1));
    const bx = Math.round(hitPos.x);
    const by = Math.round(hitPos.y);
    const bz = Math.round(hitPos.z);

    if (e.button === 0) {
      const block = getBlock(bx, by, bz);
      if (block && block.type !== 'bedrock') {
        player.breaking = { x: bx, y: by, z: bz };
        player.breakStartTime = Date.now();
        player.breakBlockType = block.type;

        // Mostrar barra de progresso
        const progressBar = document.getElementById('break-progress');
        progressBar.style.display = 'block';
      }
    } else if (e.button === 2) {
      const placePos = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(0.5));
      const px = Math.round(placePos.x);
      const py = Math.round(placePos.y);
      const pz = Math.round(placePos.z);

      const selectedItem = getSelectedItem();
      if (selectedItem && blockTypes[selectedItem]) {
        placeBlock(px, py, pz, selectedItem);
      }
    }
  }

  function handleMouseUp(e) {
    if (e.button === 0) {
      player.breaking = null;
      player.breakProgress = 0;
      document.getElementById('break-progress').style.display = 'none';
    }
  }

  function updateBreaking() {
    if (player.breaking) {
      const block = getBlock(player.breaking.x, player.breaking.y, player.breaking.z);
      if (!block || block.type !== player.breakBlockType) {
        player.breaking = null;
        document.getElementById('break-progress').style.display = 'none';
        return;
      }

      const hardness = blockTypes[block.type].hardness;
      const elapsed = Date.now() - player.breakStartTime;
      player.breakProgress = elapsed / (BREAK_TIME * hardness);

      // Atualizar barra de progresso
      const progressFill = document.querySelector('.break-progress-fill');
      progressFill.style.width = `${Math.min(player.breakProgress * 100, 100)}%`;

      if (player.breakProgress >= 1) {
        removeBlock(player.breaking.x, player.breaking.y, player.breaking.z);
        player.breaking = null;
        player.breakProgress = 0;
        document.getElementById('break-progress').style.display = 'none';
      }
    }
  }

  function handleScroll(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;
    e.preventDefault();
    const dir = e.deltaY > 0 ? 1 : -1;
    const newSlot = (player.selectedSlot + dir + player.hotbarSlots) % player.hotbarSlots;
    selectSlot(newSlot);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function updatePlayer() {
    const dir = new THREE.Vector3();
    const right = new THREE.Vector3();

    camera.getWorldDirection(dir);
    dir.y = 0;
    dir.normalize();
    // CORRE√á√ÉO: Vetor right calculado corretamente para controles padr√£o
    right.crossVectors(dir, camera.up).normalize();

    const speed = keys['ShiftLeft'] ? SPRINT_SPEED : (player.flying ? FLY_SPEED : MOVE_SPEED);

    // Calcular movimento desejado - CORRE√á√ÉO DOS CONTROLES
    const move = new THREE.Vector3();
    if (keys['KeyW']) move.add(dir);
    if (keys['KeyS']) move.add(dir.clone().negate());
    if (keys['KeyA']) move.add(right.clone().negate()); // CORRE√á√ÉO: Movimento para esquerda
    if (keys['KeyD']) move.add(right); // CORRE√á√ÉO: Movimento para direita

    if (move.length() > 0) {
      move.normalize().multiplyScalar(speed);
    }

    // Aplicar gravidade se n√£o estiver voando
    if (!player.flying) {
      player.velocity.y += GRAVITY;
      move.y = player.velocity.y;
    } else {
      if (keys['Space']) move.y = FLY_SPEED;
      if (keys['ShiftLeft']) move.y = -FLY_SPEED;
      player.velocity.y = 0;
    }

    // Detectar colis√µes e ajustar movimento
    const newPos = camera.position.clone().add(move);
    const collision = checkCollision(newPos);

    // Colis√£o lateral
    if (collision.sides) {
      // Projetar movimento no plano XZ para evitar paredes
      const lateralMove = new THREE.Vector3(move.x, 0, move.z);

      // Testar movimento apenas em X
      const testX = new THREE.Vector3(camera.position.x + move.x, camera.position.y, camera.position.z);
      if (!checkCollision(testX).sides) {
        camera.position.x = testX.x;
        move.x = 0;
      }

      // Testar movimento apenas em Z
      const testZ = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z + move.z);
      if (!checkCollision(testZ).sides) {
        camera.position.z = testZ.z;
        move.z = 0;
      }

      // Se ainda houver colis√£o, tentar deslizar
      if (move.x !== 0 || move.z !== 0) {
        const slideMove = new THREE.Vector3(move.x, 0, move.z);
        slideMove.normalize().multiplyScalar(speed * 0.5);

        const testSlide = new THREE.Vector3(
                camera.position.x + slideMove.x,
                camera.position.y,
                camera.position.z + slideMove.z
        );

        if (!checkCollision(testSlide).sides) {
          camera.position.x = testSlide.x;
          camera.position.z = testSlide.z;
        }
      }
    } else {
      // Sem colis√£o lateral, mover normalmente
      camera.position.x += move.x;
      camera.position.z += move.z;
    }

    // Colis√£o vertical
    if (collision.ground) {
      // No ch√£o
      player.velocity.y = 0;
      player.canJump = true;

      // Ajustar posi√ß√£o para ficar exatamente em cima do bloco
      const groundY = Math.floor(newPos.y - PLAYER_HEIGHT/2) + 1 + PLAYER_HEIGHT/2;
      camera.position.y = groundY;

      // Pular
      if (keys['Space'] && player.canJump) {
        player.velocity.y = JUMP_SPEED;
        player.canJump = false;
      }
    } else if (collision.ceiling) {
      // Batendo no teto
      player.velocity.y = Math.min(player.velocity.y, 0);
      const ceilingY = Math.floor(newPos.y + PLAYER_HEIGHT/2) - COLLISION_TOLERANCE - PLAYER_HEIGHT/2;
      camera.position.y = ceilingY;
    } else {
      // No ar
      camera.position.y += move.y;
      player.canJump = false;
    }

    // Dano por queda
    if (player.velocity.y < -2.5 && !player.flying && collision.ground) {
      const fallDamage = Math.floor(Math.abs(player.velocity.y) - 2);
      if (fallDamage > 0) {
        damagePlayer(fallDamage);
      }
    }

    // Atualizar rota√ß√£o da c√¢mera
    camera.rotation.order = 'YXZ';
    camera.rotation.y = mouse.x;
    camera.rotation.x = mouse.y;

    // Atualizar chunks
    const chunk = worldToChunk(camera.position.x, camera.position.z);
    if (chunk.x !== player.lastChunk.x || chunk.z !== player.lastChunk.z) {
      player.lastChunk = chunk;
      updateVisibleChunks();
    }
  }

  function checkCollision(position) {
    const result = {
      sides: false,
      ground: false,
      ceiling: false
    };

    // Definir pontos de teste para o jogador
    const playerMinY = position.y - PLAYER_HEIGHT/2;
    const playerMaxY = position.y + PLAYER_HEIGHT/2;
    const playerRadius = PLAYER_WIDTH/2;

    // Testar colis√£o com o ch√£o
    const groundTestPoints = [
      new THREE.Vector3(position.x, playerMinY - COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x + playerRadius, playerMinY - COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x - playerRadius, playerMinY - COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x, playerMinY - COLLISION_TOLERANCE, position.z + playerRadius),
      new THREE.Vector3(position.x, playerMinY - COLLISION_TOLERANCE, position.z - playerRadius)
    ];

    for (const point of groundTestPoints) {
      const block = getBlock(
              Math.floor(point.x),
              Math.floor(point.y),
              Math.floor(point.z)
      );
      if (block && block.type !== 'leaves' && block.type !== 'glass') {
        result.ground = true;
        break;
      }
    }

    // Testar colis√£o com o teto
    const ceilingTestPoints = [
      new THREE.Vector3(position.x, playerMaxY + COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x + playerRadius, playerMaxY + COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x - playerRadius, playerMaxY + COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x, playerMaxY + COLLISION_TOLERANCE, position.z + playerRadius),
      new THREE.Vector3(position.x, playerMaxY + COLLISION_TOLERANCE, position.z - playerRadius)
    ];

    for (const point of ceilingTestPoints) {
      const block = getBlock(
              Math.floor(point.x),
              Math.floor(point.y),
              Math.floor(point.z)
      );
      if (block && block.type !== 'leaves' && block.type !== 'glass') {
        result.ceiling = true;
        break;
      }
    }

    // Testar colis√£o lateral
    const sideTestPoints = [];
    const angles = [0, 45, 90, 135, 180, 225, 270, 315];

    for (const angle of angles) {
      const rad = angle * Math.PI / 180;
      const testPoint = new THREE.Vector3(
              position.x + Math.cos(rad) * playerRadius,
              position.y,
              position.z + Math.sin(rad) * playerRadius
      );
      sideTestPoints.push(testPoint);

      // Testar tamb√©m em diferentes alturas
      sideTestPoints.push(testPoint.clone().setY(position.y + PLAYER_HEIGHT/3));
      sideTestPoints.push(testPoint.clone().setY(position.y - PLAYER_HEIGHT/3));
    }

    for (const point of sideTestPoints) {
      const block = getBlock(
              Math.floor(point.x),
              Math.floor(point.y),
              Math.floor(point.z)
      );
      if (block && block.type !== 'leaves' && block.type !== 'glass') {
        result.sides = true;
        break;
      }
    }

    return result;
  }

  function noise(x, z) {
    const X = Math.floor(x);
    const Z = Math.floor(z);
    const xf = x - X;
    const zf = z - Z;

    const a = hash(X, Z);
    const b = hash(X + 1, Z);
    const c = hash(X, Z + 1);
    const d = hash(X + 1, Z + 1);

    const u = xf * xf * (3.0 - 2.0 * xf);
    const v = zf * zf * (3.0 - 2.0 * zf);

    return a * (1 - u) * (1 - v) + b * u * (1 - v) + c * (1 - u) * v + d * u * v;
  }

  function hash(x, y) {
    let h = x * 374761393 + y * 668265263;
    h = (h ^ (h >> 13)) * 1274126177;
    return Math.abs((h ^ (h >> 16)) / 2147483648.0);
  }

  function createPlayerModel() {
    const group = new THREE.Group();

    // Corpo
    const bodyGeo = new THREE.BoxGeometry(0.6, 0.9, 0.3);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = -0.8;
    group.add(body);

    // Cabe√ßa
    const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = -0.1;
    head.userData.isHead = true;
    group.add(head);

    // Bra√ßos
    const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
    const armMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });

    const leftArm = new THREE.Mesh(armGeo, armMat);
    leftArm.position.set(-0.4, -0.7, 0);
    leftArm.userData.isArm = true;
    leftArm.userData.side = 'left';
    group.add(leftArm);

    const rightArm = new THREE.Mesh(armGeo, armMat);
    rightArm.position.set(0.4, -0.7, 0);
    rightArm.userData.isArm = true;
    rightArm.userData.side = 'right';
    group.add(rightArm);

    // Pernas
    const legGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
    const legMat = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });

    const leftLeg = new THREE.Mesh(legGeo, legMat);
    leftLeg.position.set(-0.15, -1.4, 0);
    leftLeg.userData.isLeg = true;
    leftLeg.userData.side = 'left';
    group.add(leftLeg);

    const rightLeg = new THREE.Mesh(legGeo, legMat);
    rightLeg.position.set(0.15, -1.4, 0);
    rightLeg.userData.isLeg = true;
    rightLeg.userData.side = 'right';
    group.add(rightLeg);

    playerModel = group;
    camera.add(playerModel);
  }

  const originalHandleMouseDown = handleMouseDown;

  handleMouseDown = function(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;

    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

    // Verificar inimigos primeiro
    if (e.button === 0) {
      const enemyIntersects = raycaster.intersectObjects(enemyMeshes);
      if (enemyIntersects.length > 0) {
        const enemyMesh = enemyIntersects[0].object;
        let enemy = null;

        // Encontrar o grupo pai que cont√©m a refer√™ncia ao inimigo
        let current = enemyMesh;
        while (current && !enemy) {
          if (current.userData && current.userData.enemyRef) {
            enemy = current.userData.enemyRef;
          }
          current = current.parent;
        }

        if (enemy) {
          enemy.damage(5);
          return;
        }
      }
    }

    // Chamar fun√ß√£o original para blocos e animais
    originalHandleMouseDown.call(this, e);
  };

  const originalStartGame = startGame;
  startGame = function() {
    originalStartGame.call(this);


    createPlayerModel();

    // Gerar uma vila pr√≥xima ao spawn
    generateVillage(30, 30);

    // Spawnar alguns inimigos
    const chunk = worldToChunk(0, 0);
    for (let cx = chunk.x - 2; cx <= chunk.x + 2; cx++) {
      for (let cz = chunk.z - 2; cz <= chunk.z + 2; cz++) {
        if (Math.random() > 0.7) {
          spawnEnemies(cx, cz);
        }
      }
    }

    initMobileControls();
    animate();
  };

  // Atualizar UI para mostrar contagem de entidades
  document.getElementById('animals-count').parentElement.querySelector('strong').textContent = 'Entidades:';


  let sky, waterMeshes = [], particles = [], clouds = [];
  let dayNightCycle = 0;
  const DAY_LENGTH = 120000;

  let playerCharacter = null;

  class WaterSystem {
    constructor() {
      this.meshes = [];
      this.waterLevels = new Map();
    }

    createWaterBlock(x, y, z) {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshLambertMaterial({
        color: 0x1E90FF,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide
      });

      const water = new THREE.Mesh(geometry, material);
      water.position.set(x, y, z);
      water.userData.isWater = true;
      water.userData.waveOffset = Math.random() * Math.PI * 2;
      water.userData.baseY = y;

      scene.add(water);
      this.meshes.push(water);
      waterMeshes.push(water);

      return water;
    }

    updateWaves(time) {
      for (const water of this.meshes) {
        if (water.userData.isWater) {
          const waveHeight = Math.sin(time * 2 + water.userData.waveOffset) * 0.05;
          water.position.y = water.userData.baseY + waveHeight;

          // Efeito de transpar√™ncia pulsante
          water.material.opacity = 0.6 + Math.sin(time * 3 + water.userData.waveOffset) * 0.1;
        }
      }
    }

    removeWater(x, y, z) {
      for (let i = this.meshes.length - 1; i >= 0; i--) {
        const water = this.meshes[i];
        if (Math.floor(water.position.x) === x &&
                Math.floor(water.position.y) === y &&
                Math.floor(water.position.z) === z) {
          scene.remove(water);
          water.geometry.dispose();
          water.material.dispose();
          this.meshes.splice(i, 1);

          const waterIndex = waterMeshes.indexOf(water);
          if (waterIndex > -1) waterMeshes.splice(waterIndex, 1);
          break;
        }
      }
    }
  }

  let waterSystem = null;

  class ParticleSystem {
    constructor() {
      this.particles = [];
      this.maxParticles = 1000;
      this.pool = [];
      this.initPool();
    }

    initPool() {
      for (let i = 0; i < this.maxParticles; i++) {
        const geometry = new THREE.SphereGeometry(0.05, 3, 3);
        const material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const particle = new THREE.Mesh(geometry, material);
        particle.visible = false;
        scene.add(particle);
        this.pool.push(particle);
      }
    }

    emit(position, color, count = 10, velocity = 0.1) {
      for (let i = 0; i < Math.min(count, this.pool.length); i++) {
        const particle = this.pool.pop();
        if (!particle) break;

        particle.position.copy(position);
        particle.position.add(new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2
        ));

        particle.material.color.set(color);
        particle.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * velocity,
                Math.random() * velocity * 0.5,
                (Math.random() - 0.5) * velocity
        );
        particle.userData.life = 1.0;
        particle.userData.decay = 0.02 + Math.random() * 0.02;
        particle.visible = true;

        this.particles.push(particle);
      }
    }

    update() {
      for (let i = this.particles.length - 1; i >= 0; i--) {
        const particle = this.particles[i];

        particle.userData.life -= particle.userData.decay;
        particle.position.add(particle.userData.velocity);
        particle.userData.velocity.y -= 0.01;

        particle.material.opacity = particle.userData.life;
        particle.scale.setScalar(particle.userData.life);

        if (particle.userData.life <= 0) {
          particle.visible = false;
          this.pool.push(particle);
          this.particles.splice(i, 1);
        }
      }
    }
  }

  let particleSystem = null;

  function createSky() {
    // C√©u gradient
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const context = canvas.getContext('2d');

    const gradient = context.createLinearGradient(0, 0, 0, 256);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(0.5, '#98D8F0');
    gradient.addColorStop(1, '#B0E0E6');

    context.fillStyle = gradient;
    context.fillRect(0, 0, 256, 256);

    const texture = new THREE.CanvasTexture(canvas);
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.BackSide,
      fog: false
    });

    sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);
  }

  function createClouds() {
    const cloudCount = 30;
    for (let i = 0; i < cloudCount; i++) {
      const cloudGroup = new THREE.Group();

      // Criar nuvem com m√∫ltiplas esferas
      const cloudPieces = 3 + Math.floor(Math.random() * 3);
      for (let j = 0; j < cloudPieces; j++) {
        const size = 3 + Math.random() * 2;
        const geometry = new THREE.SphereGeometry(size, 8, 8);
        const material = new THREE.MeshLambertMaterial({
          color: 0xFFFFFF,
          transparent: true,
          opacity: 0.8
        });

        const piece = new THREE.Mesh(geometry, material);
        piece.position.set(
                (Math.random() - 0.5) * 8,
                (Math.random() - 0.5) * 3,
                (Math.random() - 0.5) * 8
        );
        cloudGroup.add(piece);
      }

      // Posicionar nuvem no c√©u
      cloudGroup.position.set(
              (Math.random() - 0.5) * 400,
              80 + Math.random() * 40,
              (Math.random() - 0.5) * 400
      );

      cloudGroup.userData.speed = 0.01 + Math.random() * 0.02;
      cloudGroup.userData.direction = new THREE.Vector3(
              Math.random() - 0.5,
              0,
              Math.random() - 0.5
      ).normalize();

      scene.add(cloudGroup);
      clouds.push(cloudGroup);
    }
  }

  function updateDayNightCycle(deltaTime) {
    dayNightCycle = (dayNightCycle + deltaTime * 0.001) % 1;

    const timeOfDay = Math.sin(dayNightCycle * Math.PI * 2);
    const brightness = Math.max(0.3, timeOfDay * 0.5 + 0.5);

    // Atualizar luz ambiente
    scene.traverse(object => {
      if (object.isLight && object.type !== 'AmbientLight') {
        object.intensity = brightness;
      }
    });

    // Atualizar cor do c√©u
    if (sky && sky.material.map) {
      const canvas = sky.material.map.image;
      const context = canvas.getContext('2d');

      const dayColor = `rgb(${135 * brightness}, ${206 * brightness}, ${235 * brightness})`;
      const nightColor = `rgb(${10 * brightness}, ${10 * brightness}, ${40 * brightness})`;

      const gradient = context.createLinearGradient(0, 0, 0, 256);
      gradient.addColorStop(0, timeOfDay > 0 ? dayColor : nightColor);
      gradient.addColorStop(1, timeOfDay > 0 ?
              `rgb(${152 * brightness}, ${216 * brightness}, ${240 * brightness})` :
              `rgb(${5 * brightness}, ${5 * brightness}, ${20 * brightness})`);

      context.fillStyle = gradient;
      context.fillRect(0, 0, 256, 256);

      sky.material.map.needsUpdate = true;
    }

    // Mover nuvens
    clouds.forEach(cloud => {
      cloud.position.add(cloud.userData.direction.clone().multiplyScalar(cloud.userData.speed));

      // Reposicionar nuvens que sa√≠ram do mapa
      if (cloud.position.length() > 500) {
        cloud.position.set(
                (Math.random() - 0.5) * 400,
                80 + Math.random() * 40,
                (Math.random() - 0.5) * 400
        );
      }
    });
  }

  const textureCache = {};


  document.addEventListener('keydown', (e) => {
    if (e.code === 'KeyT' && multiplayer.connected && !document.getElementById('multiplayer-chat').classList.contains('open')) {
      e.preventDefault();
      openChat();
    }

    if (e.code === 'Escape' && document.getElementById('multiplayer-chat').classList.contains('open')) {
      closeChat();
    }
  });

  document.getElementById('chat-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      sendChatMessage(e.target.value);
    }
  });

  async function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 60, 120);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 25, 0);

    renderer = new THREE.WebGLRenderer({
      antialias: true,
      powerPreference: "high-performance",
      alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));

    // ‚úÖ MOVER ESTA LINHA PARA C√Å (depois do renderer)
    setupShadowSystem();

    document.body.appendChild(renderer.domElement);

    raycaster = new THREE.Raycaster();
    raycaster.far = REACH;

    // Ilumina√ß√£o
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(100, 100, 50);
    setupSunShadows(sun);
    scene.add(sun);

    const ambient = new THREE.AmbientLight(0x404040, 0.9);
    scene.add(ambient);

    addAmbientOcclusion();
    addVolumetricShadows();

    createSky();
    createClouds();
    waterSystem = new WaterSystem();
    particleSystem = new ParticleSystem();

    // ‚úÖ CRIAR MATERIAIS AQUI (depois de tudo estar pronto)
    await createMaterialsWithEmissive();

    initializeInventory();
    createHealthUI();
    createInventoryUI();
    createFullInventoryUI();
    setupEventListeners();

    enableSoftShadows();
    loadSettings();
  }

  function generateChunk(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);
    if (chunks[chunkKey]) return;

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    for (let x = sx; x < sx + CHUNK_SIZE; x++) {
      for (let z = sz; z < sz + CHUNK_SIZE; z++) {
        const height = getHeight(x, z);

        // Bedrock na base
        setBlock(x, 0, z, 'bedrock');

        // Camadas subterr√¢neas
        const stoneHeight = height - 4;
        for (let y = 1; y < stoneHeight; y++) {
          setBlock(x, y, z, 'stone');
        }

        for (let y = stoneHeight; y < height - 1; y++) {
          setBlock(x, y, z, 'dirt');
        }

        setBlock(x, height - 1, z, 'dirt');
        setBlock(x, height, z, 'grass');

        // Adicionar √°rvores
        if (Math.random() > 0.990 && height < 50) {
          generateTree(x, height + 1, z);
        }

        // Adicionar √°gua em vales
        if (height < 10 && Math.random() > 0.7) {
          for (let y = height + 1; y <= 10; y++) {
            setBlock(x, y, z, 'water');
            waterSystem.createWaterBlock(x, y, z);
          }
        }

        // Flores e vegeta√ß√£o
        if (Math.random() > 0.95 && height < 40) {
          setBlock(x, height + 1, z, 'leaves');
        }
      }
    }

    chunks[chunkKey] = true;
  }

  function generateTree(x, y, z) {
    const treeHeight = Math.floor(Math.random() * 10) + 4;

    // Tronco
    for (let i = 0; i < treeHeight; i++) {
      setBlock(x, y + i, z, 'wood');
    }

    // Copa
    const topY = y + treeHeight - 1;
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 3) {
            setBlock(x + dx, topY + dy, z + dz, 'leaves');
          }
        }
      }
    }
  }

  function removeBlock(x, y, z) {
    const block = getBlock(x, y, z);
    if (!block || block.type === 'bedrock') return;

    // Criar part√≠culas do bloco quebrado
    if (particleSystem) {
      const color = blockTypes[block.type] ? blockTypes[block.type].color : 0xFFFFFF;
      particleSystem.emit(
              new THREE.Vector3(x, y, z),
              color,
              15,
              0.2
      );
    }

    // Remover √°gua se for bloco de √°gua
    if (block.type === 'water') {
      waterSystem.removeWater(x, y, z);
    }

    addToInventory(block.type, 1);
    removeBlockData(x, y, z);

    // Reconstruir chunks
    const chunk = worldToChunk(x, z);
    const chunksToUpdate = new Set();
    chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

    const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

    if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
    if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
    if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
    if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

    chunksToUpdate.forEach(key => {
      const [cx, cz] = key.split(',').map(Number);
      if (chunkMeshes[key]) {
        buildChunkMesh(cx, cz);
      }
    });

    updateFaceCount();
  }

  function placeBlock(x, y, z, type) {
    if (getBlock(x, y, z)) return;

    // Verificar se o bloco est√° dentro do jogador
    const playerBox = new THREE.Box3(
            new THREE.Vector3(
                    camera.position.x - PLAYER_WIDTH/2,
                    camera.position.y - PLAYER_HEIGHT/2,
                    camera.position.z - PLAYER_WIDTH/2
            ),
            new THREE.Vector3(
                    camera.position.x + PLAYER_WIDTH/2,
                    camera.position.y + PLAYER_HEIGHT/2,
                    camera.position.z + PLAYER_WIDTH/2
            )
    );

    const blockBox = new THREE.Box3(
            new THREE.Vector3(x - 0.5, y - 0.5, z - 0.5),
            new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5)
    );

    if (playerBox.intersectsBox(blockBox)) return;

    // Verificar se tem o item no invent√°rio
    const selectedItem = getSelectedItem();
    if (selectedItem === type && removeFromInventory(player.selectedSlot, 1)) {
      setBlock(x, y, z, type);

      // ‚ú® ILUMINA√á√ÉO: Adicionar luz se o bloco for emissivo
      if (blockTypes[type] && blockTypes[type].emissive) {
        addBlockLight(x, y, z, type);
      }

      // Se for √°gua, criar mesh especial
      if (type === 'water') {
        waterSystem.createWaterBlock(x, y, z);
        // Adicionar ilumina√ß√£o suave para √°gua
        addWaterLighting(x, y, z);
      }

      // ‚úÖ SINCRONIZAR MULTIPLAYER
      if (multiplayer.connected) {
        console.log('üì§ Sincronizando coloca√ß√£o de bloco:', type, 'em', x, y, z);
        sendMultiplayerMessage({
          type: 'block_place',
          x: Math.floor(x),
          y: Math.floor(y),
          z: Math.floor(z),
          blockType: type
        });
      }

      // Reconstruir chunks afetados
      const chunk = worldToChunk(x, z);
      const chunksToUpdate = new Set();
      chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

      const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
      const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

      if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
      if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
      if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
      if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

      chunksToUpdate.forEach(key => {
        const [cx, cz] = key.split(',').map(Number);
        if (chunkMeshes[key]) {
          buildChunkMesh(cx, cz);
        }
      });

      updateFaceCount();
    }
  }


  blockTypes.water = { color: 0x1E90FF, name: '√Ågua', hardness: 0.5 };


  function cleanupUnusedResources() {
    // Limpar geometrias n√£o utilizadas
    for (let key in chunkMeshes) {
      const chunk = chunkMeshes[key];
      if (!scene.children.includes(chunk)) {
        chunk.children.forEach(child => {
          child.geometry.dispose();
          child.material.dispose();
        });
        delete chunkMeshes[key];
      }
    }

    // Limpar part√≠culas antigas
    if (particles.length > 1000) {
      particles.splice(0, particles.length - 1000).forEach(p => {
        scene.remove(p);
        p.geometry.dispose();
        p.material.dispose();
      });
    }

    // Limpar anima√ß√µes de quebra antigas
    if (breakingAnimations.length > 50) {
      breakingAnimations.splice(0, breakingAnimations.length - 50).forEach(anim => {
        anim.particles.forEach(p => {
          scene.remove(p);
          p.geometry.dispose();
          p.material.dispose();
        });
      });
    }
  }

  setInterval(cleanupUnusedResources, 30000);


  document.addEventListener('touchmove', (e) => {
    if (e.scale !== 1) {
      e.preventDefault();
    }
  }, { passive: false });

  let lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
      e.preventDefault();
    }
    lastTouchEnd = now;
  }, false);

  document.addEventListener('DOMContentLoaded', () => {
    const menuContainer = document.querySelector('.menu-container');
    if (menuContainer) {
      const settingsBtn = document.createElement('button');
      settingsBtn.className = 'menu-settings-btn';
      settingsBtn.innerHTML = '‚öôÔ∏è Configura√ß√µes';
      settingsBtn.onclick = openSettings;
      menuContainer.appendChild(settingsBtn);
    }
  });

  function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
    color: white;
    padding: 15px 25px;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    z-index: 10000;
    animation: slideIn 0.3s ease;
  `;
    notification.textContent = message;

    document.body.appendChild(notification);

    setTimeout(() => {
      notification.style.animation = 'slideOut 0.3s ease';
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }

  const style = document.createElement('style');
  style.textContent = `
  @keyframes slideIn {
    from { transform: translateX(400px); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  @keyframes slideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(400px); opacity: 0; }
  }
`;
  document.head.appendChild(style);


  document.addEventListener('keydown', (e) => {
    if (e.code === 'Escape' && controls.locked) {
      openSettings();
      document.exitPointerLock();
      controls.locked = false;
    }
  });

  const frustum = new THREE.Frustum();
  const cameraViewProjectionMatrix = new THREE.Matrix4();

  function updateVisibleChunks() {
    const px = camera.position.x;
    const pz = camera.position.z;
    const chunk = worldToChunk(px, pz);

    // Atualizar frustum
    camera.updateMatrixWorld();
    cameraViewProjectionMatrix.multiplyMatrices(
            camera.projectionMatrix,
            camera.matrixWorldInverse
    );
    frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);

    // Calcular prioridades de chunks
    const chunkPriorities = [];

    for (let cx = chunk.x - RENDER_DISTANCE; cx <= chunk.x + RENDER_DISTANCE; cx++) {
      for (let cz = chunk.z - RENDER_DISTANCE; cz <= chunk.z + RENDER_DISTANCE; cz++) {
        const chunkKey = getChunkKey(cx, cz);

        if (!isChunkInFrustum(cx, cz)) continue;

        const dx = cx - chunk.x;
        const dz = cz - chunk.z;
        const distance = Math.sqrt(dx * dx + dz * dz);

        // Calcular dire√ß√£o da c√¢mera
        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir);

        const chunkDir = new THREE.Vector3(
                cx * CHUNK_SIZE - px,
                0,
                cz * CHUNK_SIZE - pz
        ).normalize();

        const alignment = cameraDir.dot(chunkDir);

        // Prioridade: dist√¢ncia + alinhamento com c√¢mera
        const priority = distance * 10 - alignment * 5;

        chunkPriorities.push({ cx, cz, priority, chunkKey, distance });
      }
    }

    // Ordenar por prioridade
    chunkPriorities.sort((a, b) => a.priority - b.priority);

    // Processar chunks de alta prioridade primeiro
    const chunksToGenerate = [];
    const chunksToMesh = [];

    chunkPriorities.forEach(({ cx, cz, chunkKey, distance }) => {
      if (!chunks[chunkKey]) {
        chunksToGenerate.push([cx, cz, distance]);
      } else if (!chunkMeshes[chunkKey]) {
        // Determinar LOD baseado na dist√¢ncia
        const lodLevel = getLODLevel(distance);
        chunksToMesh.push([cx, cz, lodLevel]);
      } else {
        // Atualizar LOD de chunks existentes
        const currentLOD = chunkMeshes[chunkKey].userData.lodLevel || 0;
        const newLOD = getLODLevel(distance);

        if (currentLOD !== newLOD) {
          buildChunkMeshWithLOD(cx, cz, newLOD);
        }
      }
    });

    // Limitar chunks processados por frame
    const maxChunksPerFrame = 3;

    chunksToGenerate.slice(0, maxChunksPerFrame).forEach(([cx, cz]) => {
      generateChunk(cx, cz);
      spawnAnimals(cx, cz);
      spawnEnemies(cx, cz);
    });

    chunksToMesh.slice(0, maxChunksPerFrame).forEach(([cx, cz, lodLevel]) => {
      buildChunkMeshWithLOD(cx, cz, lodLevel);
    });

    // Remover chunks distantes
    const chunksToRemove = [];
    for (let key in chunkMeshes) {
      const [cx, cz] = key.split(',').map(Number);
      const dx = Math.abs(cx - chunk.x);
      const dz = Math.abs(cz - chunk.z);

      if (dx > RENDER_DISTANCE + 2 || dz > RENDER_DISTANCE + 2) {
        chunksToRemove.push(key);
      }
    }

    chunksToRemove.forEach(key => {
      const [cx, cz] = key.split(',').map(Number);
      scene.remove(chunkMeshes[key]);
      chunkMeshes[key].children.forEach(child => {
        child.geometry.dispose();
      });
      delete chunkMeshes[key];
      removeAnimalsInChunk(cx, cz);
      removeEnemiesInChunk(cx, cz);
    });

    updateFaceCount();
  }

  function isChunkInFrustum(cx, cz) {
    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    // Criar bounding box do chunk
    const chunkBox = new THREE.Box3(
            new THREE.Vector3(sx, 0, sz),
            new THREE.Vector3(sx + CHUNK_SIZE, 50, sz + CHUNK_SIZE)
    );

    return frustum.intersectsBox(chunkBox);
  }

  function animate() {
    requestAnimationFrame(animate);

    const deltaTime = 0.016;

    if (controls.locked && !document.getElementById('inventory-full').classList.contains('open')) {
      updatePlayer();
      updateBreaking();

      if (multiplayer.connected) {
        syncPlayerPosition();
      }

      if (playerCharacter) {
        const isMoving = keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'];
        const isJumping = !player.canJump;
        const isRunning = keys['ShiftLeft'] && isMoving;

        playerCharacter.updateAnimation(deltaTime, isMoving, isJumping, isRunning);

        playerCharacter.setPosition(
                camera.position.x,
                camera.position.y - 2.6,
                camera.position.z
        );
        playerCharacter.setRotation(camera.rotation.y);

        // ‚ú® Atualizar sombras do jogador
        setupPlayerShadows();
      }
    }

    camera.updateMatrixWorld();
    cameraViewProjectionMatrix.multiplyMatrices(
            camera.projectionMatrix,
            camera.matrixWorldInverse
    );
    frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);

    for (let key in chunkMeshes) {
      const [cx, cz] = key.split(',').map(Number);
      const mesh = chunkMeshes[key];

      if (mesh) {
        mesh.visible = isChunkInFrustum(cx, cz);
      }
    }

    // Atualizar sistemas
    if (waterSystem) waterSystem.updateWaves(performance.now() * 0.001);
    if (particleSystem) particleSystem.update();
    updateDayNightCycle(deltaTime);
    updateDynamicLighting();

    // ‚ú® ATUALIZAR SOMBRAS DIN√ÇMICAS
    updateDynamicShadows();
    updateSunShadowPosition();

    updateBreakAnimations();
    updateAnimals();
    updateEnemies();
    updateVillagers();


    renderer.render(scene, camera);

    frames++;
    const now = performance.now();

    if (now - lastFaceUpdate > 2000) {
      updateFaceCount();
      lastFaceUpdate = now;
    }

    if (now >= lastTime + 1000) {
      const fps = Math.round(frames * 1000 / (now - lastTime));
      document.getElementById('fps').textContent = fps;
      document.getElementById('fps').className = fps >= 50 ? 'performance-good' : fps >= 30 ? 'performance-ok' : 'performance-bad';

      document.getElementById('pos').textContent =
              `${Math.floor(camera.position.x)}, ${Math.floor(camera.position.y)}, ${Math.floor(camera.position.z)}`;
      document.getElementById('chunks').textContent = Object.keys(chunks).length;
      document.getElementById('total').textContent = Object.keys(worldData).length;
      document.getElementById('animals-count').textContent = `${animals.length} | I:${enemies.length} | A:${villagers.length}`;

      frames = 0;
      lastTime = now;
    }
  }

  function openMultiplayerMenu() {
    document.getElementById('multiplayer-menu').classList.add('open');
    updateMultiplayerMenuStatus();
  }

  function closeMultiplayerMenu() {
    document.getElementById('multiplayer-menu').classList.remove('open');
  }

  function toggleMultiplayerConnection() {
    if (multiplayer.connected) {
      disconnectMultiplayer();
    } else {
      const serverUrl = document.getElementById('mp-server-url').value;
      const playerName = document.getElementById('mp-player-name').value;

      multiplayer.serverUrl = serverUrl;
      multiplayer.enabled = true;

      connectMultiplayer();

      if (playerName) {
        setTimeout(() => {
          sendMultiplayerMessage({
            type: 'set_name',
            name: playerName
          });
        }, 1000);
      }
    }

    updateMultiplayerMenuStatus();
  }

  function updateMultiplayerMenuStatus() {
    const btn = document.getElementById('mp-connect-btn');
    const status = document.getElementById('mp-connection-status');
    const indicator = document.getElementById('mp-indicator');

    if (multiplayer.connected) {
      btn.textContent = 'Desconectar';
      btn.classList.remove('danger');
      status.textContent = 'Conectado ao servidor';
      indicator.className = 'mp-status-indicator online';
      document.getElementById('multiplayer-status').classList.remove('hidden');
    } else {
      btn.textContent = 'Conectar';
      btn.classList.add('mp-button');
      status.textContent = 'N√£o conectado';
      indicator.className = 'mp-status-indicator offline';
      document.getElementById('multiplayer-status').classList.add('hidden');
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const menuContainer = document.querySelector('.menu-container');
    if (menuContainer) {
      const mpBtn = document.createElement('button');
      mpBtn.className = 'start-button';
      mpBtn.style.background = 'linear-gradient(135deg, #2196F3, #1565C0)';
      mpBtn.innerHTML = 'üåê MULTIPLAYER';
      mpBtn.onclick = openMultiplayerMenu;

      const startBtn = document.querySelector('.start-button');
      if (startBtn) {
        startBtn.parentNode.insertBefore(mpBtn, startBtn.nextSibling);
      }
    }
  });

  function perlinNoise(x, y) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    x -= Math.floor(x);
    y -= Math.floor(y);
    const u = fade(x);
    const v = fade(y);
    const hash = (X * 57 + Y * 113) % 256;
    return lerp(v, lerp(u, grad(hash, x, y), grad(hash + 1, x - 1, y)),
            lerp(u, grad(hash + 1, x, y - 1), grad(hash + 2, x - 1, y - 1)));
  }

  function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
  function lerp(t, a, b) { return a + t * (b - a); }
  function grad(hash, x, y) {
    const h = hash & 3;
    return ((h & 1) === 0 ? x : -x) + ((h & 2) === 0 ? y : -y);
  }

  function createEnhancedGrassTexture(ctx, size) {
    // 1. Fundo com gradiente natural (topo mais claro, base mais escura)
    const gradient = ctx.createLinearGradient(0, 0, 0, size);
    gradient.addColorStop(0, '#A0FF60');    // verde claro no topo
    gradient.addColorStop(0.5, '#78C040');
    gradient.addColorStop(1, '#4A8F20');    // verde escuro na base
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // 2. Camada de varia√ß√£o org√¢nica (ru√≠do leve)
    for (let i = 0; i < size * 8; i++) {  // reduzido para n√£o sobrecarregar
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      const opacity = 0.15 + Math.random() * 0.15;
      ctx.fillStyle = `rgba(${90 + shade}, ${150 + shade}, ${40 + shade}, ${opacity})`;
      const s = 3 + Math.random() * 6;
      ctx.fillRect(x - s/2, y - s/2, s, s);
    }

    // 3. Manchas sutis de terra na parte inferior
    for (let i = 0; i < Math.floor(size / 4); i++) {
      const x = Math.random() * size;
      const y = size * 0.6 + Math.random() * size * 0.4;
      const radius = 5 + Math.random() * 12;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(100, 70, 40, 0.6)');
      grd.addColorStop(1, 'rgba(100, 70, 40, 0)');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // 4. L√¢minas de grama ‚Äì AQUI EST√Å O PRINCIPAL AJUSTE
    const bladeCount = size * 12; // boa densidade sem exagerar
    ctx.lineCap = 'round';

    for (let i = 0; i < bladeCount; i++) {
      const x = Math.random() * size;
      // As l√¢minas nascem mais da parte inferior do tile
      const baseY = size - Math.random() * size * 0.4;
      const height = 8 + Math.random() * 18; // altura maior para destacar
      const width = 1.5 + Math.random() * 1.5; // espessura maior (2‚Äì3 px)
      const sway = (Math.random() - 0.5) * 8; // curvatura lateral

      // Cor base da l√¢mina (varia√ß√µes naturais de verde)
      const r = 40 + Math.random() * 50;
      const g = 120 + Math.random() * 80;
      const b = 20 + Math.random() * 30;

      // Sombra sutil na base (ajuda a dar profundidade)
      ctx.strokeStyle = 'rgba(30, 70, 20, 0.6)';
      ctx.lineWidth = width + 1;
      ctx.beginPath();
      ctx.moveTo(x, baseY);
      ctx.quadraticCurveTo(x + sway * 0.6, baseY - height * 0.7, x + sway, baseY - height);
      ctx.stroke();

      // L√¢mina principal ‚Äì mais clara na ponta, mais escura na base
      const tipLightness = 1.1 + Math.random() * 0.3;
      ctx.strokeStyle = `rgb(${r}, ${Math.min(255, g * tipLightness)}, ${b})`;
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(x, baseY);
      ctx.quadraticCurveTo(x + sway * 0.6, baseY - height * 0.7, x + sway, baseY - height);
      ctx.stroke();
    }

    // 5. Brilhos de orvalho (opcional, mas d√° vida)
    ctx.fillStyle = 'rgba(255, 255, 240, 0.5)';
    for (let i = 0; i < Math.floor(size / 4); i++) {
      const x = Math.random() * size;
      const y = Math.random() * size * 0.7;
      const r = 0.8 + Math.random() * 1.2;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();

      // Reflexo ainda menor para efeito de gota
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();
      ctx.arc(x - r * 0.3, y - r * 0.3, r * 0.4, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(255, 255, 240, 0.5)'; // reset
    }
  }
  function createEnhancedDirtTexture(ctx, size) {
    // Base marrom com gradiente
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, '#8B4513');
    gradient.addColorStop(0.5, '#7A3C0F');
    gradient.addColorStop(1, '#6B350D');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o de terra
    for (let i = 0; i < size * 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 80 - 40;
      const opacity = 0.3 + Math.random() * 0.5;
      ctx.fillStyle = `rgba(${139 + shade}, ${69 + shade}, ${19 + shade}, ${opacity})`;
      const s = 2 + Math.random() * 4;
      ctx.fillRect(x, y, s, s);
    }

    // Pedrinhas e cascalho
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40;
      ctx.fillStyle = `rgba(${100 + shade}, ${100 + shade}, ${100 + shade}, 0.4)`;
      const s = 1 + Math.random() * 3;
      ctx.fillRect(x, y, s, s);
    }

    // Ra√≠zes e material org√¢nico
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = 'rgba(60, 40, 20, 0.5)';
      ctx.lineWidth = 1 + Math.random();
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.random() * 8 - 4, y + Math.random() * 8 - 4);
      ctx.stroke();
    }

    // Manchas √∫midas
    for (let i = 0; i < 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 5;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(50, 30, 10, 0.3)');
      grd.addColorStop(1, 'rgba(50, 30, 10, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }
  }

  function createEnhancedStoneTexture(ctx, size) {
    // Base cinza com gradiente
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, '#888888');
    gradient.addColorStop(0.5, '#787878');
    gradient.addColorStop(1, '#686868');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o de pedra
    for (let i = 0; i < size * 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 100 - 50;
      const opacity = 0.2 + Math.random() * 0.4;
      ctx.fillStyle = `rgba(${128 + shade}, ${128 + shade}, ${128 + shade}, ${opacity})`;
      const s = 2 + Math.random() * 5;
      ctx.fillRect(x, y, s, s);
    }

    // Veios minerais
    for (let i = 0; i < 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = `rgba(${150 + Math.random() * 50}, ${150 + Math.random() * 50}, ${150 + Math.random() * 50}, 0.4)`;
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      for (let j = 0; j < 3 + Math.random() * 3; j++) {
        ctx.lineTo(x + Math.random() * 15 - 7.5, y + Math.random() * 15 - 7.5);
      }
      ctx.stroke();
    }

    // Rachaduras
    for (let i = 0; i < 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = 'rgba(40, 40, 40, 0.4)';
      ctx.lineWidth = 0.5 + Math.random();
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.random() * 10 - 5, y + Math.random() * 10 - 5);
      ctx.stroke();
    }

    // Cristais pequenos
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = `rgba(200, 200, 200, ${0.2 + Math.random() * 0.3})`;
      ctx.fillRect(x, y, 1, 1);
    }
  }

  function createEnhancedWoodTexture(ctx, size) {
    // Base madeira
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, size, size);

    // An√©is de crescimento com mais detalhe
    const centerX = size / 2;
    const centerY = size / 2;
    const maxRadius = size * 0.8;
    for (let r = 3; r < maxRadius; r += 2 + Math.random() * 3) {
      const thickness = 1 + Math.random() * 2;
      const shade = Math.random() * 50 - 25;
      const opacity = 0.2 + Math.random() * 0.4;
      ctx.strokeStyle = `rgba(${80 + shade}, ${50 + shade}, ${20 + shade}, ${opacity})`;
      ctx.lineWidth = thickness;
      ctx.beginPath();
      // Anel irregular
      for (let angle = 0; angle <= Math.PI * 2; angle += 0.1) {
        const variation = Math.sin(angle * 8) * 2 + Math.random() * 2;
        const radius = r + variation;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        if (angle === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      ctx.stroke();
    }

    // Veios verticais
    for (let i = 0; i < 40; i++) {
      const x = Math.random() * size;
      ctx.strokeStyle = `rgba(70, 45, 15, ${0.1 + Math.random() * 0.2})`;
      ctx.lineWidth = 0.5 + Math.random();
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x + Math.random() * 4 - 2, size);
      ctx.stroke();
    }

    // N√≥s da madeira
    for (let i = 0; i < 3; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 6;
      for (let r = 0; r < radius; r += 1) {
        const shade = Math.random() * 30 - 15;
        ctx.strokeStyle = `rgba(${50 + shade}, ${30 + shade}, ${10 + shade}, 0.3)`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
  }

  function createEnhancedLeavesTexture(ctx, size) {
    // Base verde escuro
    ctx.fillStyle = '#228B22';
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o de folhas
    for (let i = 0; i < size * 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 80 - 40;
      const opacity = 0.3 + Math.random() * 0.5;
      ctx.fillStyle = `rgba(${34 + shade}, ${139 + shade}, ${34 + shade}, ${opacity})`;
      const s = 2 + Math.random() * 4;
      ctx.fillRect(x, y, s, s);
    }

    // Folhas individuais detalhadas
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const size_leaf = 2 + Math.random() * 3;
      const shade = Math.random() * 60 - 30;
      ctx.fillStyle = `rgba(${50 + shade}, ${200 + shade}, ${50 + shade}, ${0.4 + Math.random() * 0.3})`;
      ctx.beginPath();
      // Forma de folha
      ctx.ellipse(x, y, size_leaf, size_leaf * 1.5, Math.random() * Math.PI * 2, 0, Math.PI * 2);
      ctx.fill();
    }

    // Veias das folhas
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = `rgba(20, 100, 20, ${0.2 + Math.random() * 0.2})`;
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.random() * 4 - 2, y + 3 + Math.random() * 2);
      ctx.stroke();
    }

    // √Åreas de luz (onde o sol passa)
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(150, 255, 100, 0.3)');
      grd.addColorStop(1, 'rgba(150, 255, 100, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Buracos/transpar√™ncia
    for (let i = 0; i < 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.fillRect(x, y, 3, 3);
    }
  }

  function createEnhancedSandTexture(ctx, size) {
    // Base areia com gradiente
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, '#F4A460');
    gradient.addColorStop(0.5, '#E39450');
    gradient.addColorStop(1, '#D28440');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - gr√£os de areia
    for (let i = 0; i < size * 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60 - 30;
      const opacity = 0.3 + Math.random() * 0.4;
      ctx.fillStyle = `rgba(${244 + shade}, ${164 + shade}, ${96 + shade}, ${opacity})`;
      ctx.fillRect(x, y, 1, 1);
    }

    // Segunda camada - gr√£os maiores
    for (let i = 0; i < size * 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgba(${240 + shade}, ${160 + shade}, ${90 + shade}, 0.5)`;
      ctx.fillRect(x, y, 2, 2);
    }

    // Manchas mais escuras
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(200, 140, 80, 0.3)');
      grd.addColorStop(1, 'rgba(200, 140, 80, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Brilhos
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(255, 220, 180, 0.4)';
      ctx.fillRect(x, y, 1, 1);
    }
  }

  function createEnhancedWaterTexture(ctx, size) {
    // Base azul com gradiente
    const gradient = ctx.createLinearGradient(0, 0, 0, size);
    gradient.addColorStop(0, '#1E90FF');
    gradient.addColorStop(0.5, '#1873CC');
    gradient.addColorStop(1, '#1565C0');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Ondas (m√∫ltiplas camadas)
    for (let layer = 0; layer < 3; layer++) {
      const amplitude = 4 - layer;
      const frequency = 0.15 + layer * 0.05;
      const yOffset = layer * size / 3;
      for (let y = 0; y < size / 3; y += 2) {
        ctx.strokeStyle = `rgba(${100 + layer * 20}, ${149 + layer * 20}, ${237 + layer * 20}, ${0.3 - layer * 0.1})`;
        ctx.lineWidth = 1 + layer * 0.5;
        ctx.beginPath();
        for (let x = 0; x < size; x += 2) {
          const wave = Math.sin(x * frequency + y * 0.1) * amplitude;
          const wavY = yOffset + y + wave;
          if (x === 0) {
            ctx.moveTo(x, wavY);
          } else {
            ctx.lineTo(x, wavY);
          }
        }
        ctx.stroke();
      }
    }

    // Reflexos de luz (c√°usticos)
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 5;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(173, 216, 230, 0.5)');
      grd.addColorStop(0.5, 'rgba(173, 216, 230, 0.2)');
      grd.addColorStop(1, 'rgba(173, 216, 230, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Espuma/bolhas
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 1 + Math.random() * 2;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function createEnhancedCobblestoneTexture(ctx, size) {
    // Base cinza escuro
    ctx.fillStyle = '#6B6B6B';
    ctx.fillRect(0, 0, size, size);

    // Pedras individuais com mais detalhe
    const stones = 20;
    const stoneSize = size / 5;
    for (let i = 0; i < stones; i++) {
      const col = i % 5;
      const row = Math.floor(i / 5);
      const x = col * stoneSize + Math.random() * 6 - 3;
      const y = row * stoneSize + Math.random() * 6 - 3;
      const w = stoneSize - Math.random() * 8;
      const h = stoneSize - Math.random() * 8;

      // Base da pedra com gradiente
      const shade = Math.random() * 50 - 25;
      const grd = ctx.createLinearGradient(x, y, x + w, y + h);
      grd.addColorStop(0, `rgb(${107 + shade}, ${107 + shade}, ${107 + shade})`);
      grd.addColorStop(1, `rgb(${87 + shade}, ${87 + shade}, ${87 + shade})`);
      ctx.fillStyle = grd;
      ctx.fillRect(x, y, w, h);

      // Textura interna da pedra
      for (let j = 0; j < 10; j++) {
        const px = x + Math.random() * w;
        const py = y + Math.random() * h;
        const pshade = Math.random() * 40 - 20;
        ctx.fillStyle = `rgba(${107 + pshade}, ${107 + pshade}, ${107 + pshade}, 0.5)`;
        ctx.fillRect(px, py, 2, 2);
      }

      // Contorno da pedra
      ctx.strokeStyle = 'rgba(40, 40, 40, 0.6)';
      ctx.lineWidth = 1 + Math.random();
      ctx.strokeRect(x, y, w, h);

      // Destaque (luz)
      ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + w * 0.3, y);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y + h * 0.3);
      ctx.stroke();
    }

    // Argamassa entre as pedras
    ctx.fillStyle = 'rgba(80, 80, 80, 0.5)';
    for (let i = 1; i < 5; i++) {
      ctx.fillRect(i * stoneSize - 2, 0, 4, size);
      ctx.fillRect(0, i * stoneSize - 2, size, 4);
    }
  }

  function createEnhancedPlanksTexture(ctx, size) {
    // Base madeira clara
    ctx.fillStyle = '#C19A6B';
    ctx.fillRect(0, 0, size, size);

    // T√°buas horizontais com detalhe
    const plankHeight = size / 5;
    for (let i = 0; i < 5; i++) {
      const y = i * plankHeight;
      const shade = Math.random() * 40 - 20;

      // Gradiente na t√°bua
      const grd = ctx.createLinearGradient(0, y, 0, y + plankHeight);
      grd.addColorStop(0, `rgb(${193 + shade}, ${154 + shade}, ${107 + shade})`);
      grd.addColorStop(0.5, `rgb(${183 + shade}, ${144 + shade}, ${97 + shade})`);
      grd.addColorStop(1, `rgb(${193 + shade}, ${154 + shade}, ${107 + shade})`);
      ctx.fillStyle = grd;
      ctx.fillRect(0, y, size, plankHeight - 3);

      // Veios da madeira
      for (let j = 0; j < 30; j++) {
        const x = Math.random() * size;
        const vshade = Math.random() * 30 - 15;
        ctx.strokeStyle = `rgba(${140 + vshade}, ${100 + vshade}, ${60 + vshade}, ${0.15 + Math.random() * 0.2})`;
        ctx.lineWidth = 0.5 + Math.random() * 0.5;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.random() * 4 - 2, y + plankHeight - 3);
        ctx.stroke();
      }

      // N√≥s da madeira
      if (Math.random() > 0.6) {
        const kx = Math.random() * size;
        const ky = y + Math.random() * (plankHeight - 3);
        const kr = 2 + Math.random() * 4;
        for (let r = 0; r < kr; r++) {
          ctx.strokeStyle = `rgba(100, 70, 40, ${0.3 - r * 0.05})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(kx, ky, r, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      // Linha entre t√°buas
      ctx.fillStyle = 'rgba(80, 60, 40, 0.6)';
      ctx.fillRect(0, y + plankHeight - 3, size, 3);

      // Detalhe de sombra na linha
      ctx.fillStyle = 'rgba(60, 40, 20, 0.4)';
      ctx.fillRect(0, y + plankHeight - 3, size, 1);
    }

    // Pregos decorativos
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
      ctx.beginPath();
      ctx.arc(x, y, 1, 0, Math.PI * 2);
      ctx.fill();

      // Brilho do prego
      ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
      ctx.fillRect(x - 0.5, y - 1, 1, 0.5);
    }
  }

  function createEnhancedBrickTexture(ctx, size) {
    // Base tijolo
    ctx.fillStyle = '#B22222';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de tijolos detalhado
    const brickW = size / 5;
    const brickH = size / 10;
    for (let row = 0; row < 10; row++) {
      const offset = (row % 2) * (brickW / 2);
      for (let col = 0; col < 6; col++) {
        const x = col * brickW + offset;
        const y = row * brickH;
        if (x < size && y < size) {
          // Base do tijolo com gradiente
          const shade = Math.random() * 50 - 25;
          const grd = ctx.createLinearGradient(x, y, x + brickW, y + brickH);
          grd.addColorStop(0, `rgb(${178 + shade}, ${34 + shade}, ${34 + shade})`);
          grd.addColorStop(1, `rgb(${158 + shade}, ${24 + shade}, ${24 + shade})`);
          ctx.fillStyle = grd;
          ctx.fillRect(x + 1, y + 1, brickW - 3, brickH - 3);

          // Textura do tijolo
          for (let i = 0; i < 8; i++) {
            const bx = x + 1 + Math.random() * (brickW - 3);
            const by = y + 1 + Math.random() * (brickH - 3);
            const bshade = Math.random() * 40 - 20;
            ctx.fillStyle = `rgba(${178 + bshade}, ${34 + bshade}, ${34 + bshade}, 0.4)`;
            ctx.fillRect(bx, by, 2, 2);
          }

          // Destaque (luz)
          ctx.strokeStyle = 'rgba(220, 80, 80, 0.3)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + 1, y + 1);
          ctx.lineTo(x + brickW - 3, y + 1);
          ctx.moveTo(x + 1, y + 1);
          ctx.lineTo(x + 1, y + brickH - 3);
          ctx.stroke();

          // Sombra
          ctx.strokeStyle = 'rgba(100, 20, 20, 0.4)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + brickW - 2, y + 1);
          ctx.lineTo(x + brickW - 2, y + brickH - 2);
          ctx.lineTo(x + 1, y + brickH - 2);
          ctx.stroke();
        }
      }
    }

    // Argamassa
    ctx.fillStyle = '#CCCCCC';
    for (let row = 0; row < 10; row++) {
      ctx.fillRect(0, row * brickH - 1, size, 2);
    }
    for (let col = 0; col < 6; col++) {
      for (let row = 0; row < 10; row++) {
        const offset = (row % 2) * (brickW / 2);
        const x = col * brickW + offset;
        ctx.fillRect(x - 1, 0, 2, size);
      }
    }
  }

  function createEnhancedBedrockTexture(ctx, size) {
    // Base muito escura
    ctx.fillStyle = '#1C1C1C';
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o escura
    for (let i = 0; i < size * 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      const opacity = 0.3 + Math.random() * 0.4;
      ctx.fillStyle = `rgba(${28 + shade}, ${28 + shade}, ${28 + shade}, ${opacity})`;
      const s = 2 + Math.random() * 5;
      ctx.fillRect(x, y, s, s);
    }

    // Manchas muito escuras (quase pretas)
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 6;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
      grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Cristais escuros
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60;
      ctx.fillStyle = `rgba(${28 + shade}, ${28 + shade}, ${46 + shade}, 0.5)`;
      ctx.fillRect(x, y, 3, 3);
    }

    // Rachaduras profundas
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      for (let j = 0; j < 2 + Math.random() * 3; j++) {
        ctx.lineTo(x + Math.random() * 15 - 7.5, y + Math.random() * 15 - 7.5);
      }
      ctx.stroke();
    }

    // Brilhos m√≠sticos (roxos escuros)
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(100, 50, 150, 0.3)');
      grd.addColorStop(1, 'rgba(100, 50, 150, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }
  }


  // Fun√ß√£o createTexture corrigida
  function createTexture(type, size = 64) {
    if (textureCache[type]) return textureCache[type];

    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // Preencher com cor padr√£o baseada no tipo
    const block = blockTypes[type];
    if (block) {
      const color = block.color;
      const r = (color >> 16) & 255;
      const g = (color >> 8) & 255;
      const b = color & 255;

      // Base s√≥lida
      ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
      ctx.fillRect(0, 0, size, size);

      // Adicionar algum ru√≠do para textura
      for (let i = 0; i < size * 4; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const shade = Math.random() * 40 - 20;
        ctx.fillStyle = `rgb(${r + shade}, ${g + shade}, ${b + shade})`;
        ctx.fillRect(x, y, 2, 2);
      }

      // Para blocos emissivos, adicionar brilho
      if (block.emissive) {
        const gradient = ctx.createRadialGradient(
                size/2, size/2, 0,
                size/2, size/2, size/2
        );
        gradient.addColorStop(0, `rgba(255, 255, 200, 0.4)`);
        gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
      }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    textureCache[type] = texture;
    return texture;
  }

  function createEnhancedTexture(type, size = 64) {
    if (textureCache[type]) return textureCache[type];

    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // Chama as fun√ß√µes espec√≠ficas para cada tipo
    switch(type) {
      case 'grass':
        createEnhancedGrassTexture(ctx, size);
        break;
      case 'dirt':
        createEnhancedDirtTexture(ctx, size);
        break;
      case 'stone':
        createEnhancedStoneTexture(ctx, size);
        break;
      case 'wood':
        createEnhancedWoodTexture(ctx, size);
        break;
      case 'leaves':
        createEnhancedLeavesTexture(ctx, size);
        break;
      case 'sand':
        createEnhancedSandTexture(ctx, size);
        break;
      case 'water':
        createEnhancedWaterTexture(ctx, size);
        break;
      case 'glass':
        createEnhancedGlassTexture(ctx, size);
        break;
      case 'cobblestone':
        createEnhancedCobblestoneTexture(ctx, size);
        break;
      case 'planks':
        createEnhancedPlanksTexture(ctx, size);
        break;
      case 'brick':
        createEnhancedBrickTexture(ctx, size);
        break;
      case 'bedrock':
        createEnhancedBedrockTexture(ctx, size);
        break;
      default:
        // Para outros tipos, use a fun√ß√£o createTexture padr√£o
        return createTexture(type, size);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    textureCache[type] = texture;
    return texture;
  }







  async function createMaterialsWithEmissive() {
    for (let type in blockTypes) {
      const block = blockTypes[type];

      let texture;

      // Escolher a textura baseada no tipo de bloco
      if (type === 'grass') {
        texture = createGrassSideTexture(64);
      } else if (type === 'wood') {
        texture = createWoodSideTexture(64);
      } else if (type === 'bookshelf') {
        texture = createBookshelfTexture(64);
      } else if (type === 'furnace') {
        texture = createFurnaceSideTexture(64);
      } else if (type === 'water') {
        texture = createWaterTexture(64);
      } else if (type === 'leaves') {
        texture = createLeavesTexture(64);
      } else if (type === 'glass') {
        texture = createEnhancedGlassTexture(64);
      } else if (type === 'ice') {
        texture = createSimpleTexture(type, 64);
      } else {
        // Para outros blocos, use a textura gen√©rica
        texture = createBlockTexture(type, 64);
      }

      // Criar material baseado no tipo de bloco
      if (block.emissive) {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          emissive: block.color,
          emissiveIntensity: 0.8
        });
      } else if (type === 'glass' || type === 'ice') {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });
      } else if (type === 'water') {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
      } else if (type === 'leaves') {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,
          opacity: 0.9,
          side: THREE.DoubleSide,
          alphaTest: 0.5
        });
      } else {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture
        });
      }
    }
  }

  // Fun√ß√µes de cria√ß√£o de texturas espec√≠ficas (mantenha as mesmas fun√ß√µes)
  function createGrassTopTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // Fundo verde grama
    ctx.fillStyle = '#7CFC00';
    ctx.fillRect(0, 0, size, size);

    // Adicionar detalhes de grama
    for (let i = 0; i < 100; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgb(${124 + shade}, ${252 + shade}, ${0 + shade})`;
      ctx.fillRect(x, y, 2, 2);
    }

    // Pontos de grama mais escuros
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = '#5CB800';
      ctx.fillRect(x, y, 1, 1);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createGrassSideTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // Gradiente de terra para grama
    const gradient = ctx.createLinearGradient(0, 0, 0, size);
    gradient.addColorStop(0, '#7CFC00'); // Grama no topo
    gradient.addColorStop(0.3, '#8B4513'); // Transi√ß√£o
    gradient.addColorStop(1, '#7A3C0F'); // Terra na base

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Adicionar detalhes de terra
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * size;
      const y = size * 0.3 + Math.random() * size * 0.7;
      const shade = Math.random() * 30 - 15;
      ctx.fillStyle = `rgb(${139 + shade}, ${69 + shade}, ${19 + shade})`;
      ctx.fillRect(x, y, 2, 2);
    }

    // Pontos de grama no topo
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size * 0.3;
      ctx.fillStyle = '#90EE90';
      ctx.fillRect(x, y, 1, 1);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createDirtTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#8B4513';
    ctx.fillRect(0, 0, size, size);

    // Adicionar varia√ß√µes de cor
    for (let i = 0; i < 200; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 50 - 25;
      ctx.fillStyle = `rgb(${139 + shade}, ${69 + shade}, ${19 + shade})`;
      ctx.fillRect(x, y, 2, 2);
    }

    // Pedrinhas
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = '#A0522D';
      ctx.fillRect(x, y, 1, 1);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createStoneTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#808080';
    ctx.fillRect(0, 0, size, size);

    // Adicionar varia√ß√µes de cinza
    for (let i = 0; i < 300; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 80 - 40;
      ctx.fillStyle = `rgb(${128 + shade}, ${128 + shade}, ${128 + shade})`;
      ctx.fillRect(x, y, 2, 2);
    }

    // Veios minerais
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = '#A0A0A0';
      ctx.fillRect(x, y, 3, 1);
      ctx.fillRect(x, y + 1, 1, 3);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createWoodTopTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#8B5A2B';
    ctx.fillRect(0, 0, size, size);

    // An√©is de crescimento
    const centerX = size / 2;
    const centerY = size / 2;

    for (let i = 0; i < 5; i++) {
      const radius = (i + 1) * 5;
      ctx.strokeStyle = `rgb(${101 + i * 5}, ${67 + i * 5}, ${33 + i * 5})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.stroke();
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createWoodSideTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, size, size);

    // Veios da madeira
    for (let i = 0; i < 20; i++) {
      const x = i * (size / 20);
      const shade = Math.random() * 20 - 10;
      ctx.fillStyle = `rgb(${101 + shade}, ${67 + shade}, ${33 + shade})`;
      ctx.fillRect(x, 0, 2, size);
    }

    // N√≥s da madeira
    for (let i = 0; i < 3; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = '#8B4513';
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createPlanksTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#C19A6B';
    ctx.fillRect(0, 0, size, size);

    // Linhas das t√°buas
    for (let i = 0; i < 5; i++) {
      const y = i * (size / 5);
      const shade = Math.random() * 20 - 10;
      ctx.fillStyle = `rgb(${193 + shade}, ${154 + shade}, ${107 + shade})`;
      ctx.fillRect(0, y, size, 3);

      // Textura dentro da t√°bua
      for (let j = 0; j < 10; j++) {
        const x = Math.random() * size;
        const lineShade = Math.random() * 30 - 15;
        ctx.fillStyle = `rgb(${180 + lineShade}, ${140 + lineShade}, ${90 + lineShade})`;
        ctx.fillRect(x, y + 4, 1, (size / 5) - 8);
      }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createCobblestoneTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#6B6B6B';
    ctx.fillRect(0, 0, size, size);

    // Pedras individuais
    const stoneSize = size / 4;
    for (let row = 0; row < 4; row++) {
      for (let col = 0; col < 4; col++) {
        const x = col * stoneSize + Math.random() * 4;
        const y = row * stoneSize + Math.random() * 4;
        const w = stoneSize - Math.random() * 6;
        const h = stoneSize - Math.random() * 6;

        const shade = Math.random() * 40 - 20;
        ctx.fillStyle = `rgb(${107 + shade}, ${107 + shade}, ${107 + shade})`;
        ctx.fillRect(x, y, w, h);

        // Contorno
        ctx.strokeStyle = '#4A4A4A';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, w, h);
      }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createBrickTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#B22222';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de tijolos
    const brickWidth = size / 4;
    const brickHeight = size / 8;

    for (let row = 0; row < 8; row++) {
      const offset = (row % 2) ? brickWidth / 2 : 0;
      for (let col = 0; col < 5; col++) {
        const x = col * brickWidth + offset;
        const y = row * brickHeight;

        const shade = Math.random() * 30 - 15;
        ctx.fillStyle = `rgb(${178 + shade}, ${34 + shade}, ${34 + shade})`;
        ctx.fillRect(x + 1, y + 1, brickWidth - 2, brickHeight - 2);

        // Argamassa
        ctx.fillStyle = '#CCCCCC';
        if (col === 0 || offset === 0) {
          ctx.fillRect(x, y, 1, brickHeight);
        }
        if (row === 0) {
          ctx.fillRect(x, y, brickWidth, 1);
        }
      }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createSandTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#F4A460';
    ctx.fillRect(0, 0, size, size);

    // Gr√£os de areia
    for (let i = 0; i < 400; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      const grainSize = Math.random() > 0.8 ? 2 : 1;
      ctx.fillStyle = `rgb(${244 + shade}, ${164 + shade}, ${96 + shade})`;
      ctx.fillRect(x, y, grainSize, grainSize);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createBookshelfTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // Fundo de madeira
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, size, size);

    // Livros coloridos
    const bookWidth = size / 8;
    for (let i = 0; i < 8; i++) {
      const x = i * bookWidth;
      const colors = ['#FF4444', '#4444FF', '#44FF44', '#FFFF44', '#FF44FF', '#44FFFF'];
      const color = colors[Math.floor(Math.random() * colors.length)];

      ctx.fillStyle = color;
      ctx.fillRect(x + 1, 2, bookWidth - 2, size - 4);

      // Lombada do livro
      ctx.fillStyle = '#222222';
      ctx.fillRect(x + bookWidth - 3, 2, 1, size - 4);

      // T√≠tulo do livro (linhas)
      for (let j = 0; j < 3; j++) {
        const lineY = 5 + j * 5;
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(x + 3, lineY, bookWidth - 8, 1);
      }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createFurnaceSideTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#696969';
    ctx.fillRect(0, 0, size, size);

    // Grade da fornalha
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        const x = i * (size / 4);
        const y = j * (size / 4);

        ctx.fillStyle = '#555555';
        ctx.fillRect(x + 2, y + 2, (size / 4) - 4, (size / 4) - 4);

        // Detalhes
        ctx.fillStyle = '#333333';
        ctx.fillRect(x + 4, y + 4, (size / 4) - 8, (size / 4) - 8);
      }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createFurnaceTopTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#808080';
    ctx.fillRect(0, 0, size, size);

    // Abertura da fornalha
    ctx.fillStyle = '#222222';
    const holeSize = size / 2;
    const holeX = (size - holeSize) / 2;
    const holeY = (size - holeSize) / 2;
    ctx.fillRect(holeX, holeY, holeSize, holeSize);

    // Grades
    for (let i = 0; i < 3; i++) {
      ctx.fillStyle = '#444444';
      ctx.fillRect(holeX, holeY + i * (holeSize / 3), holeSize, 1);
      ctx.fillRect(holeX + i * (holeSize / 3), holeY, 1, holeSize);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createLeavesTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#228B22';
    ctx.fillRect(0, 0, size, size);

    // Detalhes de folhas
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgb(${34 + shade}, ${139 + shade}, ${34 + shade})`;

      // Forma de folha
      ctx.beginPath();
      ctx.ellipse(x, y, 3, 2, Math.random() * Math.PI, 0, Math.PI * 2);
      ctx.fill();
    }

    // Buracos nas folhas
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = '#1A6B1A';
      ctx.beginPath();
      ctx.arc(x, y, 1, 0, Math.PI * 2);
      ctx.fill();
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createWaterTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // Gradiente azul
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, '#1E90FF');
    gradient.addColorStop(0.5, '#1873CC');
    gradient.addColorStop(1, '#1565C0');

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Ondas
    for (let i = 0; i < 20; i++) {
      const y = i * (size / 20);
      ctx.strokeStyle = 'rgba(173, 216, 230, 0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = 0; x < size; x += 5) {
        const wave = Math.sin(x * 0.1 + y * 0.05) * 2;
        ctx.lineTo(x, y + wave);
      }
      ctx.stroke();
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createBlockTexture(type, size) {
    // Textura gen√©rica baseada no tipo de bloco
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    const block = blockTypes[type];
    if (!block) return createSimpleTexture(type, size);

    const baseColor = block.color || block.topColor || block.sideColor || 0xFFFFFF;
    const r = (baseColor >> 16) & 255;
    const g = (baseColor >> 8) & 255;
    const b = baseColor & 255;

    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    ctx.fillRect(0, 0, size, size);

    // Adicionar textura baseada no tipo
    if (type.includes('ore')) {
      // Textura de min√©rio
      for (let i = 0; i < 30; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const shade = Math.random() * 60 - 30;
        ctx.fillStyle = `rgb(${r + shade}, ${g + shade}, ${b + shade})`;
        ctx.fillRect(x, y, 3, 3);
      }

      // Pontos brilhantes (minerais)
      for (let i = 0; i < 10; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        ctx.fillStyle = type === 'gold_ore' ? '#FFD700' :
                type === 'diamond_ore' ? '#00FFFF' :
                        type === 'emerald_ore' ? '#00FF00' :
                                type === 'coal_ore' ? '#000000' :
                                        '#FFFFFF';
        ctx.fillRect(x, y, 2, 2);
      }
    } else if (type.includes('concrete')) {
      // Textura de concreto
      for (let i = 0; i < 100; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const shade = Math.random() * 20 - 10;
        ctx.fillStyle = `rgb(${r + shade}, ${g + shade}, ${b + shade})`;
        ctx.fillRect(x, y, 1, 1);
      }
    } else {
      // Textura padr√£o
      for (let i = 0; i < 150; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const shade = Math.random() * 40 - 20;
        ctx.fillStyle = `rgb(${r + shade}, ${g + shade}, ${b + shade})`;
        ctx.fillRect(x, y, 2, 2);
      }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createSimpleTexture(type, size) {
    // Textura simples para blocos sem textura complexa
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    const block = blockTypes[type];
    if (!block) {
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, size, size);
    } else {
      const baseColor = block.color || block.topColor || block.sideColor || 0xFFFFFF;
      const r = (baseColor >> 16) & 255;
      const g = (baseColor >> 8) & 255;
      const b = baseColor & 255;

      ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
      ctx.fillRect(0, 0, size, size);

      // Adicionar algum ru√≠do
      for (let i = 0; i < 50; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const shade = Math.random() * 30 - 15;
        ctx.fillStyle = `rgb(${r + shade}, ${g + shade}, ${b + shade})`;
        ctx.fillRect(x, y, 2, 2);
      }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  function createEnhancedGlassTexture(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // Base transparente azulada
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, 'rgba(173, 216, 230, 0.3)');
    gradient.addColorStop(0.5, 'rgba(173, 216, 230, 0.2)');
    gradient.addColorStop(1, 'rgba(173, 216, 230, 0.3)');

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Reflexos diagonais
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const length = 10 + Math.random() * 20;
      const angle = Math.random() * Math.PI / 4 - Math.PI / 8;
      ctx.strokeStyle = `rgba(255, 255, 255, ${0.2 + Math.random() * 0.3})`;
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
      ctx.stroke();
    }

    // Brilhos pontuais
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
      grd.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Imperfei√ß√µes (bolhas)
    for (let i = 0; i < 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 1 + Math.random() * 2;
      ctx.fillStyle = 'rgba(230, 240, 250, 0.4)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    return texture;
  }

  // CORRE√á√ÉO: Modificar a fun√ß√£o buildChunkMesh para corrigir os erros
  function buildChunkMesh(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);

    if (chunkMeshes[chunkKey]) {
      scene.remove(chunkMeshes[chunkKey]);
      chunkMeshes[chunkKey].children.forEach(child => {
        child.geometry.dispose();
      });
      delete chunkMeshes[chunkKey];
    }

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    const geometriesByType = {};

    for (let type in blockTypes) {
      geometriesByType[type] = {
        positions: [],
        normals: [],
        indices: [],
        uvs: [], // Adicionar UVs para texturas
        vertexCount: 0
      };
    }

    let totalFaces = 0;

    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
      for (let lz = 0; lz < CHUNK_SIZE; lz++) {
        for (let y = 0; y < 40; y++) {
          const x = sx + lx;
          const z = sz + lz;
          const block = getBlock(x, y, z);

          if (!block) continue;

          const geo = geometriesByType[block.type];
          if (!geo) continue; // Pular se n√£o houver geometria para esse tipo

          const faces = [
            { dir: [1, 0, 0], corners: [[1, 0, 0], [1, 1, 0], [1, 1, 1], [1, 0, 1]] },
            { dir: [-1, 0, 0], corners: [[0, 0, 1], [0, 1, 1], [0, 1, 0], [0, 0, 0]] },
            { dir: [0, 1, 0], corners: [[0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 1, 0]] },
            { dir: [0, -1, 0], corners: [[0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 0, 1]] },
            { dir: [0, 0, 1], corners: [[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]] },
            { dir: [0, 0, -1], corners: [[1, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0]] }
          ];

          for (let face of faces) {
            const [dx, dy, dz] = face.dir;
            const neighbor = getBlock(x + dx, y + dy, z + dz);

            if (!neighbor) {
              const baseIdx = geo.vertexCount;

              for (let corner of face.corners) {
                geo.positions.push(
                        x + corner[0] - 0.5,
                        y + corner[1] - 0.5,
                        z + corner[2] - 0.5
                );
                geo.normals.push(dx, dy, dz);

                // Coordenadas UV baseadas na dire√ß√£o da face
                if (dx !== 0) { // Face lateral
                  geo.uvs.push(corner[1], corner[2]);
                } else if (dy !== 0) { // Face topo/fundo
                  geo.uvs.push(corner[0], corner[2]);
                } else { // Face frontal/traseira
                  geo.uvs.push(corner[0], corner[1]);
                }
              }

              geo.indices.push(
                      baseIdx, baseIdx + 1, baseIdx + 2,
                      baseIdx, baseIdx + 2, baseIdx + 3
              );

              geo.vertexCount += 4;
              totalFaces++;
            }
          }
        }
      }
    }

    const group = new THREE.Group();

    for (let type in geometriesByType) {
      const geo = geometriesByType[type];

      if (geo.positions.length === 0) continue;

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(geo.positions, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(geo.normals, 3));
      geometry.setAttribute('uv', new THREE.Float32BufferAttribute(geo.uvs, 2));
      geometry.setIndex(geo.indices);

      // Verificar se o material existe
      if (materials[type]) {
        const mesh = new THREE.Mesh(geometry, materials[type]);
        mesh.userData.chunkKey = chunkKey;
        mesh.userData.type = type;
        group.add(mesh);
      }
    }

    if (group.children.length > 0) {
      scene.add(group);
      chunkMeshes[chunkKey] = group;
      chunkMeshes[chunkKey].userData.faceCount = totalFaces;
    }

    return totalFaces;
  }








  // Fun√ß√µes de ru√≠do melhoradas
  function perlinNoise2D(x, y, frequency = 1, octaves = 4, persistence = 0.5) {
    let value = 0;
    let amplitude = 1;
    let maxValue = 0;

    for (let i = 0; i < octaves; i++) {
      const nx = x * frequency * Math.pow(2, i);
      const ny = y * frequency * Math.pow(2, i);
      value += simpleNoise(nx, ny) * amplitude;
      maxValue += amplitude;
      amplitude *= persistence;
    }

    return value / maxValue;
  }

  function simpleNoise(x, y) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    x -= Math.floor(x);
    y -= Math.floor(y);

    const u = fade(x);
    const v = fade(y);

    // Tabela de permuta√ß√£o
    const p = new Array(512);
    for (let i = 0; i < 256; i++) p[i] = i;
    for (let i = 255; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [p[i], p[j]] = [p[j], p[i]];
    }
    for (let i = 256; i < 512; i++) p[i] = p[i - 256];

    const a = p[X] + Y;
    const aa = p[a & 255];
    const ab = p[(a + 1) & 255];
    const b = p[X + 1] + Y;
    const ba = p[b & 255];
    const bb = p[(b + 1) & 255];

    const grad = (hash, x, y) => {
      const h = hash & 3;
      return ((h & 1) ? -x : x) + ((h & 2) ? -y : y);
    };

    return lerp(v,
            lerp(u, grad(p[aa], x, y), grad(p[ba], x - 1, y)),
            lerp(u, grad(p[ab], x, y - 1), grad(p[bb], x - 1, y - 1))
    );
  }

  function fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  function lerp(t, a, b) {
    return a + t * (b - a);
  }

  // Fun√ß√µes auxiliares seguras para gradientes
  function createSafeLinearGradient(ctx, x0, y0, x1, y1, colorStops) {
    try {
      // Verificar se os valores s√£o finitos
      if (![x0, y0, x1, y1].every(val => Number.isFinite(val))) {
        console.warn('Valores n√£o finitos para gradiente linear:', {x0, y0, x1, y1});
        return colorStops[0]?.color || '#000000';
      }

      const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
      for (const stop of colorStops) {
        if (Number.isFinite(stop.offset)) {
          gradient.addColorStop(stop.offset, stop.color);
        }
      }
      return gradient;
    } catch (error) {
      console.warn('Erro ao criar gradiente linear:', error);
      return colorStops[0]?.color || '#000000';
    }
  }

  function createSafeRadialGradient(ctx, x0, y0, r0, x1, y1, r1, colorStops) {
    try {
      // Verificar se os valores s√£o finitos
      const values = [x0, y0, r0, x1, y1, r1];
      if (!values.every(val => Number.isFinite(val))) {
        console.warn('Valores n√£o finitos para gradiente radial:', {x0, y0, r0, x1, y1, r1});
        return colorStops[0]?.color || '#000000';
      }

      const gradient = ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
      for (const stop of colorStops) {
        if (Number.isFinite(stop.offset)) {
          gradient.addColorStop(stop.offset, stop.color);
        }
      }
      return gradient;
    } catch (error) {
      console.warn('Erro ao criar gradiente radial:', error);
      return colorStops[0]?.color || '#000000';
    }
  }

  // ==================== FUN√á√ïES DE TEXTURA ====================

  // Textura de Grama
  function createEnhancedGrassTexture(ctx, size) {
    // Limpar canvas
    ctx.clearRect(0, 0, size, size);

    // 1. Fundo com gradiente natural (otimizado)
    const gradient = ctx.createLinearGradient(0, 0, 0, size);
    gradient.addColorStop(0, '#8CD800');     // Verde vivo no topo
    gradient.addColorStop(0.4, '#6FAF30');   // Verde m√©dio
    gradient.addColorStop(0.8, '#4A7C20');   // Verde escuro
    gradient.addColorStop(1, '#2C4A10');     // Verde muito escuro na base

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // 2. Textura de terra na base (reduzida para performance)
    for (let i = 0; i < Math.min(size * 3, 150); i++) {
      const x = Math.random() * size;
      // Terra concentrada na parte inferior (√∫ltimos 40%)
      const y = size * 0.6 + Math.random() * size * 0.4;
      const shade = Math.floor(Math.random() * 30) - 15;
      ctx.fillStyle = `rgba(${90 + shade}, ${60 + shade}, ${30 + shade}, 0.4)`;
      const s = 2 + Math.random() * 3;
      ctx.fillRect(x, y, s, s);
    }

    // 3. L√¢minas de grama (sistema otimizado)
    const bladeCount = Math.min(size * 6, 300); // Limitado para performance
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    for (let i = 0; i < bladeCount; i++) {
      const x = Math.random() * size;
      // Base da l√¢mina come√ßa na parte superior do tile
      const baseY = size - Math.random() * size * 0.3;
      const height = 6 + Math.random() * 10; // Altura variada
      const width = 0.8 + Math.random() * 0.8; // Espessura
      const sway = (Math.random() - 0.5) * 6; // Curvatura

      // Cor base da l√¢mina (varia√ß√£o natural)
      const greenBase = 120 + Math.random() * 40;
      const r = Math.floor(40 + Math.random() * 20);
      const g = Math.floor(greenBase);
      const b = Math.floor(20 + Math.random() * 15);

      // Desenhar sombra sutil
      ctx.strokeStyle = `rgba(${r - 20}, ${g - 20}, ${b - 10}, 0.4)`;
      ctx.lineWidth = width + 0.5;
      ctx.beginPath();
      ctx.moveTo(x, baseY);
      const cpX = x + sway * 0.3;
      const cpY = baseY - height * 0.5;
      ctx.quadraticCurveTo(cpX, cpY, x + sway, baseY - height);
      ctx.stroke();

      // L√¢mina principal
      ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(x, baseY);
      ctx.quadraticCurveTo(cpX, cpY, x + sway, baseY - height);
      ctx.stroke();
    }

    // 4. Pontos de brilho/reflexo (otimizado)
    for (let i = 0; i < Math.min(size / 4, 15); i++) {
      const x = Math.random() * size;
      const y = Math.random() * size * 0.6;
      const r = 0.5 + Math.random() * 1;

      ctx.fillStyle = 'rgba(255, 255, 220, 0.6)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    // 5. Detalhes de textura finais
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    // Adicionar leve ru√≠do para textura org√¢nica
    for (let i = 0; i < data.length; i += 16) { // Pulando pixels para performance
      const idx = Math.floor(Math.random() * (data.length / 4)) * 4;
      if (idx + 3 < data.length) {
        const variation = Math.random() * 20 - 10;
        data[idx] = Math.min(255, Math.max(0, data[idx] + variation));
        data[idx + 1] = Math.min(255, Math.max(0, data[idx + 1] + variation * 0.7));
      }
    }

    ctx.putImageData(imageData, 0, 0);
  }

  // ATUALIZAR tamb√©m a fun√ß√£o createTexture para usar a nova grama aprimorada
  function createTexture(type, size = 64) {
    const cacheKey = `${type}_${size}`;
    if (textureCache[cacheKey]) return textureCache[cacheKey];

    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // Para grama, usar a nova fun√ß√£o aprimorada
    if (type === 'grass') {
      createEnhancedGrassTexture(ctx, size);
    } else {
      // Para outros blocos, manter a l√≥gica existente
      const block = blockTypes[type];
      if (block) {
        const color = block.color || 0x808080;
        const r = (color >> 16) & 255;
        const g = (color >> 8) & 255;
        const b = color & 255;

        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.fillRect(0, 0, size, size);

        // Adicionar algum ru√≠do para textura
        for (let i = 0; i < size * 2; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.floor(Math.random() * 40 - 20);
          ctx.fillStyle = `rgb(${r + shade}, ${g + shade}, ${b + shade})`;
          ctx.fillRect(x, y, 2, 2);
        }
      }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    textureCache[cacheKey] = texture;
    return texture;
  }
  // Textura de Terra
  function createEnhancedDirtTexture(ctx, size) {
    if (!ctx || typeof size !== 'number' || size <= 0) return;

    ctx.clearRect(0, 0, size, size);

    // Base com gradiente
    const gradient = createSafeLinearGradient(ctx, 0, 0, 0, size, [
      { offset: 0, color: '#8D6E63' },
      { offset: 0.5, color: '#795548' },
      { offset: 1, color: '#6D4C41' }
    ]);

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Adicionar ru√≠do para varia√ß√£o
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const noise = perlinNoise2D(x / 8, y / 8, 1, 3, 0.6);
        const variation = Math.floor(noise * 40 - 20);

        const idx = (y * size + x) * 4;

        if (data[idx + 3] > 0) { // S√≥ modificar pixels n√£o transparentes
          data[idx] = Math.min(255, Math.max(0, data[idx] + variation));
          data[idx + 1] = Math.min(255, Math.max(0, data[idx + 1] + variation - 5));
          data[idx + 2] = Math.min(255, Math.max(0, data[idx + 2] + variation - 10));
        }
      }
    }

    ctx.putImageData(imageData, 0, 0);

    // Pedras pequenas
    for (let i = 0; i < 40; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.floor(Math.random() * 40 + 100);
      const sizeStone = 1 + Math.random() * 2;
      ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
      ctx.fillRect(x, y, sizeStone, sizeStone);
    }

    // Material org√¢nico (ra√≠zes)
    ctx.strokeStyle = 'rgba(92, 64, 51, 0.4)';
    ctx.lineCap = 'round';
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.lineWidth = 0.5 + Math.random();
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + (Math.random() * 6 - 3), y + (Math.random() * 6 - 3));
      ctx.stroke();
    }
  }

  // Textura de Pedra
  function createEnhancedStoneTexture(ctx, size) {
    if (!ctx || typeof size !== 'number' || size <= 0) return;

    ctx.clearRect(0, 0, size, size);

    // Base com gradiente
    const gradient = createSafeLinearGradient(ctx, 0, 0, size, size, [
      { offset: 0, color: '#888888' },
      { offset: 0.5, color: '#787878' },
      { offset: 1, color: '#686868' }
    ]);

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Varia√ß√£o com ru√≠do
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4) {
      const variation = Math.floor(Math.random() * 50 - 25);
      data[i] = Math.min(255, Math.max(0, data[i] + variation));
      data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + variation));
      data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + variation));
    }

    ctx.putImageData(imageData, 0, 0);

    // Veios minerais
    for (let i = 0; i < 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const mineralColor = 150 + Math.random() * 50;
      ctx.strokeStyle = `rgba(${mineralColor}, ${mineralColor}, ${mineralColor}, 0.4)`;
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      for (let j = 0; j < 3 + Math.random() * 3; j++) {
        ctx.lineTo(x + Math.random() * 15 - 7.5, y + Math.random() * 15 - 7.5);
      }
      ctx.stroke();
    }

    // Rachaduras
    for (let i = 0; i < 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = 'rgba(40, 40, 40, 0.4)';
      ctx.lineWidth = 0.5 + Math.random();
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.random() * 10 - 5, y + Math.random() * 10 - 5);
      ctx.stroke();
    }
  }

  // Textura de Madeira
  function createEnhancedWoodTexture(ctx, size) {
    if (!ctx || typeof size !== 'number' || size <= 0) return;

    ctx.clearRect(0, 0, size, size);

    // Base madeira
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, size, size);

    // An√©is de crescimento
    const centerX = size / 2;
    const centerY = size / 2;
    const maxRadius = size * 0.8;

    for (let r = 3; r < maxRadius; r += 2 + Math.random() * 3) {
      const thickness = 1 + Math.random() * 2;
      const shade = Math.random() * 50 - 25;
      const opacity = 0.2 + Math.random() * 0.4;
      ctx.strokeStyle = `rgba(${80 + shade}, ${50 + shade}, ${20 + shade}, ${opacity})`;
      ctx.lineWidth = thickness;
      ctx.beginPath();

      // Criar anel irregular
      const points = [];
      for (let angle = 0; angle <= Math.PI * 2; angle += 0.1) {
        const variation = Math.sin(angle * 8) * 2 + Math.random() * 2;
        const radius = r + variation;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        points.push({x, y});
      }

      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.closePath();
      ctx.stroke();
    }

    // Veios verticais
    for (let i = 0; i < 40; i++) {
      const x = Math.random() * size;
      ctx.strokeStyle = `rgba(70, 45, 15, ${0.1 + Math.random() * 0.2})`;
      ctx.lineWidth = 0.5 + Math.random();
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x + Math.random() * 4 - 2, size);
      ctx.stroke();
    }
  }

  // Textura de Folhas
  function createEnhancedLeavesTexture(ctx, size) {
    if (!ctx || typeof size !== 'number' || size <= 0) return;

    ctx.clearRect(0, 0, size, size);

    // Base verde
    ctx.fillStyle = '#228B22';
    ctx.fillRect(0, 0, size, size);

    // Varia√ß√£o de cores
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4) {
      const variation = Math.floor(Math.random() * 60 - 30);
      data[i] = Math.min(255, Math.max(0, data[i] + variation));
      data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + variation));
      data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + variation));
    }

    ctx.putImageData(imageData, 0, 0);

    // Folhas individuais
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const sizeLeaf = 2 + Math.random() * 3;
      const angle = Math.random() * Math.PI * 2;
      const shade = Math.random() * 60 - 30;

      ctx.fillStyle = `rgba(${50 + shade}, ${200 + shade}, ${50 + shade}, ${0.4 + Math.random() * 0.3})`;
      ctx.beginPath();
      ctx.ellipse(x, y, sizeLeaf, sizeLeaf * 1.5, angle, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Textura de Vidro
  function createEnhancedGlassTexture(ctx, size) {
    if (!ctx || typeof size !== 'number' || size <= 0) return;

    ctx.clearRect(0, 0, size, size);

    // Base transparente
    const gradient = createSafeLinearGradient(ctx, 0, 0, size, size, [
      { offset: 0, color: 'rgba(173, 216, 230, 0.3)' },
      { offset: 0.5, color: 'rgba(173, 216, 230, 0.2)' },
      { offset: 1, color: 'rgba(173, 216, 230, 0.3)' }
    ]);

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Reflexos
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const length = 10 + Math.random() * 20;
      const angle = Math.random() * Math.PI / 4 - Math.PI / 8;
      ctx.strokeStyle = `rgba(255, 255, 255, ${0.2 + Math.random() * 0.3})`;
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
      ctx.stroke();
    }

    // Brilhos pontuais
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;

      const gradientRadial = createSafeRadialGradient(ctx, x, y, 0, x, y, radius, [
        { offset: 0, color: 'rgba(255, 255, 255, 0.6)' },
        { offset: 0.5, color: 'rgba(255, 255, 255, 0.3)' },
        { offset: 1, color: 'rgba(255, 255, 255, 0)' }
      ]);

      ctx.fillStyle = gradientRadial;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }
  }

  // Textura de √Ågua
  function createEnhancedWaterTexture(ctx, size) {
    if (!ctx || typeof size !== 'number' || size <= 0) return;

    ctx.clearRect(0, 0, size, size);

    // Base azul com gradiente
    const gradient = createSafeLinearGradient(ctx, 0, 0, 0, size, [
      { offset: 0, color: '#1E90FF' },
      { offset: 0.5, color: '#1873CC' },
      { offset: 1, color: '#1565C0' }
    ]);

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Ondas simples
    ctx.strokeStyle = 'rgba(173, 216, 230, 0.2)';
    ctx.lineWidth = 1;

    for (let y = 0; y < size; y += 4) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      for (let x = 0; x < size; x += 5) {
        const wave = Math.sin(x * 0.1 + y * 0.05) * 2;
        ctx.lineTo(x, y + wave);
      }
      ctx.stroke();
    }

    // Reflexos de luz
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;

      const gradientRadial = createSafeRadialGradient(ctx, x, y, 0, x, y, radius, [
        { offset: 0, color: 'rgba(173, 216, 230, 0.5)' },
        { offset: 1, color: 'rgba(173, 216, 230, 0)' }
      ]);

      ctx.fillStyle = gradientRadial;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }
  }

  // Textura de Areia
  function createEnhancedSandTexture(ctx, size) {
    if (!ctx || typeof size !== 'number' || size <= 0) return;

    ctx.clearRect(0, 0, size, size);

    // Base areia
    const gradient = createSafeLinearGradient(ctx, 0, 0, size, size, [
      { offset: 0, color: '#F4A460' },
      { offset: 0.5, color: '#E39450' },
      { offset: 1, color: '#D28440' }
    ]);

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Gr√£os de areia
    for (let i = 0; i < size * 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.floor(Math.random() * 40 - 20);
      ctx.fillStyle = `rgb(${244 + shade}, ${164 + shade}, ${96 + shade})`;
      const grainSize = Math.random() > 0.7 ? 2 : 1;
      ctx.fillRect(x, y, grainSize, grainSize);
    }

    // Gr√£os maiores
    for (let i = 0; i < size * 5; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.floor(Math.random() * 30 - 15);
      ctx.fillStyle = `rgb(${240 + shade}, ${160 + shade}, ${90 + shade})`;
      ctx.fillRect(x, y, 3, 3);
    }
  }

  // Textura de Tijolo
  function createEnhancedBrickTexture(ctx, size) {
    if (!ctx || typeof size !== 'number' || size <= 0) return;

    ctx.clearRect(0, 0, size, size);

    // Base tijolo
    ctx.fillStyle = '#B22222';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de tijolos
    const brickW = size / 5;
    const brickH = size / 10;

    for (let row = 0; row < 10; row++) {
      const offset = (row % 2) * (brickW / 2);
      for (let col = 0; col < 6; col++) {
        const x = col * brickW + offset;
        const y = row * brickH;

        if (x < size && y < size) {
          // Tijolo individual com gradiente
          const shade = Math.random() * 40 - 20;
          const brickGradient = createSafeLinearGradient(ctx, x, y, x + brickW, y + brickH, [
            { offset: 0, color: `rgb(${178 + shade}, ${34 + shade}, ${34 + shade})` },
            { offset: 1, color: `rgb(${158 + shade}, ${14 + shade}, ${14 + shade})` }
          ]);

          ctx.fillStyle = brickGradient;
          ctx.fillRect(x + 1, y + 1, brickW - 3, brickH - 3);

          // Textura do tijolo
          for (let j = 0; j < 5; j++) {
            const bx = x + 1 + Math.random() * (brickW - 3);
            const by = y + 1 + Math.random() * (brickH - 3);
            const bshade = Math.random() * 30 - 15;
            ctx.fillStyle = `rgba(${178 + bshade}, ${34 + bshade}, ${34 + bshade}, 0.3)`;
            ctx.fillRect(bx, by, 2, 2);
          }
        }
      }
    }

    // Argamassa
    ctx.fillStyle = '#CCCCCC';
    for (let i = 0; i <= 10; i++) {
      ctx.fillRect(0, i * brickH - 1, size, 2);
    }
    for (let i = 0; i <= 6; i++) {
      for (let row = 0; row < 10; row++) {
        const offset = (row % 2) * (brickW / 2);
        const x = i * brickW + offset;
        if (x < size) {
          ctx.fillRect(x - 1, 0, 2, size);
        }
      }
    }
  }

  // Textura de Bedrock
  function createEnhancedBedrockTexture(ctx, size) {
    if (!ctx || typeof size !== 'number' || size <= 0) return;

    ctx.clearRect(0, 0, size, size);

    // Base muito escura
    ctx.fillStyle = '#1C1C1C';
    ctx.fillRect(0, 0, size, size);

    // Varia√ß√£o escura
    for (let i = 0; i < size * 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.floor(Math.random() * 40 - 20);
      ctx.fillStyle = `rgb(${28 + shade}, ${28 + shade}, ${28 + shade})`;
      const s = 2 + Math.random() * 4;
      ctx.fillRect(x, y, s, s);
    }

    // Manchas escuras
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 4 + Math.random() * 8;

      const gradientRadial = createSafeRadialGradient(ctx, x, y, 0, x, y, radius, [
        { offset: 0, color: 'rgba(0, 0, 0, 0.6)' },
        { offset: 1, color: 'rgba(0, 0, 0, 0)' }
      ]);

      ctx.fillStyle = gradientRadial;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Cristais escuros
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.floor(Math.random() * 60);
      ctx.fillStyle = `rgb(${28 + shade}, ${28 + shade}, ${46 + shade})`;
      ctx.fillRect(x, y, 3, 3);
    }
  }

  // ==================== SISTEMA DE TEXTURAS PRINCIPAL ====================

  function createTexture(type, size = 64) {
    // Verificar cache
    const cacheKey = `${type}_${size}`;
    if (textureCache[cacheKey]) {
      return textureCache[cacheKey];
    }

    // Criar canvas
    const canvas = document.createElement('canvas');
    if (!canvas || !canvas.getContext) {
      console.error('N√£o foi poss√≠vel criar canvas para textura');
      return null;
    }

    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    if (!ctx) {
      console.error('N√£o foi poss√≠vel obter contexto 2D');
      return null;
    }

    // Limpar canvas
    ctx.clearRect(0, 0, size, size);

    try {
      // Chamar fun√ß√£o espec√≠fica para cada tipo
      switch(type) {
        case 'grass':
          createEnhancedGrassTexture(ctx, size);
          break;
        case 'dirt':
          createEnhancedDirtTexture(ctx, size);
          break;
        case 'stone':
          createEnhancedStoneTexture(ctx, size);
          break;
        case 'wood':
          createEnhancedWoodTexture(ctx, size);
          break;
        case 'leaves':
          createEnhancedLeavesTexture(ctx, size);
          break;
        case 'sand':
          createEnhancedSandTexture(ctx, size);
          break;
        case 'water':
          createEnhancedWaterTexture(ctx, size);
          break;
        case 'glass':
          createEnhancedGlassTexture(ctx, size);
          break;
        case 'brick':
          createEnhancedBrickTexture(ctx, size);
          break;
        case 'bedrock':
          createEnhancedBedrockTexture(ctx, size);
          break;
        default:
          // Fallback para blocos n√£o especificados
          const block = blockTypes[type];
          if (block) {
            const color = block.color || 0x808080;
            const r = (color >> 16) & 255;
            const g = (color >> 8) & 255;
            const b = color & 255;

            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            ctx.fillRect(0, 0, size, size);

            // Adicionar algum ru√≠do
            for (let i = 0; i < size * 2; i++) {
              const x = Math.random() * size;
              const y = Math.random() * size;
              const shade = Math.floor(Math.random() * 40 - 20);
              ctx.fillStyle = `rgb(${r + shade}, ${g + shade}, ${b + shade})`;
              ctx.fillRect(x, y, 2, 2);
            }
          } else {
            // Textura padr√£o cinza
            ctx.fillStyle = '#808080';
            ctx.fillRect(0, 0, size, size);
          }
      }
    } catch (error) {
      console.error(`Erro ao criar textura ${type}:`, error);
      // Fallback seguro
      ctx.fillStyle = '#808080';
      ctx.fillRect(0, 0, size, size);
    }

    // Criar textura Three.js
    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    // Armazenar em cache
    textureCache[cacheKey] = texture;
    return texture;
  }

  // ==================== SISTEMA DE MATERIAIS ====================

  async function createMaterials() {
    // Verificar se Three.js est√° dispon√≠vel
    if (typeof THREE === 'undefined') {
      console.error('Three.js n√£o est√° carregado');
      return;
    }

    // Tipos de blocos que precisam de texturas especiais
    const texturedTypes = [
      'grass', 'dirt', 'stone', 'wood', 'leaves',
      'sand', 'water', 'glass', 'brick', 'bedrock'
    ];

    // Criar materiais para cada tipo
    for (const type of texturedTypes) {
      try {
        // Obter textura
        const texture = createTexture(type, 64);

        if (!texture) {
          console.warn(`Falha ao criar textura para ${type}, usando cor s√≥lida`);
          const block = blockTypes[type];
          const color = block?.color || 0x808080;
          materials[type] = new THREE.MeshLambertMaterial({ color: color });
          continue;
        }

        const block = blockTypes[type];

        // Configurar material baseado no tipo
        if (block?.emissive) {
          materials[type] = new THREE.MeshLambertMaterial({
            map: texture,
            emissive: new THREE.Color(block.color),
            emissiveIntensity: 0.8
          });
        } else if (type === 'glass') {
          materials[type] = new THREE.MeshLambertMaterial({
            map: texture,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
          });
        } else if (type === 'water') {
          materials[type] = new THREE.MeshLambertMaterial({
            map: texture,
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
          });
        } else if (type === 'leaves') {
          materials[type] = new THREE.MeshLambertMaterial({
            map: texture,
            transparent: true,
            opacity: 0.85,
            side: THREE.DoubleSide,
            alphaTest: 0.1
          });
        } else {
          materials[type] = new THREE.MeshLambertMaterial({
            map: texture
          });
        }
      } catch (error) {
        console.error(`Erro ao criar material para ${type}:`, error);
        // Material de fallback
        const block = blockTypes[type];
        const color = block?.color || 0x808080;
        materials[type] = new THREE.MeshLambertMaterial({ color: color });
      }
    }

    // Para outros blocos n√£o especificados, criar materiais b√°sicos
    for (const type in blockTypes) {
      if (!materials[type]) {
        try {
          const block = blockTypes[type];
          const color = block?.color || 0x808080;

          if (block?.emissive) {
            materials[type] = new THREE.MeshLambertMaterial({
              color: color,
              emissive: color,
              emissiveIntensity: 0.8
            });
          } else {
            materials[type] = new THREE.MeshLambertMaterial({
              color: color
            });
          }
        } catch (error) {
          console.error(`Erro ao criar material b√°sico para ${type}:`, error);
          materials[type] = new THREE.MeshLambertMaterial({ color: 0xFF0000 }); // Vermelho para erro vis√≠vel
        }
      }
    }

    console.log(`‚úÖ Materais criados: ${Object.keys(materials).length} tipos`);
  }

  // ==================== CORRE√á√ÉO DO ANIMALS.JS ====================

  // Adicionar no in√≠cio do Animals.js para definir a vari√°vel scene globalmente
  // OU modificar o Animals.js para receber scene como par√¢metro

  // E modifique a fun√ß√£o createMesh para:
  function createMesh(geometry, material) {
    if (!scene) {
      console.error('Scene n√£o definida em Animals.js');
      console.trace(); // Mostrar onde foi chamada
      return null;
    }
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    return mesh;
  }


  // Fun√ß√£o para redimensionar a janela
  function onWindowResize() {
    if (camera && renderer) {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  }

  // Fun√ß√£o para criar material multi-textura para a grama
  function createGrassMaterial() {
    // Criar texturas para cada face
    const grassTopTexture = createGrassTopTexture(64);
    const grassSideTexture = createGrassSideTexture(64);
    const dirtTexture = createDirtTexture(64);

    // Material com texturas diferentes para cada face
    return new THREE.MeshLambertMaterial({
      map: grassSideTexture, // Textura padr√£o para laterais
      // Usaremos vertex colors para determinar qual textura usar em cada face
      vertexColors: true
    });
  }

  // Atualizar a fun√ß√£o buildChunkMesh para suportar multi-textura
  function buildChunkMesh(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);

    if (chunkMeshes[chunkKey]) {
      scene.remove(chunkMeshes[chunkKey]);
      chunkMeshes[chunkKey].children.forEach(child => {
        child.geometry.dispose();
      });
      delete chunkMeshes[chunkKey];
    }

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    const geometriesByType = {};

    for (let type in blockTypes) {
      // Para grama, vamos criar uma geometria especial
      if (type === 'grass') {
        geometriesByType[type] = {
          positions: [],
          normals: [],
          indices: [],
          uvs: [],
          colors: [], // Adicionar cores dos v√©rtices
          vertexCount: 0
        };
      } else {
        geometriesByType[type] = {
          positions: [],
          normals: [],
          indices: [],
          uvs: [],
          vertexCount: 0
        };
      }
    }

    let totalFaces = 0;

    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
      for (let lz = 0; lz < CHUNK_SIZE; lz++) {
        for (let y = 0; y < 40; y++) {
          const x = sx + lx;
          const z = sz + lz;
          const block = getBlock(x, y, z);

          if (!block) continue;

          const geo = geometriesByType[block.type];
          if (!geo) continue;

          const faces = [
            { dir: [1, 0, 0], corners: [[1, 0, 0], [1, 1, 0], [1, 1, 1], [1, 0, 1]] },
            { dir: [-1, 0, 0], corners: [[0, 0, 1], [0, 1, 1], [0, 1, 0], [0, 0, 0]] },
            { dir: [0, 1, 0], corners: [[0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 1, 0]] },
            { dir: [0, -1, 0], corners: [[0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 0, 1]] },
            { dir: [0, 0, 1], corners: [[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]] },
            { dir: [0, 0, -1], corners: [[1, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0]] }
          ];

          for (let face of faces) {
            const [dx, dy, dz] = face.dir;
            const neighbor = getBlock(x + dx, y + dy, z + dz);

            if (!neighbor) {
              const baseIdx = geo.vertexCount;

              for (let corner of face.corners) {
                geo.positions.push(
                        x + corner[0] - 0.5,
                        y + corner[1] - 0.5,
                        z + corner[2] - 0.5
                );
                geo.normals.push(dx, dy, dz);

                // Coordenadas UV
                if (dx !== 0) {
                  geo.uvs.push(corner[1], corner[2]);
                } else if (dy !== 0) {
                  geo.uvs.push(corner[0], corner[2]);
                } else {
                  geo.uvs.push(corner[0], corner[1]);
                }

                // Para grama, adicionar cores dos v√©rtices para identificar as faces
                if (block.type === 'grass') {
                  // Topo: verde (face Y positiva)
                  if (dy === 1) {
                    geo.colors.push(1.0, 1.0, 0.0); // Amarelo para identificar topo
                  }
                  // Fundo: marrom (face Y negativa)
                  else if (dy === -1) {
                    geo.colors.push(0.5, 0.3, 0.1); // Marrom para fundo
                  }
                  // Laterais: mistura
                  else {
                    geo.colors.push(0.7, 0.4, 0.2); // Marrom para laterais
                  }
                }
              }

              geo.indices.push(
                      baseIdx, baseIdx + 1, baseIdx + 2,
                      baseIdx, baseIdx + 2, baseIdx + 3
              );

              geo.vertexCount += 4;
              totalFaces++;
            }
          }
        }
      }
    }

    const group = new THREE.Group();

    for (let type in geometriesByType) {
      const geo = geometriesByType[type];

      if (geo.positions.length === 0) continue;

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(geo.positions, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(geo.normals, 3));
      geometry.setAttribute('uv', new THREE.Float32BufferAttribute(geo.uvs, 2));

      // Para grama, adicionar atributo de cor
      if (type === 'grass' && geo.colors.length > 0) {
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(geo.colors, 3));
      }

      geometry.setIndex(geo.indices);

      let material;

      // Material especial para grama
      if (type === 'grass') {
        // Criar um material que use um shader customizado para multi-textura
        material = new THREE.ShaderMaterial({
          uniforms: {
            grassTopTexture: { value: createGrassTopTexture(64) },
            grassSideTexture: { value: createGrassSideTexture(64) },
            dirtTexture: { value: createDirtTexture(64) }
          },
          vertexShader: `
          attribute vec3 color;
          varying vec3 vColor;

          void main() {
            vColor = color;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
          fragmentShader: `
          uniform sampler2D grassTopTexture;
          uniform sampler2D grassSideTexture;
          uniform sampler2D dirtTexture;
          varying vec3 vColor;

          void main() {
            // Topo (amarelo na cor do v√©rtice)
            if (vColor.r > 0.9 && vColor.g > 0.9) {
              gl_FragColor = texture2D(grassTopTexture, gl_PointCoord);
            }
            // Laterais (marrom m√©dio)
            else if (vColor.r > 0.6 && vColor.g < 0.5) {
              gl_FragColor = texture2D(grassSideTexture, gl_PointCoord);
            }
            // Fundo (marrom escuro)
            else {
              gl_FragColor = texture2D(dirtTexture, gl_PointCoord);
            }
          }
        `
        });
      } else {
        // Material normal para outros blocos
        material = materials[type];
      }

      if (material) {
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData.chunkKey = chunkKey;
        mesh.userData.type = type;
        group.add(mesh);
      }
    }

    if (group.children.length > 0) {
      scene.add(group);
      chunkMeshes[chunkKey] = group;
      chunkMeshes[chunkKey].userData.faceCount = totalFaces;
    }

    return totalFaces;
  }

  // CORRE√á√ÉO: Modificar a fun√ß√£o createInventoryUI para usar itemTypes corretamente
  function createInventoryUI() {
    const invBar = document.getElementById('inventory-bar');
    invBar.innerHTML = '';

    for (let i = 0; i < player.hotbarSlots; i++) {
      const slot = document.createElement('div');
      slot.className = `inv-slot ${i === player.selectedSlot ? 'active' : ''}`;
      slot.dataset.index = i;

      const slotData = player.inventory[i];
      if (slotData.count > 0 && slotData.type && itemTypes[slotData.type]) {
        const colorObj = itemTypes[slotData.type].color;
        let colorHex;

        // Converter cor para hexadecimal
        if (typeof colorObj === 'number') {
          colorHex = colorObj.toString(16).padStart(6, '0');
        } else {
          colorHex = 'FFFFFF'; // Branco como fallback
        }

        slot.innerHTML = `
                    <div class="block-icon" style="background: #${colorHex}"></div>
                    <div class="slot-count">${slotData.count}</div>
                `;
      }

      slot.onclick = () => selectSlot(i);
      invBar.appendChild(slot);
    }
  }

  // CORRE√á√ÉO: Adicionar event listener para pointer lock
  document.addEventListener('DOMContentLoaded', function() {
    // Adicionar evento de clique no canvas para solicitar pointer lock
    setTimeout(() => {
      if (renderer && renderer.domElement) {
        renderer.domElement.addEventListener('click', function() {
          if (document.getElementById('main-menu').style.display === 'none' && !controls.locked) {
            renderer.domElement.requestPointerLock();
          }
        });
      }
    }, 1000);
  });

  // CORRE√á√ÉO: Modificar a fun√ß√£o startGame para n√£o solicitar pointer lock automaticamente
  function startGame() {
    document.getElementById('main-menu').style.display = 'none';

    const chunk = worldToChunk(0, 0);
    player.lastChunk = chunk;

    const chunksToLoad = [];
    for (let cx = chunk.x - RENDER_DISTANCE; cx <= chunk.x + RENDER_DISTANCE; cx++) {
      for (let cz = chunk.z - RENDER_DISTANCE; cz <= chunk.z + RENDER_DISTANCE; cz++) {
        chunksToLoad.push([cx, cz]);
      }
    }

    chunksToLoad.forEach(([cx, cz]) => {
      generateChunk(cx, cz);
      spawnAnimals(cx, cz);
    });

    chunksToLoad.forEach(([cx, cz]) => {
      buildChunkMesh(cx, cz);
    });

    // Criar personagem
    if (typeof PlayerCharacter !== 'undefined') {
      playerCharacter = new PlayerCharacter();
      playerCharacter.setPosition(0, 25, 0);
      scene.add(playerCharacter.group);
    }

    // Spawnar inimigos
    chunksToLoad.forEach(([cx, cz]) => {
      spawnEnemies(cx, cz);
    });

    // Gerar vila
    if (typeof generateVillage !== 'undefined') {
      generateVillage(30, 30);
    }

    // N√£o solicitar pointer lock automaticamente
    // O usu√°rio precisa clicar no canvas primeiro
    controls.locked = false;

    animate();
  }




  init();
</script>
</body>
</html>